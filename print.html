<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Build your own Programmatic Incremental Build System</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/custom.css">
        <link rel="stylesheet" href="src/mdbook-admonish.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><div>Introduction</div></li><li class="chapter-item expanded affix "><li class="part-title">Programmability</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Setup</div></li><li class="chapter-item expanded "><a href="1_api/index.html"><strong aria-hidden="true">2.</strong> Programmable Build System API</a></li><li class="chapter-item expanded affix "><li class="part-title">Incrementality</li><li class="chapter-item expanded "><a href="2_top_down/index.html"><strong aria-hidden="true">3.</strong> Incremental Top-Down Context</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Minimality</div></li><li class="chapter-item expanded affix "><li class="part-title">Soundness</li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Prevent Overlapping File Writes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Prevent Hidden Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Prevent Cycles</div></li><li class="chapter-item expanded affix "><li class="part-title">Improvements</li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Serialization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Stamps</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Configurable Hashing</div></li><li class="chapter-item expanded affix "><li class="part-title">Efficiency</li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Incremental Bottom-Up Context</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Observability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Deferred Tasks</div></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Multiple Task Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> On Static Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> On Declarativity</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><div>Related Work</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="programmable-build-system-api"><a class="header" href="#programmable-build-system-api">Programmable Build System API</a></h1>
<p>In this first chapter, we will program the core API of the programmatic incremental build system, and implement an extremely simple non-incremental version of the build system to get started.</p>
<h2 id="task-and-context"><a class="header" href="#task-and-context">Task and Context</a></h2>
<p>The unit of computation in a programmatic build system is a <em>task</em>.
A task is kind of like a closure: a value that can be executed to produce their output.
However, in an <em>incremental</em> programmatic build system, we also need to keep track of <em>dynamic dependencies</em> that are made while tasks are executing.
Therefore, tasks are executed under a <em>build context</em> which enable them to create these dependencies.
Tasks <em>require</em> other tasks through the context, creating a dynamic dependency and returning their up-to-date output.</p>
<p>On the other hand, an incremental build context wants to <em>selectively execute tasks</em> — only those that are affected by a change.
To that end, a build context will selectively execute tasks, tasks require other tasks through the build context, the build context selectively executes those, and so forth.
Thus, tasks and build contexts are mutually recursive.</p>
<p>In this tutorial, we will be using the words <em>context</em>, <em>build context</em>, and <em>build system</em> interchangeably, typically using just <em>context</em> as it is concise.</p>
<p>Let's make tasks and contexts more concrete by defining them in code.</p>
<h3 id="api-implementation"><a class="header" href="#api-implementation">API Implementation</a></h3>
<p>Since we want users of the build system to implement their own tasks, we will define <code>Task</code> as a trait.
Likewise, we will also be implementing multiple contexts in this tutorial, so we will also define <code>Context</code> as a trait.
Add the following code to your <code>src/lib.rs</code> file:</p>
<pre><code class="language-rust ">use std::fmt::Debug;
use std::hash::Hash;

pub trait Task: Clone + Eq + Hash + Debug {
  type Output: Clone + Eq + Debug;
  fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
}

pub trait Context&lt;T: Task&gt; {
  fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
}</code></pre>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="1_api/index.html#admonition-note"></a></p>
</div>
<div>
<p>If this seems overwhelming to you, don't worry. We will go through the API and explain things. But more importantly, the API should become more clear once we implement it in the next section and subsequent chapters.
Furthermore, if you're new to Rust and/or need help understanding certain concepts, I will try to explain them in Rust Help blocks. They are collapsed by default to reduce distraction, clicking the header opens them. See the first Rust Help block at the end of this section.</p>
</div>
</div>
<p>The <code>Task</code> trait has several supertraits that we will need later in the tutorial to implement incrementality:</p>
<ul>
<li><code>Eq</code> and <code>Hash</code>: to check whether a task is equal to another one, and to create a hash of it, so we can use
a <code>HashMap</code> to get the output of a task if it is up-to-date.</li>
<li><code>Clone</code>: to create a clone of the task so that we can store it in the <code>HashMap</code> without having ownership of it.</li>
<li><code>Debug</code>: to format the task for debugging purposes.</li>
</ul>
<p>A <code>Task</code> has a single method <code>execute</code>, which takes a reference to itself (<code>&amp;self</code>), and a mutable reference to a context (<code>context: &amp;mut C</code>), and produces a value of type <code>Self::Output</code>.
Because <code>Context</code> is a trait, we use generics (<code>&lt;C: Context&lt;Self&gt;&gt;</code>) to have <code>execute</code> work for any <code>Context</code> implementation (ignoring the <code>Self</code> part for now).
The <code>execute</code> method takes self by reference such that a task can access its data, but not mutate it, as that could throw off incrementality by changing the hash/equality of the task.
Finally, the type of output of a task is defined by the <code>Output</code> associated type, and this type must implement <code>Clone</code>, <code>Eq</code>, and <code>Debug</code> for the same reason as <code>Task</code>.</p>
<p>The <code>Context</code> trait is generic over <code>Task</code>, allowing it to work with any task implementation.
It has a single method <code>require_task</code> for creating a dependency to a task and returning its up-to-date result.
It takes a mutable reference to itself, enabling dependency tracking and caching, which require mutation.
Because of this, the context reference passed to <code>Task::execute</code> is also mutable.</p>
<p>This <code>Task</code> and <code>Context</code> API mirrors the mutually recursive definition of task and context we discussed earlier, and forms the basis for the entire build system.</p>
<p>Build the project by running <code>cargo build</code>.
The output should look something like:</p>
<pre><code class="language-shell ">   Compiling pie v0.1.0 (/private/var/folders/24/8k48jl6d249_n_qfxwsl6xvm0000gn/T/.tmp8gJbkf/pie)
    Finished dev [unoptimized + debuginfo] target(s) in 0.12s
</code></pre>
<details id="admonition-rust-help" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="1_api/index.html#admonition-rust-help"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/book/ch00-00-introduction.html" title="" target="_blank">The Rust Programming Language</a> is an introductory book about Rust. I will try to provide links to the book where possible.</p>
<p>Rust has a <a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html" title="" target="_blank">module system</a> for project organization. The <code>lib.rs</code> file is the &quot;main file&quot; of a library. Later on, we will be creating more modules in different files.</p>
<p>Things are imported into the current scope with <a href="https://doc.rust-lang.org/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html" title="" target="_blank">
<code>use</code></a> statements. We import the <code>Debug</code> and <code>Hash</code> traits from the standard library with two <code>use</code> statements. Use statements use <a href="https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html" title="" target="_blank">paths</a> to refer to nested things. We use <code>::</code> for nesting, similar to namespaces in C++.</p>
<p>Rust models the concept of <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html" title="" target="_blank">ownership</a> to enable memory safety without a garbage collector.
The <code>execute</code> method accepts a <em>reference</em> to the current type, indicated with <code>&amp;</code>: <code>&amp;self</code>. This reference is <em>immutable</em>, meaning that we can read data from it, but not mutate it. In Rust, things are immutable by default.
On the other hand, <code>execute</code> accepts a <em>mutable reference</em> to the context, indicated with <code>&amp;mut</code>: <code>context: &amp;mut C</code>, which does allow mutation.</p>
<p><a href="https://doc.rust-lang.org/book/ch10-02-traits.html" title="" target="_blank">Traits</a> are the main mechanism for open extensibility in Rust. They are comparable to interfaces in class-oriented languages. We will implement a context and tasks in the next section.</p>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-supertraits-to-require-one-traits-functionality-within-another-trait" title="" target="_blank">Supertraits</a> are a kind of inheritance. The <code>: Clone + Eq + Hash + Debug</code> part of the <code>Task</code> trait means that every <code>Task</code> implementation must also implement the <code>Clone</code>, <code>Eq</code>, <code>Hash</code>, and <code>Debug</code> traits. These traits are part of the standard library:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html" title="" target="_blank">Clone</a> for duplicating values.</li>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html" title="" target="_blank">Eq</a> for equality comparisons, along with <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html" title="" target="_blank">PartialEq</a>.</li>
<li><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html" title="" target="_blank">Hash</a> for turning a value into a hash.</li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html" title="" target="_blank">Debug</a> for formatting values in a programmer-facing debugging context.</li>
</ul>
<p><code>Clone</code> and <code>Eq</code> are so common that they are part of the <a href="https://doc.rust-lang.org/std/prelude/index.html" title="" target="_blank">Rust Prelude</a>, so we don't have to import those with <code>use</code> statements.</p>
<p><a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html" title="" target="_blank">Methods</a> are functions that take a form of <code>self</code> as the first argument. This enables convenient object-like calling syntax: <code>context.require_task(&amp;task);</code>.</p>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types" title="" target="_blank">Associated types</a> are a kind of placeholder type in a trait such that methods of traits can use that type. In <code>Task</code> this allows us to talk about the <code>Output</code> type of a task. In <code>Context</code> this allows us to refer to both the <code>Task</code> type <code>T</code> and its output type <code>T::Output</code>. The <code>::</code> syntax here is used to access associated types of traits.</p>
<p>The <code>Self</code> type in a trait is a built-in associated type that is a placeholder for the type that is implementing the trait.</p>
<p>The <code>Task</code> trait is defined with <code>pub</code> (public) <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html" title="" target="_blank">visibility</a>, such that users of the library can implement it. Because <code>Task</code> uses <code>Context</code> in its public API, <code>Context</code> must also be public, even though we don't intend for users to implement their own <code>Context</code>.</p>
</div>
</details>
<h2 id="non-incremental-context"><a class="header" href="#non-incremental-context">Non-Incremental Context</a></h2>
<p>We set up the <code>Task</code> and <code>Context</code> API in such a way that we can implement incrementality.
However, incrementality is <em>hard</em>, so let's start with an extremely simple non-incremental <code>Context</code> implementation to get a feeling for the API.</p>
<h3 id="context-module"><a class="header" href="#context-module">Context module</a></h3>
<p>Since we will be implementing three different contexts in this tutorial, we will separate them in different modules.
Create the <code>context</code> module by adding a module to <code>src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::fmt::Debug;
 use std::hash::Hash;

+mod context;
+
 pub trait Task: Clone + Eq + Hash + Debug {
   type Output: Clone + Eq + Debug;
   fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
 }
</code></pre>
<p>This is a diff over <code>src/lib.rs</code> where lines with a green background are additions, lines with a red background are removals, and lines with a grey background are context on where to add/remove lines, similar to diffs on source code hubs like GitHub.</p>
<p>Create the <code>src/context</code> directory, and in it, create the <code>src/context/mod.rs</code> file with the following contents:</p>
<pre><code class="language-rust ">pub(crate) mod non_incremental;</code></pre>
<p>Then, create the <code>src/context/non_incremental.rs</code> file, it will be empty for now.
Your project structure should now look like:</p>
<pre><code>pie
├── Cargo.toml
├── target
├── Cargo.lock
└── src
    ├── context
    │   ├── non_incremental.rs
    │   └── mod.rs
    └── lib.rs
</code></pre>
<p>Confirm your module structure is correct by building with <code>cargo build</code>.</p>
<details id="admonition-rust-help-1" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="1_api/index.html#admonition-rust-help-1"></a></p>
</summary>
<div>
<p>Modules are typically <a href="https://doc.rust-lang.org/book/ch07-05-separating-modules-into-different-files.html" title="" target="_blank">separated into different files</a>.
Modules are declared with <code>mod context</code>. 
Then, the contents of a module are defined either by creating a sibling file with the same name: <code>context.rs</code>, or by creating a sibling directory with the same name, with a <code>mod.rs</code> file in it: <code>context/mod.rs</code>.
Use the latter if you intend to nest modules, otherwise use the former.</p>
<p>Like traits, modules also have <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html" title="" target="_blank">visibility</a>.</p>
</div>
</details>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<p>Implement the non-incremental context in <code>src/context/non_incremental.rs</code> by adding:</p>
<pre><code class="language-rust ">use crate::{Context, Task};

pub struct NonIncrementalContext;

impl&lt;T: Task&gt; Context&lt;T&gt; for NonIncrementalContext {
  fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output {
    task.execute(self)
  }
}</code></pre>
<p>This <code>NonIncrementalContext</code> is extremely simple: in <code>require_task</code> we unconditionally execute the task, and pass <code>self</code> along so the task we're calling can require additional tasks.
Let's write some tests to see if this does what we expect.</p>
<details id="admonition-rust-help-2" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="1_api/index.html#admonition-rust-help-2"></a></p>
</summary>
<div>
<p>In Rust, libraries are called <a href="https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html" title="" target="_blank">crates</a>.
We import the <code>Context</code> and <code>Task</code> traits from the root of your crate (i.e., the <code>src/lib.rs</code> file) using <code>crate::</code> as a prefix.</p>
<p><a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html" title="" target="_blank">Structs</a> are concrete types that can contain data through fields and implement traits, similar to classes in class-oriented languages.
Since we don't need any data in <code>NonIncrementalContext</code>, we define it as a <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#unit-like-structs-without-any-fields" title="" target="_blank">unit-like struct</a>.</p>
<p><a href="https://doc.rust-lang.org/book/ch10-02-traits.html#implementing-a-trait-on-a-type" title="" target="_blank">Traits are implemented for a type</a> with <code>impl Context for NonIncrementalContext { ... }</code>, where we then have to implement all methods and associated types of the trait.</p>
<p>The <code>Context</code> trait is generic over <code>Task</code>, so in the <code>impl</code> block we introduce a type parameter <code>T</code> with <code>impl&lt;T&gt;</code>, and use <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#using-trait-bounds-to-conditionally-implement-methods" title="" target="_blank">trait bounds</a> as <code>impl&lt;T: Task&gt;</code> to declare that <code>T</code> must implement <code>Task</code>.</p>
<p>The last expression of a function – in this case <code>task.execute(self)</code> in <code>require_task</code> which is an expression because it does not end with <code>;</code> – is used as the return value.
We could also write that as <code>return task.execute(self);</code>, but that is more verbose.</p>
</div>
</details>
<h3 id="simple-test"><a class="header" href="#simple-test">Simple Test</a></h3>
<p>Add the following test to <code>src/context/non_incremental.rs</code>:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use super::*;

  #[test]
  fn test_require_task_direct() {
    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
    struct ReturnHelloWorld;

    impl Task for ReturnHelloWorld {
      type Output = String;
      fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, _context: &amp;mut C) -&gt; Self::Output {
        &quot;Hello World!&quot;.to_string()
      }
    }

    let mut context = NonIncrementalContext;
    assert_eq!(&quot;Hello World!&quot;, context.require_task(&amp;ReturnHelloWorld));
  }
}</code></pre>
<p>In this test, we create a struct <code>ReturnHelloWorld</code> which is the &quot;hello world&quot; of the build system.
We implement <code>Task</code> for it, set its <code>Output</code> associated type to be <code>String</code>, and implement the <code>execute</code> method to just return <code>&quot;Hello World!&quot;</code>.
We derive the <code>Clone</code>, <code>Eq</code>, <code>Hash</code>, and <code>Debug</code> traits for <code>ReturnHelloWorld</code> as they are required for all <code>Task</code>
implementations.</p>
<p>We require the task with our context by creating a <code>NonIncrementalContext</code>, calling its <code>require_task</code> method, passing
in a reference to the task.
It returns the output of the task, which we test with <code>assert_eq!</code>.</p>
<p>Run the test by running <code>cargo test</code>.
The output should look something like:</p>
<pre><code class="language-shell ">   Compiling pie v0.1.0 (/private/var/folders/24/8k48jl6d249_n_qfxwsl6xvm0000gn/T/.tmp8gJbkf/pie)
    Finished test [unoptimized + debuginfo] target(s) in 0.37s
     Running unittests src/lib.rs (/private/var/folders/24/8k48jl6d249_n_qfxwsl6xvm0000gn/T/.tmp8gJbkf/pie/target/debug/deps/pie-df5bfba2a552abda)

running 1 test
test context::non_incremental::test::test_require_task_direct ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests pie

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Which indicates that the test indeed succeeds!
You can experiment by returning a different string from <code>ReturnHelloWorld::execute</code> to see what a failed test looks like.</p>
<details id="admonition-rust-help-3" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="1_api/index.html#admonition-rust-help-3"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#the-tests-module-and-cfgtest" title="" target="_blank">Unit tests</a> for a module 
are typically defined by creating a nested module named <code>test</code> with the <code>#[cfg(test)]</code> attribute applied to it. In that
<code>test</code> module, you apply <code>#[test]</code> to testing functions, which then get executed when you run <code>cargo test</code>.</p>
<p>The <code>#[cfg(...)]</code> attribute provides <a href="https://doc.rust-lang.org/reference/conditional-compilation.html" title="" target="_blank">conditional compilation</a> for the item it is applied to. In this case, <code>#[cfg(test)]</code> ensures that the module is only compiled when we run <code>cargo test</code>.</p>
<p>We import all definitions from the parent module (i.e., the <code>non_incremental</code> module) into the <code>test</code> module with <code>use super::*;</code>.</p>
<p>In Rust, <a href="https://doc.rust-lang.org/reference/items.html" title="" target="_blank">items</a> — that is, functions, structs, implementations, etc. — 
can be nested inside functions. We use that in <code>test_require_task_direct</code> to scope <code>ReturnHelloWorld</code> and its implementation
to the test function, so it can't clash with other test functions.</p>
<p>In <code>execute</code>, we use <code>_context</code> as the parameter name for the context, as the parameter is unused.
Unused parameters give a warning in Rust, unless it is prefixed by a <code>_</code>.</p>
<p><a href="https://doc.rust-lang.org/std/macro.assert_eq.html" title="" target="_blank">assert_eq!</a> is a <a href="https://doc.rust-lang.org/book/ch19-06-macros.html" title="" target="_blank">macro</a> that checks if its two expressions are equal. 
If not, it <a href="https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html" title="" target="_blank">panics</a>.
This macro is typically <a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html" title="" target="_blank">used in tests</a> for assertions, as a panic marks a test as failed.</p>
</div>
</details>
<h3 id="test-with-multiple-tasks"><a class="header" href="#test-with-multiple-tasks">Test with Multiple Tasks</a></h3>
<p>Our first test only tests a single task that does not use the context, so let's write a test with two tasks where one requires the other to increase our test coverage.
Add the following test:</p>
<pre><code class="language-rust customdiff">     }

     let mut context = NonIncrementalContext;
     assert_eq!(&quot;Hello World!&quot;, context.require_task(&amp;ReturnHelloWorld));
   }
+
+  #[test]
+  fn test_require_task_problematic() {
+    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
+    struct ReturnHelloWorld;
+    impl Task for ReturnHelloWorld {
+      type Output = String;
+      fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, _context: &amp;mut C) -&gt; Self::Output {
+        &quot;Hello World!&quot;.to_string()
+      }
+    }
+
+    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
+    struct ToLowerCase;
+    impl Task for ToLowerCase {
+      type Output = String;
+      fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
+        context.require_task(&amp;ReturnHelloWorld).to_lowercase()
+      }
+    }
+
+    let mut context = NonIncrementalContext;
+    assert_eq!(&quot;hello world!&quot;, context.require_task(&amp;ToLowerCase));
+  }
 }</code></pre>
<p>We use the same <code>ReturnHelloWorld</code> task as before, but now also have a <code>ToLowerCase</code> task which requires <code>ReturnHelloWorld</code> and then turn its string lowercase.
However, due to the way we've set up the types between <code>Task</code> and <code>Context</code>, we will run into a problem.
Running <code>cargo test</code>, you should get these errors:</p>
<pre><code class="language-shell ">   Compiling pie v0.1.0 (/private/var/folders/24/8k48jl6d249_n_qfxwsl6xvm0000gn/T/.tmp8gJbkf/pie)
error[E0308]: mismatched types
  --&gt; src/context/non_incremental.rs:48:30
   |
48 |         context.require_task(&amp;ReturnHelloWorld).to_lowercase()
   |                 ------------ ^^^^^^^^^^^^^^^^^ expected `&amp;ToLowerCase`, found `&amp;ReturnHelloWorld`
   |                 |
   |                 arguments to this method are incorrect
   |
   = note: expected reference `&amp;ToLowerCase`
              found reference `&amp;non_incremental::test::test_require_task_problematic::ReturnHelloWorld`
note: method defined here
  --&gt; src/lib.rs:12:6
   |
12 |   fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
   |      ^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `pie` due to previous error
</code></pre>
<p>The problem is that <code>execute</code> of <code>ToLowerCase</code> takes a <code>Context&lt;Self&gt;</code>, so in <code>impl Task for ToLowerCase</code> it takes a <code>Context&lt;ToLowerCase&gt;</code>, while we're trying to require <code>&amp;ReturnHelloWorld</code> through the context.
This doesn't work as <code>Context&lt;ToLowerCase&gt;::require_task</code> only takes a <code>&amp;ToLowerCase</code> as input.</p>
<p>We could change <code>execute</code> of <code>ToLowerCase</code> to take <code>Context&lt;ReturnHelloWorld&gt;</code>:</p>
<pre><code class="language-rust customdiff">
     #[derive(Clone, PartialEq, Eq, Hash, Debug)]
     struct ToLowerCase;
     impl Task for ToLowerCase {
       type Output = String;
-      fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
+      fn execute&lt;C: Context&lt;ReturnHelloWorld&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
         context.require_task(&amp;ReturnHelloWorld).to_lowercase()
       }
     }

     let mut context = NonIncrementalContext;</code></pre>
<p>But that is not allowed:</p>
<pre><code class="language-shell ">   Compiling pie v0.1.0 (/private/var/folders/24/8k48jl6d249_n_qfxwsl6xvm0000gn/T/.tmp8gJbkf/pie)
error[E0276]: impl has stricter requirements than trait
  --&gt; src/context/non_incremental.rs:47:21
   |
47 |       fn execute&lt;C: Context&lt;ReturnHelloWorld&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `C: Context&lt;non_incremental::test::test_require_task_problematic::ReturnHelloWorld&gt;`
   |
  ::: src/lib.rs:8:3
   |
8  |   fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
   |   --------------------------------------------------------------------- definition of `execute` from trait

For more information about this error, try `rustc --explain E0276`.
error: could not compile `pie` due to previous error
</code></pre>
<p>This is because the <code>Task</code> trait defines <code>execute</code> to take a <code>Context&lt;Self&gt;</code>, thus every implementation of <code>Task</code> must adhere to this, so we can't solve it this way.</p>
<p>Effectively, due to the way we defined <code>Task</code> and <code>Context</code>, we can only use <em>a single task implementation</em>.
However, there is a good reason for this which will become more apparent once we implement incrementality.</p>
<details id="admonition-why-only-a-single-task-type" class="admonition info">
<summary class="admonition-title">
<p>Why only a single Task type?</p>
<p><a class="admonition-anchor-link" href="1_api/index.html#admonition-why-only-a-single-task-type"></a></p>
</summary>
<div>
<p>The gist of it is that an incremental context wants to build a dependency graph and cache task outputs, so that we can figure out from the dependency graph whether a task is affected by a change, and just return its output if it is not affected.
For that, a context implementation will have a <code>Store&lt;T&gt;</code>.</p>
<p>A <code>Context&lt;ReturnHelloWorld&gt;</code> and <code>Context&lt;ToLowerCase&gt;</code> would have to be implemented by different types, which would have different <code>Store</code>s, which would then have completely separate dependency graphs.
That won't work, as we need a single (global) dependency graph over all tasks to figure out what is affected.</p>
</div>
</details>
<p>There is a much more complicated way to actually solve this problem, but it introduces too much complexity into the tutorial, so we will be going with a much simpler solution.
In chapter <em>TODO</em>, we will describe this solution which does support multiple task types.</p>
<p>For now, we will solve this by just using a single task type which is an enumeration of the different possible tasks.
Replace the test with the following:</p>
<pre><code class="language-rust customdiff">     let mut context = NonIncrementalContext;
     assert_eq!(&quot;Hello World!&quot;, context.require_task(&amp;ReturnHelloWorld));
   }

-  #[test]
-  fn test_require_task_problematic() {
-    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
-    struct ReturnHelloWorld;
-    impl Task for ReturnHelloWorld {
-      type Output = String;
-      fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, _context: &amp;mut C) -&gt; Self::Output {
-        &quot;Hello World!&quot;.to_string()
-      }
-    }
-
-    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
-    struct ToLowerCase;
-    impl Task for ToLowerCase {
-      type Output = String;
-      fn execute&lt;C: Context&lt;ReturnHelloWorld&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
-        context.require_task(&amp;ReturnHelloWorld).to_lowercase()
-      }
-    }
-
-    let mut context = NonIncrementalContext;
-    assert_eq!(&quot;hello world!&quot;, context.require_task(&amp;ToLowerCase));
-  }
+  #[test]
+  fn test_require_task() {
+    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
+    enum Test {
+      ReturnHelloWorld,
+      ToLowerCase,
+    }
+
+    impl Task for Test {
+      type Output = String;
+      fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
+        match self {
+          Self::ReturnHelloWorld =&gt; &quot;Hello World!&quot;.to_string(),
+          Self::ToLowerCase =&gt; context.require_task(&amp;Self::ReturnHelloWorld).to_lowercase(),
+        }
+      }
+    }
+
+    let mut context = NonIncrementalContext;
+    assert_eq!(&quot;Hello World!&quot;, context.require_task(&amp;Test::ReturnHelloWorld));
+    assert_eq!(&quot;hello world!&quot;, context.require_task(&amp;Test::ToLowerCase));
+  }
 }</code></pre>
<p>Here, we instead define a single task <code>Test</code> which is an <code>enum</code> with two variants.
In its <code>Task</code> implementation, we match ourselves and return <code>&quot;Hello World!&quot;</code> when the variant is <code>ReturnHelloWorld</code>.
When the variant is <code>ReturnHelloWorld</code>, we require <code>&amp;Self::ReturnHelloWorld</code> through the context, which is now valid because it is an instance of <code>Test</code>, and turn its string lowercase and return that.
This now works due to only having a single task type.
Run the test with <code>cargo test</code> to confirm it is working.</p>
<details id="admonition-rust-help-4" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="1_api/index.html#admonition-rust-help-4"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html" title="" target="_blank">Enums</a> define a type by a set of variants, similar to enums in other languages, sometimes called tagged unions in other languages.
The <code>match</code> expression matches the variant and dispatches based on that, similar to switch statements in other languages.</p>
</div>
</details>
<p>We have defined the API for the build system and implemented a non-incremental version of it.
We're now ready to start implementing an incremental context in the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="incremental-top-down-context"><a class="header" href="#incremental-top-down-context">Incremental Top-Down Context</a></h1>
<p>In this chapter, we will implement an <em>incremental</em> build context.
An incremental context selectively executes tasks — only those that are affected by a change.
In other words, an incremental context executes the <em>minimum number of tasks</em> required to make all tasks up-to-date.</p>
<p>However, due to dynamic dependencies, this is not trivial.
We cannot first gather all tasks into a dependency tree and then topologically sort that, as dependencies are added and removed <em>while tasks are executing</em>.
To do incremental builds in the presence of dynamic dependencies, we need to check and execute affected tasks <em>one at a time</em>, updating the dependency graph, while tasks are executing.
To achieve this, we will employ a technique called <em>top-down incremental building</em>, which starts checking if a top (root) task needs to be executed, and recursively checks whether dependent tasks should be executed until we reach the bottom (leaf) task(s), akin to a depth-first search.</p>
<p>Furthermore, build systems almost always interact with the file system in some way. 
For example, tasks read configuration and source files, or write intermediate and binary files.
Thus, a change in a file can affect a task that reads it, and executing a task can result in writing to new or existing files.
Therefore, we will also keep track of <em>file dependencies</em>.
Like task dependencies, file dependencies are also tracked dynamically while tasks are executing.</p>
<p>There are several ways to check if a file dependency is consistent (i.e., has not changed), such as checking the last modification date, or comparing a hash.
To make this configurable on a per-dependency basis, we will implement <em>stamps</em>.
A file stamp is just a value that is produced from a file, such as the modification date or hash, that is stored with the file dependency.
To check if a file dependency is consistent, we just stamp the file again and compare it with the stored stamp.</p>
<p>Similarly, we can employ stamps for task dependencies as well by stamping the output of a task.</p>
<p>Before we start coding, let's sketch the outline of the solution — we will:</p>
<ul>
<li>Extend <code>Context</code> with a way to for tasks to register file dependencies.
<ul>
<li>Implement file system utility functions in module <code>fs</code>.</li>
<li>Make <code>NonIncrementalContext</code> compatible with the extension to <code>Context</code>.</li>
</ul>
</li>
<li>Implement a <code>TopDownContext</code> that does incremental building.
<ul>
<li>Implement file and task output stamps.</li>
<li>Extend <code>Context</code> to support stampers when creating dependencies.</li>
<li>Implement file and task dependencies.</li>
<li>Implement <code>Store</code> that keeps track of the dependency graph.</li>
</ul>
</li>
<li>Write tests for <code>TopDownContext</code> to confirm that it is sound and incremental.
<ul>
<li>Implement a <code>Tracker</code> that can track build events, so we can assert whether a task has executed or not to test incrementality.</li>
</ul>
</li>
</ul>
<h2 id="adding-file-dependencies"><a class="header" href="#adding-file-dependencies">Adding File Dependencies</a></h2>
<p>To support file dependencies, add a method to the <code>Context</code> trait in <code>src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::fmt::Debug;
+use std::fs::File;
 use std::hash::Hash;
+use std::io;
+use std::path::Path;

 mod context;

 pub trait Task: Clone + Eq + Hash + Debug {
   type Output: Clone + Eq + Debug;
@@ -8,6 +11,7 @@
   fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
 }

 pub trait Context&lt;T: Task&gt; {
   fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
+  fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt;;
 }</code></pre>
<p><code>require_file</code> is similar to requiring a task, but instead takes a <code>path</code> to a file or directory on the filesystem as input.
We use <code>AsRef&lt;Path&gt;</code> as the type for the path, so that we can pass anything in that can dereference to a path.
For example, <code>str</code> has an <code>AsRef&lt;Path&gt;</code> implementation, so we can just use <code>&quot;test.txt&quot;</code> as a path.</p>
<p>As an output, we return <code>Result&lt;Option&lt;File&gt;, io::Error&gt;</code>, with <code>File</code> being a handle to an open file.
The reason for this complicated type is:</p>
<ul>
<li>An incremental context will want to read the metadata (such as the last modified date) of the file, or create a hash over the file, to be able to detect changes. Because getting metadata or reading the file can fail, and we want to propagate this error, we return a <code>Result</code> with <code>io::Error</code> as the error type.</li>
<li>Tasks can create a dependency to a file that does not exist, and the existence of that file affects the task. For example, a task that prints true or false based on if a file exists. If the file does not exist (or it is a directory), we cannot open it, so we cannot return a <code>File</code>, hence we use <code>Option&lt;File&gt;</code> to return <code>None</code>.</li>
<li>Otherwise, we return <code>Ok(Some(file))</code> so that the task can read the opened file.</li>
</ul>
<details id="admonition-rust-help" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="2_top_down/index.html#admonition-rust-help"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html" title="" target="_blank">Recoverable error handling</a> in Rust is done with the <code>Result&lt;T, E&gt;</code> type, which can either be <code>Ok(t)</code> or <code>Err(e)</code>.
In contrast to many languages which use exceptions, throwing, and exception handling; Rust treats recoverable errors just as regular values.</p>
<p>Similarly, <a href="https://doc.rust-lang.org/std/option/" title="" target="_blank">optional values</a> in Rust are defined using the <code>Option&lt;T&gt;</code> type, which can either be <code>Some(t)</code> or <code>None</code>.</p>
<p>Rust has many traits for converting values or references into others, which provides a lot of convenience in what would otherwise require a lot of explicit conversions.
<a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html" title="" target="_blank">
<code>AsRef&lt;T&gt;</code></a> is such a conversion trait, that can convert itself into <code>&amp;T</code>. 
Here, we use <code>AsRef&lt;Path&gt;</code> as a generic with a trait bound to support many different kinds of values to the <code>path</code> argument in <code>require_file</code>.
For example, we can call <code>context.require_file(&quot;test.txt&quot;)</code> because <code>str</code>, which is the type of string constants, <a href="https://doc.rust-lang.org/src/std/path.rs.html#3136-3141" title="" target="_blank">implements <code>AsRef&lt;Path&gt;</code></a>.
You can also see this as a kind of method overloading, without having to provide concrete overloads for all supported types.</p>
</div>
</details>
<p>Now we need to implement this method for <code>NonIncrementalContext</code>.
However, because we will be performing similar file system operations in the incremental context as well, we will create some utility functions for this first.</p>
<p>Add the <code>fs</code> module to <code>src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::hash::Hash;
 use std::io;
 use std::path::Path;

 mod context;
+mod fs;

 pub trait Task: Clone + Eq + Hash + Debug {
   type Output: Clone + Eq + Debug;
   fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
 }</code></pre>
<p>Create file <code>src/fs.rs</code> with:</p>
<pre><code class="language-rust ">use std::{fs, io};
use std::fs::{File, Metadata};
use std::path::Path;

/// Gets the metadata for given `path`, or `Err(e)` if there was an error getting the metadata, or `Ok(None)` if no file
/// or directory exists at given `path`.
pub fn metadata(path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Option&lt;Metadata&gt;, io::Error&gt; {
  match fs::metadata(path) {
    Err(e) if e.kind() == io::ErrorKind::NotFound =&gt; Ok(None),
    Err(e) =&gt; Err(e),
    Ok(m) =&gt; Ok(Some(m))
  }
}

/// Open file at given `path` if it exists and is a file. This is necessary because on Windows, opening a directory
/// returns an error.
pub fn open_if_file(path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
  let file = match metadata(&amp;path)? {
    Some(metadata) if metadata.is_file() =&gt; Some(File::open(&amp;path)?),
    _ =&gt; None,
  };
  Ok(file)
}</code></pre>
<p>The comments explain the behaviour.</p>
<p>We will write some tests to confirm the behaviour, but for that we need a utility to create temporary files and directories.
Instead of implementing that ourselves, we will use an existing crate.
Add the <code>tempfile</code> dependency to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml customdiff"> name = &quot;pie&quot;
 version = &quot;0.1.0&quot;
 edition = &quot;2021&quot;

 [workspace]
+
+[dev-dependencies]
+tempfile = &quot;3&quot;
</code></pre>
<p>Note that this is dependency is added under <code>dev-dependencies</code>, indicating that this dependency is only available when running tests, benchmarks, and examples.
Therefore, users of our library will not depend on this library, which is good because temporary file creation is not necessary to users of our library.</p>
<p>Now, add the following tests to <code>src/fs.rs</code>:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use std::fs::remove_file;

  use tempfile::{NamedTempFile, TempDir, TempPath};

  use super::*;

  #[test]
  fn test_metadata_ok() {
    let path = create_temp_path();
    let metadata = metadata(path);
    assert!(metadata.is_ok());
    let metadata = metadata.unwrap();
    assert!(metadata.is_some());
    let metadata = metadata.unwrap();
    assert!(metadata.is_file());
  }

  #[test]
  fn test_metadata_none() {
    let path = create_temp_path();
    remove_file(&amp;path).expect(&quot;failed to delete temporary file&quot;);
    let metadata = metadata(&amp;path);
    assert!(metadata.is_ok());
    let metadata = metadata.unwrap();
    assert!(metadata.is_none());
  }

  #[test]
  fn test_open_if_file() {
    let path = create_temp_path();
    let file = open_if_file(&amp;path);
    assert!(file.is_ok());
    let file = file.unwrap();
    assert!(file.is_some());
  }

  #[test]
  fn test_open_if_file_non_existent() {
    let path = create_temp_path();
    remove_file(&amp;path).expect(&quot;failed to delete temporary file&quot;);
    let file = open_if_file(&amp;path);
    assert!(file.is_ok());
    let file = file.unwrap();
    assert!(file.is_none());
  }

  #[test]
  fn test_open_if_file_on_directory() {
    let dir = TempDir::new().expect(&quot;failed to create temporary directory&quot;);
    let file = open_if_file(dir.path());
    assert!(file.is_ok());
    let file = file.unwrap();
    assert!(file.is_none());
  }

  fn create_temp_path() -&gt; TempPath {
    NamedTempFile::new().expect(&quot;failed to create temporary file&quot;).into_temp_path()
  }
}</code></pre>
<p>The <code>tempfile</code> library takes care of deleting temporary files when they go out of scope (at the end of the test).
Unfortunately, we can't easily test when <code>metadata</code> and <code>open_if_file</code> should return an error, because we cannot disable read permissions on files via the Rust standard library.</p>
<p>Now we are done with our filesystem utility excursion.
Make the non-incremental context compatible by changing <code>src/context/non_incremental.rs</code>:</p>
<pre><code class="language-rust customdiff">+use std::fs::File;
+use std::io;
+use std::path::Path;
+
 use crate::{Context, Task};
+use crate::fs::open_if_file;

 pub struct NonIncrementalContext;

 impl&lt;T: Task&gt; Context&lt;T&gt; for NonIncrementalContext {
   fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output {
     task.execute(self)
   }
+  fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
+    let file = open_if_file(&amp;path)?;
+    Ok(file)
+  }
 }</code></pre>
<p>Since the non-incremental context does not track anything, we simply try to open the file and return it.
This implements the description we made earlier:</p>
<ul>
<li>If opening the file results in an error, the <code>?</code> operator returns <code>Err(...)</code> immediately.</li>
<li>If the file does not exist or is a directory, <code>open_if_file</code> returns <code>None</code> and <code>file</code> is <code>None</code>.</li>
<li>Otherwise, <code>file</code> is <code>Some(file)</code>.</li>
</ul>
<p>Confirm everything works with <code>cargo test</code>.</p>
<details id="admonition-rust-help-1" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="2_top_down/index.html#admonition-rust-help-1"></a></p>
</summary>
<div>
<p>The <code>?</code> operator makes it easy to <a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator" title="" target="_blank">propgate errors</a>.
Because errors are just values in Rust, to propgate an error, you'd normally have to match each result and manually propagate the error.
The <code>r?</code> operator applied to a <code>Result</code> <code>r</code> does this for you, it basically desugars to something like <code>match r { Err(e) =&gt; return Err(e), _ =&gt; {} }</code>.</p>
<p>Comments with three forward slashes <code>///</code> are <a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments" title="" target="_blank">documentation comments</a> that document the function/struct/enum/trait/etc. they are applied to.</p>
</div>
</details>
<h2 id="implementing-the-incremental-context"><a class="header" href="#implementing-the-incremental-context">Implementing the Incremental Context</a></h2>
<p>Now we get to the fun part, incrementality!</p>
<p>To check whether we need to execute a task, we need to check the dependencies of that task to see if any of them are not consistent.
A dependency is consistent if after stamping, the new stamp equals the stored stamp.
If all dependencies of the task are consistent, we return the cached output of the task.
If not, we execute the task.</p>
<p>To implement this, we will need several components:</p>
<ul>
<li><code>FileStamper</code> and <code>FileStamp</code> types for stamping files.</li>
<li><code>OutputStamper</code> and <code>OutputStamp</code> types for stamping task outputs.</li>
<li>Extension to <code>Context</code> to support passing <code>FileStamper</code> and <code>OutputStamper</code> when requiring files and tasks.</li>
<li>A <code>FileDependency</code> type that holds a <code>FileStamper</code> and <code>FileStamp</code> to check whether a file is consistent.</li>
<li>A <code>TaskDependency</code> type that holds an <code>OutputStamper</code> and <code>OutputStamp</code> to check whether a task is consistent.</li>
<li>A <code>Dependency</code> type that merges <code>FileDependency</code> and <code>TaskDependency</code> so we can check whether a dependency is consistent without having to know what kind of dependency it is.</li>
<li>A <code>Store</code> type which holds the dependency graph with methods for interacting with the graph.</li>
<li>A <code>TopDownContext</code> type that implements <code>Context</code> in an incremental way, using <code>Store</code>.</li>
</ul>
<p>We will start with implementing stamps and dependencies, as that can be implemented as a stand-alone part.</p>
<h3 id="stamp-implementation"><a class="header" href="#stamp-implementation">Stamp implementation</a></h3>
<p>Add the <code>stamp</code> module to <code>src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::io;
 use std::path::Path;

 mod context;
 mod fs;
+pub mod stamp;

 pub trait Task: Clone + Eq + Hash + Debug {
   type Output: Clone + Eq + Debug;
   fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
 }</code></pre>
<p>Note that this module is declared <code>pub</code>, as users of the library should be able to construct stampers.</p>
<h4 id="file-stamps"><a class="header" href="#file-stamps">File stamps</a></h4>
<p>Create the <code>src/stamp.rs</code> file and add:</p>
<pre><code class="language-rust ">use std::fmt::Debug;
use std::io;
use std::path::Path;
use std::time::SystemTime;

use crate::fs::metadata;

#[derive(Clone, Eq, PartialEq, Debug)]
pub enum FileStamper {
  Exists,
  Modified,
}

impl FileStamper {
  pub fn stamp(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;FileStamp, io::Error&gt; {
    match self {
      FileStamper::Exists =&gt; {
        Ok(FileStamp::Exists(path.as_ref().try_exists()?))
      }
      FileStamper::Modified =&gt; {
        let Some(metadata) = metadata(path)? else {
          return Ok(FileStamp::Modified(None));
        };
        Ok(FileStamp::Modified(Some(metadata.modified()?)))
      }
    }
  }
}

#[derive(Clone, Eq, PartialEq, Debug)]
pub enum FileStamp {
  Exists(bool),
  Modified(Option&lt;SystemTime&gt;),
}</code></pre>
<p>We're implementing <code>FileStamper</code> as an enum for simplicity.</p>
<p>A <code>FileStamper</code> has a single method <code>stamp</code> which takes something that can be dereferenced to a path, and produces a <code>FileStamp</code> or an error if creating the stamp failed.
For now, we implement only two kinds of file stampers: <code>Exists</code> and <code>Modified</code>.
The <code>Exists</code> stamper just returns a boolean indicating whether a file exists.
It can be used to create a file dependency where a task behaves differently based on whether a file exists or not.
The <code>Modified</code> stamper returns the last modification date if the file exists, or <code>None</code> if the file does not exist.</p>
<p>We derive <code>Eq</code> for stamps so that we can compare them.
Equal stamps indicate a consistent dependency, unequal indicates inconsistent.
We also derive <code>Eq</code> for stampers, because the stamper of a dependency could change, making the dependency inconsistent.</p>
<h4 id="task-output-stamps"><a class="header" href="#task-output-stamps">Task output stamps</a></h4>
<p>We implement task output stampers in a similar way.
Add to <code>src/stamp.rs</code>:</p>
<pre><code class="language-rust ">#[derive(Clone, Eq, PartialEq, Debug)]
pub enum OutputStamper {
  Inconsequential,
  Equals,
}

impl OutputStamper {
  pub fn stamp&lt;O&gt;(&amp;self, output: O) -&gt; OutputStamp&lt;O&gt; {
    match self {
      OutputStamper::Inconsequential =&gt; OutputStamp::Inconsequential,
      OutputStamper::Equals =&gt; OutputStamp::Equals(output),
    }
  }
}

#[derive(Clone, Eq, PartialEq, Debug)]
pub enum OutputStamp&lt;O&gt; {
  Inconsequential,
  Equals(O),
}

impl&lt;O&gt; OutputStamp&lt;O&gt; {
  pub fn as_ref(&amp;self) -&gt; OutputStamp&lt;&amp;O&gt; {
    match self {
      OutputStamp::Inconsequential =&gt; OutputStamp::Inconsequential,
      OutputStamp::Equals(o) =&gt; OutputStamp::Equals(o),
    }
  }
}</code></pre>
<p>The <code>Inconsequential</code> stamper simply ignores the output and always returns the same stamp (thus is always equal).
It can be used to create a task dependency where we are interested in some side effect of a task, but don't care about its output.
The <code>Equals</code> stamper simply wraps the output of a task, so the stamp is equal when the output is equal.</p>
<p>Output stamps are generic over the task output type <code>O</code>.</p>
<details id="admonition-trait-bounds-and-derive-macros" class="admonition info">
<summary class="admonition-title">
<p>Trait bounds and derive macros</p>
<p><a class="admonition-anchor-link" href="2_top_down/index.html#admonition-trait-bounds-and-derive-macros"></a></p>
</summary>
<div>
<p>Because <code>O</code> is used in the enum, the <code>derive</code> attributes on <code>OutputStamp</code> create bounds over <code>O</code>.
Thus, <code>OutputStamp</code> is only <code>Clone</code> when <code>O</code> is <code>Clone</code>, <code>OutputStamp</code> is only <code>Clone</code> when <code>O</code> is <code>Clone</code>, and so forth.
Because we declared <code>Task::Output</code> with bound <code>Clone + Eq + Debug</code>, we can be sure that <code>OutputStamp</code> is always <code>Clone</code>, <code>Eq</code>, and <code>Debug</code>.</p>
</div>
</details>
<details id="admonition-user-definable-stamps" class="admonition info">
<summary class="admonition-title">
<p>User definable stamps</p>
<p><a class="admonition-anchor-link" href="2_top_down/index.html#admonition-user-definable-stamps"></a></p>
</summary>
<div>
<p><code>FileStamper</code> and <code>OutputStamper</code> could also be a trait which would allow users of the library to implement their own stampers.
For simplicity, we do not explore that option in this tutorial.
If you feel adventurous, you could try to implement this after you've finished the tutorial.
Do note that this introduces a lot of extra generics and trait bounds everywhere, which can be a bit cumbersome.</p>
</div>
</details>
<h4 id="tests"><a class="header" href="#tests">Tests</a></h4>
<p>Finally, we write some tests.
Add to <code>src/stamp.rs</code>:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use std::fs;

  use tempfile::{NamedTempFile, TempPath};

  use super::*;

  #[test]
  fn test_exists_file_stamper() {
    let stamper = FileStamper::Exists;
    let path = create_temp_path();
    let stamp = stamper.stamp(&amp;path).expect(&quot;failed to stamp&quot;);
    assert_eq!(stamp, stamper.stamp(&amp;path).expect(&quot;failed to stamp&quot;));

    fs::remove_file(&amp;path).expect(&quot;failed to delete temporary file&quot;);
    assert_ne!(stamp, stamper.stamp(&amp;path).expect(&quot;failed to stamp&quot;));
  }

  #[test]
  fn test_modified_file_stamper() {
    let stamper = FileStamper::Modified;
    let path = create_temp_path();
    let stamp = stamper.stamp(&amp;path).expect(&quot;failed to stamp&quot;);
    assert_eq!(stamp, stamper.stamp(&amp;path).expect(&quot;failed to stamp&quot;));

    fs::write(&amp;path, format!(&quot;{:?}&quot;, stamp)).expect(&quot;failed to write to temporary file&quot;);
    assert_ne!(stamp, stamper.stamp(&amp;path).expect(&quot;failed to stamp&quot;), &quot;modified stamp is equal after modifying file&quot;);

    fs::remove_file(&amp;path).expect(&quot;failed to delete temporary file&quot;);
    assert_ne!(stamp, stamper.stamp(&amp;path).expect(&quot;failed to stamp&quot;), &quot;modified stamp is equal after removing file&quot;);
  }

  #[test]
  fn test_inconsequential_output_stamper() {
    let stamper = OutputStamper::Inconsequential;
    let stamp = stamper.stamp(&amp;1);
    assert_eq!(stamp, stamper.stamp(&amp;1));
    assert_eq!(stamp, stamper.stamp(&amp;2));
  }

  #[test]
  fn test_equals_output_stamper() {
    let stamper = OutputStamper::Equals;
    let stamp = stamper.stamp(&amp;1);
    assert_eq!(stamp, stamper.stamp(&amp;1));
    assert_ne!(stamp, stamper.stamp(&amp;2));
  }

  fn create_temp_path() -&gt; TempPath {
    NamedTempFile::new().expect(&quot;failed to create temporary file&quot;).into_temp_path()
  }
}</code></pre>
<p>We test file stamps by creating a stamp, changing the file, creating a new stamp, and then compare the stamps.
We test task output stamps by just passing a different output value to the <code>stamp</code> function, and then compare the stamps.</p>
<p>Run <code>cargo test</code> to confirm the stamp implementation.</p>
<h3 id="stamps-in-context"><a class="header" href="#stamps-in-context">Stamps in Context</a></h3>
<p>We now have a module dedicated to stamps.
However, stampers are constructed by users of the library that author tasks, and they need to pass in these stampers when creating dependencies.
Therefore, we need to update the <code>Context</code> trait to allow passing in these stampers.</p>
<p>Change <code>Context</code> in <code>src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::fs::File;
 use std::hash::Hash;
 use std::io;
 use std::path::Path;

+use stamp::{FileStamper, OutputStamper};
+
 mod context;
 mod fs;
 pub mod stamp;

 pub trait Task: Clone + Eq + Hash + Debug {
@@ -12,8 +14,18 @@
   type Output: Clone + Eq + Debug;
   fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
 }

 pub trait Context&lt;T: Task&gt; {
-  fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
-  fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt;;
+  fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output {
+    self.require_task_with_stamper(task, self.default_output_stamper())
+  }
+  fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
+    self.require_file_with_stamper(path, self.default_file_stamper())
+  }
+
+  fn require_task_with_stamper(&amp;mut self, task: &amp;T, stamper: OutputStamper) -&gt; T::Output;
+  fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt;;
+
+  fn default_output_stamper(&amp;self) -&gt; OutputStamper { OutputStamper::Equals }
+  fn default_file_stamper(&amp;self) -&gt; FileStamper { FileStamper::Modified }
 }</code></pre>
<p>We add the <code>require_task_with_stamper</code> and <code>require_file_with_stamper</code> methods which allow passing in a stamper.
We add default implementations for the <code>require_task</code> and <code>require_file</code> methods which pass in a default stamper.
The defaults are provided by <code>default_output_stamper</code> and <code>default_file_stamper</code> which can be overridden by the context implementation.</p>
<p>Update <code>NonIncrementalContext</code> in <code>src/context/non_incremental.rs</code> to implement the new methods:</p>
<pre><code class="language-rust customdiff"> use std::io;
 use std::path::Path;

 use crate::{Context, Task};
 use crate::fs::open_if_file;
+use crate::stamp::{FileStamper, OutputStamper};

 pub struct NonIncrementalContext;

 impl&lt;T: Task&gt; Context&lt;T&gt; for NonIncrementalContext {
-  fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output {
+  fn require_task_with_stamper(&amp;mut self, task: &amp;T, _stamper: OutputStamper) -&gt; T::Output {
     task.execute(self)
   }
-  fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
+  fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, _stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
     let file = open_if_file(&amp;path)?;
     Ok(file)
   }
 }</code></pre>
<p>We just ignore the stampers in <code>NonIncrementalContext</code>, as they are only needed for incrementality.</p>
<p>Run <code>cargo test</code> to confirm everything still works.</p>
<h3 id="dependency-implementation"><a class="header" href="#dependency-implementation">Dependency implementation</a></h3>
<p>Add the <code>dependency</code> module to <code>src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use stamp::{FileStamper, OutputStamper};

 mod context;
 mod fs;
 pub mod stamp;
+mod dependency;

 pub trait Task: Clone + Eq + Hash + Debug {
   type Output: Clone + Eq + Debug;
   fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
 }</code></pre>
<p>This module is not public, as users of the library should not construct dependencies.
They should only create stampers, which are passed to dependencies via the <code>Context</code>.</p>
<h4 id="file-dependencies"><a class="header" href="#file-dependencies">File dependencies</a></h4>
<p>Create the <code>src/dependency.rs</code> file and add:</p>
<pre><code class="language-rust ">use std::fmt::Debug;
use std::fs::File;
use std::io;
use std::path::PathBuf;

use crate::{Context, Task};
use crate::fs::{metadata, open_if_file};
use crate::stamp::{FileStamp, FileStamper, OutputStamp, OutputStamper};

#[derive(Clone, Eq, PartialEq, Debug)]
pub struct FileDependency {
  pub path: PathBuf,
  pub stamper: FileStamper,
  pub stamp: FileStamp,
}

impl FileDependency {
  pub fn new(path: impl Into&lt;PathBuf&gt;, stamper: FileStamper) -&gt; Result&lt;(Self, Option&lt;File&gt;), io::Error&gt; {
    let path = path.into();
    let stamp = stamper.stamp(&amp;path)?;
    let file = open_if_file(&amp;path)?;
    let dependency = FileDependency { path, stamper, stamp };
    Ok((dependency, file))
  }

  /// Checks whether this file dependency is inconsistent, returning:
  /// - `Ok(Some(stamp))` if this dependency is inconsistent (with `stamp` being the new stamp of the dependency),
  /// - `Ok(None)` if this dependency is consistent,
  /// - `Err(e)` if there was an error checking this dependency for consistency.
  pub fn is_inconsistent(&amp;self) -&gt; Result&lt;Option&lt;FileStamp&gt;, io::Error&gt; {
    let new_stamp = self.stamper.stamp(&amp;self.path)?;
    if new_stamp == self.stamp {
      Ok(None)
    } else {
      Ok(Some(new_stamp))
    }
  }
}</code></pre>
<p>A <code>FileDependency</code> stores the <code>path</code> the dependency is about, the <code>stamper</code> used to create a stamp for this dependency, and the <code>stamp</code> that was created at the time the file dependency was made.
The <code>FileDependency::new</code> function also returns the opened file if it exists, so that users of this function can read from the file without having to open it again.</p>
<p>A file dependency is inconsistent when the stored stamp is not equal to a stamp that we create at the time of checking, implemented in <code>FileDependency::is_inconsistent</code>.
For example, if we created a file dependency (with modified stamper) for a file that was modified yesterday, then modify the file, and then call <code>is_inconsistent</code> on the file dependency, it would return <code>Some(new_stamp)</code> indicating that the dependency is inconsistent.</p>
<p>We implement an <code>is_inconsistent</code> method here instead of an <code>is_consistent</code> method, so that we can return the changed stamp when the dependency is inconsistent, which we will use for debug logging purposes later.</p>
<p>Creating and checking a file dependency can fail due to file operations failing (for example, cannot access the file), so we propagate those errors.</p>
<h4 id="task-dependencies"><a class="header" href="#task-dependencies">Task dependencies</a></h4>
<p>Task dependencies are implemented in a similar way.
Add to <code>src/dependency.rs</code>:</p>
<pre><code class="language-rust ">#[derive(Clone, Eq, PartialEq, Debug)]
pub struct TaskDependency&lt;T, O&gt; {
  pub task: T,
  pub stamper: OutputStamper,
  pub stamp: OutputStamp&lt;O&gt;,
}

impl&lt;T: Task&gt; TaskDependency&lt;T, T::Output&gt; {
  pub fn new(task: T, stamper: OutputStamper, output: T::Output) -&gt; Self {
    let stamp = stamper.stamp(output);
    Self { task, stamper, stamp }
  }

  /// Checks whether this task dependency is inconsistent, returning:
  /// - `Some(stamp)` if this dependency is inconsistent (with `stamp` being the new stamp of the dependency),
  /// - `None` if this dependency is consistent.
  pub fn is_inconsistent&lt;C: Context&lt;T&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Option&lt;OutputStamp&lt;T::Output&gt;&gt; {
    let output = context.require_task(&amp;self.task);
    let new_stamp = self.stamper.stamp(output);
    if new_stamp == self.stamp {
      None
    } else {
      Some(new_stamp)
    }
  }
}</code></pre>
<p>A <code>TaskDependency</code> stores the <code>task</code> the dependency is about, along with its <code>stamper</code> and <code>stamp</code> that is created when the dependency is created.
Task dependencies are generic over the type of tasks <code>T</code>, and their type of outputs <code>O</code>.</p>
<details id="admonition-trait-bounds-on-structs" class="admonition info">
<summary class="admonition-title">
<p>Trait bounds on structs</p>
<p><a class="admonition-anchor-link" href="2_top_down/index.html#admonition-trait-bounds-on-structs"></a></p>
</summary>
<div>
<p>We chose not to put a <code>Task</code> trait bound on <code>TaskDependency</code>, and instead put the bound on the impl.
There are several up and downsides to that should be considered when making such a decision.</p>
<p>The main upside for putting the <code>Task</code> bound on the <code>TaskDependency</code> struct, is that we can leave out <code>O</code> and use <code>OutputStamp&lt;T::Output&gt;</code> as the type of the <code>stamp</code> field.
This cuts down a generic parameter, which reduces boilerplate.
The downside is that we need to then put the <code>Task</code> bound on every struct that uses <code>TaskDependency</code>, which increases boilerplate.</p>
<p>Furthermore, some <code>derive</code> macros may behave differently or fail to work with trait bounds on tasks.
For example, the derive macros from <code>serde</code> which we will use for serialization later do not seem to work well with trait bounds on structs (or I did not figure out how to make them work).
Therefore, it is better to not put <code>Task</code> bounds on structs in this library.</p>
</div>
</details>
<p>A task dependency is inconsistent if, after recursively checking it, its stamp has changed, implemented in <code>TaskDependency::is_inconsistent</code>.
Usually, this will be using the <code>Equals</code> task output stamper, so a task dependency is usually inconsistent when the output of the task changes.</p>
<p>Because we need to recursively check the task, <code>TaskDependency::is_inconsistent</code> requires a context to be passed in.</p>
<h4 id="dependency-enum"><a class="header" href="#dependency-enum">Dependency enum</a></h4>
<p>Finally, we create a <code>Dependency</code> enum that abstracts over these two kinds of dependencies.
Add to <code>src/dependency.rs</code>:</p>
<pre><code class="language-rust ">#[derive(Clone, Eq, PartialEq, Debug)]
pub enum Dependency&lt;T, O&gt; {
  RequireFile(FileDependency),
  RequireTask(TaskDependency&lt;T, O&gt;),
}

#[derive(Clone, Eq, PartialEq, Debug)]
pub enum InconsistentDependency&lt;O&gt; {
  File(FileStamp),
  Task(OutputStamp&lt;O&gt;),
}

impl&lt;T: Task&gt; Dependency&lt;T, T::Output&gt; {
  /// Checks whether this dependency is inconsistent, returning:
  /// - `Ok(Some(stamp))` if the dependency is inconsistent (with `stamp` being the new stamp of the dependency),
  /// - `Ok(None)` if the dependency is consistent,
  /// - `Err(e)` if there was an error checking the dependency for consistency.
  pub fn is_inconsistent&lt;C: Context&lt;T&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Result&lt;Option&lt;InconsistentDependency&lt;T::Output&gt;&gt;, io::Error&gt; {
    let option = match self {
      Dependency::RequireFile(d) =&gt; d.is_inconsistent()?
        .map(|s| InconsistentDependency::File(s)),
      Dependency::RequireTask(d) =&gt; d.is_inconsistent(context)
        .map(|s| InconsistentDependency::Task(s)),
    };
    Ok(option)
  }
}</code></pre>
<p><code>Dependency</code> just merges the two kinds of dependencies and provides an <code>is_inconsistent</code> method that calls the corresponding method.
This will make it easier to write a dependency graph implementation later.</p>
<p>We return the changed stamp here as well for debug logging later.
We wrap the changed stamp in an <code>InconsistentDependency</code> enum, and map to the correct variant if there is an inconsistency.</p>
<p>Because <code>Dependency</code> can store a <code>TaskDependency</code>, we need to propagate the <code>T</code> and <code>O</code> generics.
Likewise, <code>InconsistentDependency</code> propagates the <code>O</code> generic for <code>OutputStamp</code>.</p>
<details id="admonition-user-definable-dependencies" class="admonition info">
<summary class="admonition-title">
<p>User definable dependencies</p>
<p><a class="admonition-anchor-link" href="2_top_down/index.html#admonition-user-definable-dependencies"></a></p>
</summary>
<div>
<p>Like with stampers, <code>Dependency</code> could also be a trait to allow users of the library to define their own dependencies.
However, as we will see later, these dynamic dependencies also require validation, and I am unsure how such a <code>Dependency</code> trait should look.
Therefore, we don't have an appendix on how to implement this.
But, if you have an idea on how to this nicely (after you've completed this tutorial), please get in touch!</p>
</div>
</details>
<h4 id="tests-1"><a class="header" href="#tests-1">Tests</a></h4>
<p>As usual, we write some tests to confirm the behaviour.
Add tests to <code>src/dependency.rs</code>:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use std::fs;
  use std::io::Read;

  use tempfile::{NamedTempFile, TempPath};

  use crate::context::non_incremental::NonIncrementalContext;

  use super::*;

  #[derive(Clone, PartialEq, Eq, Hash, Debug)]
  struct ReadStringFromFile(PathBuf);

  impl Task for ReadStringFromFile {
    type Output = String;
    fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
      let mut string = String::new();
      let file = context.require_file(&amp;self.0)
        .expect(&quot;failed to require file&quot;);
      if let Some(mut file) = file {
        file.read_to_string(&amp;mut string)
          .expect(&quot;failed to read from file&quot;);
      };
      string
    }
  }

  #[test]
  fn test_file_dependency_consistency() {
    let mut context = NonIncrementalContext;

    let path = create_temp_path();
    fs::write(&amp;path, &quot;test1&quot;)
      .expect(&quot;failed to write to file&quot;);

    let (file_dependency, _) = FileDependency::new(&amp;path, FileStamper::Modified)
      .expect(&quot;failed to create file dependency&quot;);
    let dependency: Dependency&lt;ReadStringFromFile, String&gt; = Dependency::RequireFile(file_dependency.clone());
    assert!(file_dependency.is_inconsistent().expect(&quot;failed to check for inconsistency&quot;).is_none());
    assert!(dependency.is_inconsistent(&amp;mut context).expect(&quot;failed to check for inconsistency&quot;).is_none());

    fs::write(&amp;path, &quot;test2&quot;)
      .expect(&quot;failed to write to file&quot;);
    assert!(file_dependency.is_inconsistent().expect(&quot;failed to check for inconsistency&quot;).is_some());
    assert!(dependency.is_inconsistent(&amp;mut context).expect(&quot;failed to check for inconsistency&quot;).is_some());
  }

  #[test]
  fn test_task_dependency_consistency() {
    let mut context = NonIncrementalContext;

    let path = create_temp_path();
    fs::write(&amp;path, &quot;test1&quot;)
      .expect(&quot;failed to write to file&quot;);
    let task = ReadStringFromFile(path.to_path_buf());
    let output = context.require_task(&amp;task);

    let task_dependency = TaskDependency::new(task.clone(), OutputStamper::Equals, output);
    let dependency = Dependency::RequireTask(task_dependency.clone());
    assert!(task_dependency.is_inconsistent(&amp;mut context).is_none());
    assert!(dependency.is_inconsistent(&amp;mut context).expect(&quot;failed to check for inconsistency&quot;).is_none());

    fs::write(&amp;path, &quot;test2&quot;)
      .expect(&quot;failed to write to file&quot;);
    assert!(task_dependency.is_inconsistent(&amp;mut context).is_some());
    assert!(dependency.is_inconsistent(&amp;mut context).expect(&quot;failed to check for inconsistency&quot;).is_some());
  }

  fn create_temp_path() -&gt; TempPath {
    NamedTempFile::new().expect(&quot;failed to create temporary file&quot;).into_temp_path()
  }
}</code></pre>
<p>We test a file dependency by asserting that <code>is_inconsistent</code> returns <code>Some</code> after changing the file.</p>
<p>Testing task dependencies requires a bit more work.
We create task <code>ReadStringFromFile</code> that reads a string from a file, and then returns that string as output.
We require the task to get its output (<code>&quot;test1&quot;</code>), and create a task dependency with it.
Then, we change the file and check consistency of the task dependency.
That recursively requires the task, the context will execute the task, and the task now returns (<code>&quot;test2&quot;</code>).
Since we use the <code>Equals</code> output stamper, and <code>&quot;test1&quot;</code> does not equal <code>&quot;test2&quot;</code>, the dependency is inconsistent and returns a stamp containing <code>&quot;test2&quot;</code>.</p>
<p>Note that we are both testing the specific dependencies (<code>FileDependency</code> and <code>TaskDependency</code>), and the general <code>Dependency</code>.</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="2_top_down/index.html#admonition-note"></a></p>
</div>
<div>
<p>Normally, a task such as <code>ReadStringFromFile</code> shound return a <code>Result&lt;String, io::Error&gt;</code>, but for testing purposes we are just using panics with <code>expect</code>.</p>
<p>In the file dependency case, using <code>Dependency</code> requires an explicit type annotation because there is no task to infer the type from.
We just use <code>Dependency&lt;ReadStringFromFile, String&gt;</code> as the type, and this is fine even though we don't use <code>ReadStringFromFile</code> in that test, because the <code>Dependency::RequireFile</code> variant does not use those types.</p>
</div>
</div>
<p>Run <code>cargo test</code> to confirm everything still works.
You will get some warnings about unused things, but that is ok as we will use them in the next section.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/diff.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
