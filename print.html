<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Build your own Programmatic Incremental Build System</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/diff2html.min.css">
        <link rel="stylesheet" href="src/mdbook-admonish.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Introduction</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Programmability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="1_programmability/0_setup/index.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="1_programmability/1_api/index.html"><strong aria-hidden="true">2.2.</strong> Programmable Build System API</a></li><li class="chapter-item expanded "><a href="1_programmability/2_non_incremental/index.html"><strong aria-hidden="true">2.3.</strong> Non-Incremental Context</a></li></ol></li><li class="chapter-item expanded "><a href="2_incrementality/index.html"><strong aria-hidden="true">3.</strong> Incrementality</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2_incrementality/1_require_file/index.html"><strong aria-hidden="true">3.1.</strong> Requiring Files</a></li><li class="chapter-item expanded "><a href="2_incrementality/2_stamp/index.html"><strong aria-hidden="true">3.2.</strong> Stamps</a></li><li class="chapter-item expanded "><a href="2_incrementality/3_dependency/index.html"><strong aria-hidden="true">3.3.</strong> Dynamic Dependencies</a></li><li class="chapter-item expanded "><a href="2_incrementality/4_store/index.html"><strong aria-hidden="true">3.4.</strong> Dependency Graph Store</a></li><li class="chapter-item expanded "><a href="2_incrementality/5_context/index.html"><strong aria-hidden="true">3.5.</strong> Incremental Top-Down Context</a></li><li class="chapter-item expanded "><a href="2_incrementality/6_example/index.html"><strong aria-hidden="true">3.6.</strong> Incrementality Example</a></li></ol></li><li class="chapter-item expanded "><a href="3_min_sound/index.html"><strong aria-hidden="true">4.</strong> Testing Incrementality & Soundness</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3_min_sound/1_session/index.html"><strong aria-hidden="true">4.1.</strong> Minimality with Sessions</a></li><li class="chapter-item expanded "><a href="3_min_sound/2_tracker/index.html"><strong aria-hidden="true">4.2.</strong> Tracking Build Events</a></li><li class="chapter-item expanded "><a href="3_min_sound/3_test/index.html"><strong aria-hidden="true">4.3.</strong> Integration Testing</a></li><li class="chapter-item expanded "><a href="3_min_sound/4_fix_task_dep/index.html"><strong aria-hidden="true">4.4.</strong> Fix Superfluous Task Dependency</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> Prevent Overlapping File Writes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.6.</strong> Prevent Hidden Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.7.</strong> Prevent Cycles</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Improvements</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Serialization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> More Stampers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Configurable Hashing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Efficiency</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Incremental Bottom-Up Context</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Observability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Deferred Tasks</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Multiple Task Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> On Static Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> On Declarativity</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Related Work</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
<!-- CHANGE: removed all but light and ayu theme, and renamed ayu to dark -->                          
<!--                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>-->
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<div id="admonition-under-construction" class="admonition warning">
<div class="admonition-title">
<p>Under construction</p>
<p><a class="admonition-anchor-link" href="1_programmability/0_setup/index.html#admonition-under-construction"></a></p>
</div>
<div>
<p>This page was quickly created to make setup possible, but is unfinished.</p>
</div>
</div>
<p>Make sure <a href="https://www.rust-lang.org/tools/install">Rust is installed</a>.</p>
<p>We start by creating a new Rust crate.
Create the <code>pie</code> directory and create the <code>pie/Cargo.toml</code> file with the following contents:</p>
<pre><code class="language-toml ">[package]
name = &quot;pie&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
</code></pre>
<p>Then create the <code>pie/src</code> directory and create the <code>pie/src/lib.rs</code> file, which will be left empty for now.</p>
<p>Run <code>cargo build</code> to test if the project was set up correctly.
The output should look something like:</p>
<pre><code class="language-shell ">   Compiling pie v0.1.0 (/pie)
    Finished dev [unoptimized + debuginfo] target(s) in 0.11s
</code></pre>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="1_programmability/0_setup/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="1_programmability/0_setup/../../gen/1_programmability/0_setup/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programmable-build-system-api"><a class="header" href="#programmable-build-system-api">Programmable Build System API</a></h1>
<p>In this section, we will program the core API of the programmatic incremental build system.</p>
<p>The unit of computation in a programmatic build system is a <em>task</em>.
A task is kind of like a closure: a value that can be executed to produce their output.
However, in an <em>incremental</em> programmatic build system, we also need to keep track of <em>dynamic dependencies</em> that are made while tasks are executing.
Therefore, tasks are executed under a <em>build context</em> which enable them to create these dependencies.
Tasks <em>require</em> other tasks through the context, creating a dynamic dependency and returning their up-to-date output.</p>
<p>On the other hand, an incremental build context wants to <em>selectively execute tasks</em> — only those that are affected by a change.
To that end, a build context will selectively execute tasks, tasks require other tasks through the build context, the build context selectively executes those, and so forth.
Thus, tasks and build contexts are mutually recursive.</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="1_programmability/1_api/index.html#admonition-note"></a></p>
</div>
<div>
<p>In this tutorial, we will be using the words <em>context</em>, <em>build context</em>, and <em>build system</em> interchangeably, typically using just <em>context</em> as it is concise.</p>
</div>
</div>
<p>Let's make tasks and contexts more concrete by defining them in code.</p>
<h2 id="api-implementation"><a class="header" href="#api-implementation">API Implementation</a></h2>
<p>Since we want users of the build system to implement their own tasks, we will define <code>Task</code> as a trait.
Likewise, we will also be implementing multiple contexts in this tutorial, so we will also define <code>Context</code> as a trait.
Add the following code to your <code>pie/src/lib.rs</code> file:</p>
<pre><code class="language-rust ">use std::fmt::Debug;
use std::hash::Hash;

/// A unit of computation in a programmatic incremental build system.
pub trait Task: Clone + Eq + Hash + Debug {
  /// Type of output this task returns when executed.
  type Output: Clone + Eq + Debug;
  /// Execute the task, using `context` to specify dynamic dependencies, returning `Self::Output`.
  fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
}

/// Programmatic incremental build context, enabling tasks to create dynamic dependencies that context implementations 
/// use for incremental execution.
pub trait Context&lt;T: Task&gt; {
  /// Requires given `task`, recording a dependency and selectively executing it. Returns its up-to-date output.
  fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
}</code></pre>
<div id="admonition-note-1" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="1_programmability/1_api/index.html#admonition-note-1"></a></p>
</div>
<div>
<p>If this seems overwhelming to you, don't worry. We will go through the API and explain things. But more importantly, the API should become more clear once we implement it in the next section and subsequent chapters.
Furthermore, if you're new to Rust and/or need help understanding certain concepts, I will try to explain them in Rust Help blocks. They are collapsed by default to reduce distraction, clicking the header opens them. See the first Rust Help block at the end of this section.</p>
</div>
</div>
<p>The <code>Task</code> trait has several supertraits that we will need later in the tutorial to implement incrementality:</p>
<ul>
<li><code>Eq</code> and <code>Hash</code>: to check whether a task is equal to another one, and to create a hash of it, so we can use
a <code>HashMap</code> to get the output of a task if it is up-to-date.</li>
<li><code>Clone</code>: to create a clone of the task so that we can store it in the <code>HashMap</code> without having ownership of it.</li>
<li><code>Debug</code>: to format the task for debugging purposes.</li>
</ul>
<p>A <code>Task</code> has a single method <code>execute</code>, which takes a reference to itself (<code>&amp;self</code>), and a mutable reference to a context (<code>context: &amp;mut C</code>), and produces a value of type <code>Self::Output</code>.
Because <code>Context</code> is a trait, we use generics (<code>&lt;C: Context&lt;Self&gt;&gt;</code>) to have <code>execute</code> work for any <code>Context</code> implementation (ignoring the <code>Self</code> part for now).
The <code>execute</code> method takes self by reference such that a task can access its data, but not mutate it, as that could throw off incrementality by changing the hash/equality of the task.
Finally, the type of output of a task is defined by the <code>Output</code> associated type, and this type must implement <code>Clone</code>, <code>Eq</code>, and <code>Debug</code> for the same reason as <code>Task</code>.</p>
<p>The <code>Context</code> trait is generic over <code>Task</code>, allowing it to work with any task implementation.
It has a single method <code>require_task</code> for creating a dependency to a task and returning its up-to-date result.
It takes a mutable reference to itself, enabling dependency tracking and caching, which require mutation.
Because of this, the context reference passed to <code>Task::execute</code> is also mutable.</p>
<p>This <code>Task</code> and <code>Context</code> API mirrors the mutually recursive definition of task and context we discussed earlier, and forms the basis for the entire build system.</p>
<p>Build the project by running <code>cargo build</code>.
The output should look something like:</p>
<pre><code class="language-shell ">   Compiling pie v0.1.0 (/pie)
    Finished dev [unoptimized + debuginfo] target(s) in 0.06s
</code></pre>
<details id="admonition-rust-help" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="1_programmability/1_api/index.html#admonition-rust-help"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/book/ch00-00-introduction.html">The Rust Programming Language</a> is an introductory book about Rust. I will try to provide links to the book where possible.</p>
<p>Rust has a <a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">module system</a> for project organization. The <code>lib.rs</code> file is the &quot;main file&quot; of a library. Later on, we will be creating more modules in different files.</p>
<p>Things are imported into the current scope with <a href="https://doc.rust-lang.org/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><code>use</code></a> statements. We import the <code>Debug</code> and <code>Hash</code> traits from the standard library with two <code>use</code> statements. Use statements use <a href="https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">paths</a> to refer to nested things. We use <code>::</code> for nesting, similar to namespaces in C++.</p>
<p>Rust models the concept of <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">ownership</a> to enable memory safety without a garbage collector.
The <code>execute</code> method accepts a <em>reference</em> to the current type, indicated with <code>&amp;</code>: <code>&amp;self</code>. This reference is <em>immutable</em>, meaning that we can read data from it, but not mutate it. In Rust, things are immutable by default.
On the other hand, <code>execute</code> accepts a <em>mutable reference</em> to the context, indicated with <code>&amp;mut</code>: <code>context: &amp;mut C</code>, which does allow mutation.</p>
<p><a href="https://doc.rust-lang.org/book/ch10-02-traits.html">Traits</a> are the main mechanism for open extensibility in Rust. They are comparable to interfaces in class-oriented languages. We will implement a context and tasks in the next section.</p>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-supertraits-to-require-one-traits-functionality-within-another-trait">Supertraits</a> are a kind of inheritance. The <code>: Clone + Eq + Hash + Debug</code> part of the <code>Task</code> trait means that every <code>Task</code> implementation must also implement the <code>Clone</code>, <code>Eq</code>, <code>Hash</code>, and <code>Debug</code> traits. These traits are part of the standard library:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">Clone</a> for duplicating values.</li>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">Eq</a> for equality comparisons, along with <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">PartialEq</a>.</li>
<li><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html">Hash</a> for turning a value into a hash.</li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug</a> for formatting values in a programmer-facing debugging context.</li>
</ul>
<p><code>Clone</code> and <code>Eq</code> are so common that they are part of the <a href="https://doc.rust-lang.org/std/prelude/index.html">Rust Prelude</a>, so we don't have to import those with <code>use</code> statements.</p>
<p><a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html">Methods</a> are functions that take a form of <code>self</code> as the first argument. This enables convenient object-like calling syntax: <code>context.require_task(&amp;task);</code>.</p>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types">Associated types</a> are a kind of placeholder type in a trait such that methods of traits can use that type. In <code>Task</code> this allows us to talk about the <code>Output</code> type of a task. In <code>Context</code> this allows us to refer to both the <code>Task</code> type <code>T</code> and its output type <code>T::Output</code>. The <code>::</code> syntax here is used to access associated types of traits.</p>
<p>The <code>Self</code> type in a trait is a built-in associated type that is a placeholder for the type that is implementing the trait.</p>
<p>The <code>Task</code> trait is defined with <code>pub</code> (public) <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html">visibility</a>, such that users of the library can implement it. Because <code>Task</code> uses <code>Context</code> in its public API, <code>Context</code> must also be public, even though we don't intend for users to implement their own <code>Context</code>.</p>
</div>
</details>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="1_programmability/1_api/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="1_programmability/1_api/../../gen/1_programmability/1_api/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-incremental-context"><a class="header" href="#non-incremental-context">Non-Incremental Context</a></h1>
<p>We set up the <code>Task</code> and <code>Context</code> API in such a way that we can implement incrementality.
However, incrementality is <em>hard</em>, so let's start with an extremely simple non-incremental <code>Context</code> implementation to get a feeling for the API.</p>
<h2 id="context-module"><a class="header" href="#context-module">Context module</a></h2>
<p>Since we will be implementing three different contexts in this tutorial, we will separate them in different modules.
Create the <code>context</code> module by adding a module to <code>pie/src/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_0"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -1,6 +1,8 @@
 use std::fmt::Debug;
 use std::hash::Hash;
 
+pub mod context;
+
 /// A unit of computation in a programmatic incremental build system.
 pub trait Task: Clone + Eq + Hash + Debug {
   /// Type of output this task returns when executed.
`;
    let target = document.getElementById('diff2html_0');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>This is a diff over <code>pie/src/lib.rs</code> where lines with a green background are additions, lines with a red background are removals, lines without a special background are context on where to add/remove lines, and lines starting with <code>@@</code> denote changed lines (in unified diff style). This is similar to diffs on source code hubs like GitHub.</p>
<p>Create the <code>pie/src/context</code> directory, and in it, create the <code>pie/src/context/mod.rs</code> file with the following contents:</p>
<pre><code class="language-rust ">pub mod non_incremental;</code></pre>
<p>Both modules are public so that users of our library can access context implementations.</p>
<p>Create the <code>pie/src/context/non_incremental.rs</code> file, it will be empty for now.
Your project structure should now look like:</p>
<pre><code>pie
├── Cargo.toml
├── Cargo.lock
├── target
└── src
    ├── context
    │   ├── non_incremental.rs
    │   └── mod.rs
    └── lib.rs
</code></pre>
<p>Confirm your module structure is correct by building with <code>cargo build</code>.</p>
<details id="admonition-rust-help" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="1_programmability/2_non_incremental/index.html#admonition-rust-help"></a></p>
</summary>
<div>
<p>Modules are typically <a href="https://doc.rust-lang.org/book/ch07-05-separating-modules-into-different-files.html">separated into different files</a>.
Modules are declared with <code>mod context</code>. 
Then, the contents of a module are defined either by creating a sibling file with the same name: <code>context.rs</code>, or by creating a sibling directory with the same name, with a <code>mod.rs</code> file in it: <code>context/mod.rs</code>.
Use the latter if you intend to nest modules, otherwise use the former.</p>
<p>Like traits, modules also have <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html">visibility</a>.</p>
</div>
</details>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>Implement the non-incremental context in <code>pie/src/context/non_incremental.rs</code> by adding:</p>
<pre><code class="language-rust ">use crate::{Context, Task};

pub struct NonIncrementalContext;

impl&lt;T: Task&gt; Context&lt;T&gt; for NonIncrementalContext {
  fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output {
    task.execute(self)
  }
}
</code></pre>
<p>This <code>NonIncrementalContext</code> is extremely simple: in <code>require_task</code> we unconditionally execute the task, and pass <code>self</code> along so the task we're calling can require additional tasks.
Let's write some tests to see if this does what we expect.</p>
<details id="admonition-rust-help-1" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="1_programmability/2_non_incremental/index.html#admonition-rust-help-1"></a></p>
</summary>
<div>
<p>In Rust, libraries are called <a href="https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html">crates</a>.
We import the <code>Context</code> and <code>Task</code> traits from the root of your crate (i.e., the <code>src/lib.rs</code> file) using <code>crate::</code> as a prefix.</p>
<p><a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html">Structs</a> are concrete types that can contain data through fields and implement traits, similar to classes in class-oriented languages.
Since we don't need any data in <code>NonIncrementalContext</code>, we define it as a <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#unit-like-structs-without-any-fields">unit-like struct</a>.</p>
<p><a href="https://doc.rust-lang.org/book/ch10-02-traits.html#implementing-a-trait-on-a-type">Traits are implemented for a type</a> with <code>impl Context for NonIncrementalContext { ... }</code>, where we then have to implement all methods and associated types of the trait.</p>
<p>The <code>Context</code> trait is generic over <code>Task</code>, so in the <code>impl</code> block we introduce a type parameter <code>T</code> with <code>impl&lt;T&gt;</code>, and use <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#using-trait-bounds-to-conditionally-implement-methods">trait bounds</a> as <code>impl&lt;T: Task&gt;</code> to declare that <code>T</code> must implement <code>Task</code>.</p>
<p>The last expression of a function – in this case <code>task.execute(self)</code> in <code>require_task</code> which is an expression because it does not end with <code>;</code> – is used as the return value.
We could also write that as <code>return task.execute(self);</code>, but that is more verbose.</p>
</div>
</details>
<h2 id="simple-test"><a class="header" href="#simple-test">Simple Test</a></h2>
<p>Add the following test to <code>pie/src/context/non_incremental.rs</code>:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use super::*;

  #[test]
  fn test_require_task_direct() {
    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
    struct ReturnHelloWorld;

    impl Task for ReturnHelloWorld {
      type Output = String;
      fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, _context: &amp;mut C) -&gt; Self::Output {
        &quot;Hello World!&quot;.to_string()
      }
    }

    let mut context = NonIncrementalContext;
    assert_eq!(&quot;Hello World!&quot;, context.require_task(&amp;ReturnHelloWorld));
  }
}</code></pre>
<p>In this test, we create a struct <code>ReturnHelloWorld</code> which is the &quot;hello world&quot; of the build system.
We implement <code>Task</code> for it, set its <code>Output</code> associated type to be <code>String</code>, and implement the <code>execute</code> method to just return <code>&quot;Hello World!&quot;</code>.
We derive the <code>Clone</code>, <code>Eq</code>, <code>Hash</code>, and <code>Debug</code> traits for <code>ReturnHelloWorld</code> as they are required for all <code>Task</code>
implementations.</p>
<p>We require the task with our context by creating a <code>NonIncrementalContext</code>, calling its <code>require_task</code> method, passing
in a reference to the task.
It returns the output of the task, which we test with <code>assert_eq!</code>.</p>
<p>Run the test by running <code>cargo test</code>.
The output should look something like:</p>
<pre><code class="language-shell ">   Compiling pie v0.1.0 (/pie)
    Finished test [unoptimized + debuginfo] target(s) in 0.84s
     Running unittests src/lib.rs (/pie/target/debug/deps/pie-2022d1785b8ce336)

running 1 test
test context::non_incremental::test::test_require_task_direct ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests pie

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Which indicates that the test indeed succeeds!
You can experiment by returning a different string from <code>ReturnHelloWorld::execute</code> to see what a failed test looks like.</p>
<details id="admonition-rust-help-2" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="1_programmability/2_non_incremental/index.html#admonition-rust-help-2"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#the-tests-module-and-cfgtest">Unit tests</a> for a module 
are typically defined by creating a nested module named <code>test</code> with the <code>#[cfg(test)]</code> attribute applied to it. In that
<code>test</code> module, you apply <code>#[test]</code> to testing functions, which then get executed when you run <code>cargo test</code>.</p>
<p>The <code>#[cfg(...)]</code> attribute provides <a href="https://doc.rust-lang.org/reference/conditional-compilation.html">conditional compilation</a> for the item it is applied to. In this case, <code>#[cfg(test)]</code> ensures that the module is only compiled when we run <code>cargo test</code>.</p>
<p>We import all definitions from the parent module (i.e., the <code>non_incremental</code> module) into the <code>test</code> module with <code>use super::*;</code>.</p>
<p>In Rust, <a href="https://doc.rust-lang.org/reference/items.html">items</a> — that is, functions, structs, implementations, etc. — 
can be nested inside functions. We use that in <code>test_require_task_direct</code> to scope <code>ReturnHelloWorld</code> and its implementation
to the test function, so it can't clash with other test functions.</p>
<p>In <code>execute</code>, we use <code>_context</code> as the parameter name for the context, as the parameter is unused.
Unused parameters give a warning in Rust, unless it is prefixed by a <code>_</code>.</p>
<p><a href="https://doc.rust-lang.org/std/macro.assert_eq.html">assert_eq!</a> is a <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">macro</a> that checks if its two expressions are equal. 
If not, it <a href="https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html">panics</a>.
This macro is typically <a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html">used in tests</a> for assertions, as a panic marks a test as failed.</p>
</div>
</details>
<h2 id="test-with-multiple-tasks"><a class="header" href="#test-with-multiple-tasks">Test with Multiple Tasks</a></h2>
<p>Our first test only tests a single task that does not use the context, so let's write a test with two tasks where one requires the other to increase our test coverage.
Add the following test:</p>
<div class="diff2html" id="diff2html_1"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/non_incremental.rs
+++ pie/src/context/non_incremental.rs
@@ -17,4 +17,28 @@
     let mut context = NonIncrementalContext;
     assert_eq!("Hello World!", context.require_task(&ReturnHelloWorld));
   }
+
+  #[test]
+  fn test_require_task_problematic() {
+    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
+    struct ReturnHelloWorld;
+    impl Task for ReturnHelloWorld {
+      type Output = String;
+      fn execute<C: Context<Self>>(&self, _context: &mut C) -> Self::Output {
+        "Hello World!".to_string()
+      }
+    }
+
+    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
+    struct ToLowerCase;
+    impl Task for ToLowerCase {
+      type Output = String;
+      fn execute<C: Context<Self>>(&self, context: &mut C) -> Self::Output {
+        context.require_task(&ReturnHelloWorld).to_lowercase()
+      }
+    }
+
+    let mut context = NonIncrementalContext;
+    assert_eq!("hello world!", context.require_task(&ToLowerCase));
+  }
 }
`;
    let target = document.getElementById('diff2html_1');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We use the same <code>ReturnHelloWorld</code> task as before, but now also have a <code>ToLowerCase</code> task which requires <code>ReturnHelloWorld</code> and then turn its string lowercase.
However, due to the way we've set up the types between <code>Task</code> and <code>Context</code>, we will run into a problem.
Running <code>cargo test</code>, you should get these errors:</p>
<pre><code class="language-shell ">   Compiling pie v0.1.0 (/pie)
error[E0308]: mismatched types
  --&gt; src/context/non_incremental.rs:47:30
   |
47 |         context.require_task(&amp;ReturnHelloWorld).to_lowercase()
   |                 ------------ ^^^^^^^^^^^^^^^^^ expected `&amp;ToLowerCase`, found `&amp;ReturnHelloWorld`
   |                 |
   |                 arguments to this method are incorrect
   |
   = note: expected reference `&amp;ToLowerCase`
              found reference `&amp;non_incremental::test::test_require_task_problematic::ReturnHelloWorld`
note: method defined here
  --&gt; src/lib.rs:18:6
   |
18 |   fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
   |      ^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `pie` (lib test) due to previous error
</code></pre>
<p>The problem is that <code>execute</code> of <code>ToLowerCase</code> takes a <code>Context&lt;Self&gt;</code>, so in <code>impl Task for ToLowerCase</code> it takes a <code>Context&lt;ToLowerCase&gt;</code>, while we're trying to require <code>&amp;ReturnHelloWorld</code> through the context.
This doesn't work as <code>Context&lt;ToLowerCase&gt;::require_task</code> only takes a <code>&amp;ToLowerCase</code> as input.</p>
<p>We could change <code>execute</code> of <code>ToLowerCase</code> to take <code>Context&lt;ReturnHelloWorld&gt;</code>:</p>
<div class="diff2html" id="diff2html_2"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/non_incremental.rs
+++ pie/src/context/non_incremental.rs
@@ -33,7 +33,7 @@
     struct ToLowerCase;
     impl Task for ToLowerCase {
       type Output = String;
-      fn execute<C: Context<Self>>(&self, context: &mut C) -> Self::Output {
+      fn execute<C: Context<ReturnHelloWorld>>(&self, context: &mut C) -> Self::Output {
         context.require_task(&ReturnHelloWorld).to_lowercase()
       }
     }
`;
    let target = document.getElementById('diff2html_2');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>But that is not allowed:</p>
<pre><code class="language-shell ">   Compiling pie v0.1.0 (/pie)
error[E0276]: impl has stricter requirements than trait
  --&gt; src/context/non_incremental.rs:46:21
   |
46 |       fn execute&lt;C: Context&lt;ReturnHelloWorld&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `C: Context&lt;non_incremental::test::test_require_task_problematic::ReturnHelloWorld&gt;`
   |
  ::: src/lib.rs:11:3
   |
11 |   fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
   |   --------------------------------------------------------------------- definition of `execute` from trait

For more information about this error, try `rustc --explain E0276`.
error: could not compile `pie` (lib test) due to previous error
</code></pre>
<p>This is because the <code>Task</code> trait defines <code>execute</code> to take a <code>Context&lt;Self&gt;</code>, thus every implementation of <code>Task</code> must adhere to this, so we can't solve it this way.</p>
<p>Effectively, due to the way we defined <code>Task</code> and <code>Context</code>, we can only use <em>a single task implementation</em>.
However, there is a good reason for this which will become more apparent once we implement incrementality.</p>
<details id="admonition-why-only-a-single-task-type" class="admonition info">
<summary class="admonition-title">
<p>Why only a single Task type?</p>
<p><a class="admonition-anchor-link" href="1_programmability/2_non_incremental/index.html#admonition-why-only-a-single-task-type"></a></p>
</summary>
<div>
<p>The gist of it is that an incremental context wants to build a <em>single dependency graph</em> and cache task outputs, so that we can figure out from the graph whether a task is affected by a change, and just return its output if it is not affected.
Therefore, a context implementation will maintain a <code>Store&lt;T&gt;</code>.</p>
<p>A <code>Context&lt;ReturnHelloWorld&gt;</code> and <code>Context&lt;ToLowerCase&gt;</code> would then have a <code>Store&lt;ReturnHelloWorld&gt;</code> and <code>Store&lt;ToLowerCase&gt;</code> respectively.
These two stores would then maintain two different dependency graphs, one where the nodes in the graph are <code>ReturnHelloWorld</code> and one where the nodes are <code>ToLowerCase</code>.
But that won't work, as we need a single dependency graph over all tasks to figure out what is affected.</p>
<p>There are several solutions to this problem.
For example, we could use <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">trait objects</a>.
However, this introduces a whole slew of problems because many traits that we use are not trait-object safe. 
<code>Clone</code> is not object safe because it requires <code>Sized</code>. 
<code>Eq</code> is not object safe because it uses <code>Self</code>. 
Serializing trait-objects is problematic.
There are workarounds for all these things, but it is not pretty and very complicated.</p>
<p>Another solution would be to encapsulate different tasks into a single type, using (procedural) macros to automatically generate this single task type.
This solution is more feasible, but still introduces a lot of complexity which is not worth it in this tutorial.</p>
<p>Therefore, in this tutorial we will keep it simple.</p>
</div>
</details>
<p>For now, we will solve this by just using a single task type which is an enumeration of the different possible tasks.
First remove the problematic test:</p>
<div class="diff2html" id="diff2html_3"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/non_incremental.rs
+++ pie/src/context/non_incremental.rs
@@ -17,28 +17,4 @@
     let mut context = NonIncrementalContext;
     assert_eq!("Hello World!", context.require_task(&ReturnHelloWorld));
   }
-
-  #[test]
-  fn test_require_task_problematic() {
-    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
-    struct ReturnHelloWorld;
-    impl Task for ReturnHelloWorld {
-      type Output = String;
-      fn execute<C: Context<Self>>(&self, _context: &mut C) -> Self::Output {
-        "Hello World!".to_string()
-      }
-    }
-
-    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
-    struct ToLowerCase;
-    impl Task for ToLowerCase {
-      type Output = String;
-      fn execute<C: Context<ReturnHelloWorld>>(&self, context: &mut C) -> Self::Output {
-        context.require_task(&ReturnHelloWorld).to_lowercase()
-      }
-    }
-
-    let mut context = NonIncrementalContext;
-    assert_eq!("hello world!", context.require_task(&ToLowerCase));
-  }
 }
`;
    let target = document.getElementById('diff2html_3');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Then add the following test:</p>
<div class="diff2html" id="diff2html_4"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/non_incremental.rs
+++ pie/src/context/non_incremental.rs
@@ -17,4 +17,27 @@
     let mut context = NonIncrementalContext;
     assert_eq!("Hello World!", context.require_task(&ReturnHelloWorld));
   }
+
+  #[test]
+  fn test_require_task() {
+    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
+    enum Test {
+      ReturnHelloWorld,
+      ToLowerCase,
+    }
+
+    impl Task for Test {
+      type Output = String;
+      fn execute<C: Context<Self>>(&self, context: &mut C) -> Self::Output {
+        match self {
+          Self::ReturnHelloWorld => "Hello World!".to_string(),
+          Self::ToLowerCase => context.require_task(&Self::ReturnHelloWorld).to_lowercase(),
+        }
+      }
+    }
+
+    let mut context = NonIncrementalContext;
+    assert_eq!("Hello World!", context.require_task(&Test::ReturnHelloWorld));
+    assert_eq!("hello world!", context.require_task(&Test::ToLowerCase));
+  }
 }
`;
    let target = document.getElementById('diff2html_4');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Here, we instead define a single task <code>Test</code> which is an <code>enum</code> with two variants.
In its <code>Task</code> implementation, we match ourselves and return <code>&quot;Hello World!&quot;</code> when the variant is <code>ReturnHelloWorld</code>.
When the variant is <code>ReturnHelloWorld</code>, we require <code>&amp;Self::ReturnHelloWorld</code> through the context, which is now valid because it is an instance of <code>Test</code>, and turn its string lowercase and return that.
This now works due to only having a single task type.
Run the test with <code>cargo test</code> to confirm it is working.</p>
<details id="admonition-rust-help-3" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="1_programmability/2_non_incremental/index.html#admonition-rust-help-3"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html">Enums</a> define a type by a set of variants, similar to enums in other languages, sometimes called tagged unions in other languages.
The <code>match</code> expression matches the variant and dispatches based on that, similar to switch statements in other languages.</p>
</div>
</details>
<p>We have defined the API for the build system and implemented a non-incremental version of it.
We're now ready to start implementing an incremental context in the next chapter.</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="1_programmability/2_non_incremental/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="1_programmability/2_non_incremental/../../gen/1_programmability/2_non_incremental/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>In this chapter, we will implement an <em>incremental</em> build context.
An incremental context selectively executes tasks — only those that are affected by a change.
In other words, an incremental context executes the <em>minimum number of tasks</em> required to make all tasks up-to-date.</p>
<p>However, due to dynamic dependencies, this is not trivial.
We cannot first gather all tasks into a dependency tree and then topologically sort that, as dependencies are added and removed <em>while tasks are executing</em>.
To do incremental builds in the presence of dynamic dependencies, we need to check and execute affected tasks <em>one at a time, updating the dependency graph, while tasks are executing</em>.
To achieve this, we will employ a technique called <em>top-down incremental building</em>, where we start checking if a top (root) task needs to be executed, and recursively check whether dependent tasks should be executed until we reach the bottom (leaf) task(s), akin to a depth-first search.</p>
<p>Furthermore, build systems almost always interact with the file system in some way. 
For example, tasks read configuration and source files, or write intermediate and binary files.
Thus, a change in a file can affect a task that reads it, and executing a task can result in writing to new or existing files.
Therefore, we will also keep track of <em>file dependencies</em>.
Like task dependencies, file dependencies are also tracked dynamically while tasks are executing.</p>
<p>There are several ways to check if a file dependency is consistent (i.e., has not changed), such as checking the last modification date, or comparing a hash.
To make this configurable on a per-dependency basis, we will implement <em>stamps</em>.
A file stamp is just a value that is produced from a file, such as the modification date or hash, that is stored with the file dependency.
To check if a file dependency is consistent, we just stamp the file again and compare it with the stored stamp.</p>
<p>Similarly, we can employ stamps for task dependencies as well by stamping the output of a task.</p>
<p>To achieve incrementality, we will continue with these steps in the following sections:</p>
<ol>
<li>Extend <code>Context</code> with a method to <em>require a file</em>, enabling tasks to specify dynamic dependencies to files.</li>
<li>Implement <em>file stamps</em> and <em>task output stamps</em>, and extend <code>Context</code> with methods to select <em>stampers</em>, enabling tasks to specify when a dependency is consistent.</li>
<li>Implement <em>dynamic dependencies</em> and their <em>consistency checking</em>.</li>
<li>Implement a <em>dependency graph store</em> with methods to query and mutate the dependency graph. </li>
<li>Implement the <em>top-down incremental context</em> that incrementally executes tasks.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="requiring-files"><a class="header" href="#requiring-files">Requiring Files</a></h1>
<p>Since build systems frequently interact with files, and changes to files can affect tasks, we need to keep track of file dependencies.
Therefore, we will extend the <code>Context</code> API with methods to <em>require files</em>, enabling tasks to specify dynamic dependencies to files.</p>
<p>Add a method to the <code>Context</code> trait in <code>pie/src/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_0"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -1,5 +1,8 @@
 use std::fmt::Debug;
+use std::fs::File;
 use std::hash::Hash;
+use std::io;
+use std::path::Path;
 
 pub mod context;
 
@@ -14,6 +17,13 @@
 /// Programmatic incremental build context, enabling tasks to create dynamic dependencies that context implementations 
 /// use for incremental execution.
 pub trait Context<T: Task> {
+  /// Requires file at given ${"`"}path${"`"}, recording a dependency to it. Call this method *just before reading from the file*, 
+  /// so that the dependency corresponds to the data that you are reading. Returns:
+  /// - ${"`"}Ok(Some(file))${"`"} if a file exists at given ${"`"}path${"`"}, 
+  /// - ${"`"}Ok(None)${"`"} if no file exists at given ${"`"}path${"`"} (but a directory could exist at given ${"`"}path${"`"}),
+  /// - ${"`"}Err(e)${"`"} if there was an error getting the metadata for given ${"`"}path${"`"}, or if there was an error opening the file. 
+  fn require_file<P: AsRef<Path>>(&mut self, path: P) -> Result<Option<File>, io::Error>;
+
   /// Requires given ${"`"}task${"`"}, recording a dependency and selectively executing it. Returns its up-to-date output.
   fn require_task(&mut self, task: &T) -> T::Output;
 }
`;
    let target = document.getElementById('diff2html_0');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p><code>require_file</code> is similar to requiring a task, but instead takes a <code>path</code> to a file or directory on the filesystem as input.
We use <code>AsRef&lt;Path&gt;</code> as the type for the path, so that we can pass anything in that can dereference to a path.
For example, <code>str</code> has an <code>AsRef&lt;Path&gt;</code> implementation, so we can just use <code>&quot;test.txt&quot;</code> as a path.</p>
<p>As an output, we return <code>Result&lt;Option&lt;File&gt;, io::Error&gt;</code>, with <code>File</code> being a handle to an open file.
The reason for this complicated type is:</p>
<ul>
<li>An incremental context will want to read the metadata (such as the last modified date) of the file, or create a hash over the file, to be able to detect changes. Because getting metadata or reading the file can fail, and we want to propagate this error, we return a <code>Result</code> with <code>io::Error</code> as the error type.</li>
<li>Tasks can create a dependency to a file that does not exist, and the existence of that file affects the task. For example, a task that prints true or false based on if a file exists. If the file does not exist (or it is a directory), we cannot open it, so we cannot return a <code>File</code>, hence we use <code>Option&lt;File&gt;</code> to return <code>None</code>.</li>
<li>Otherwise, we return <code>Ok(Some(file))</code> so that the task can read the opened file.</li>
</ul>
<details id="admonition-rust-help" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="2_incrementality/1_require_file/index.html#admonition-rust-help"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html">Recoverable error handling</a> in Rust is done with the <code>Result&lt;T, E&gt;</code> type, which can either be <code>Ok(t)</code> or <code>Err(e)</code>.
In contrast to many languages which use exceptions, throwing, and exception handling; Rust treats recoverable errors just as regular values.</p>
<p>Similarly, <a href="https://doc.rust-lang.org/std/option/">optional values</a> in Rust are defined using the <code>Option&lt;T&gt;</code> type, which can either be <code>Some(t)</code> or <code>None</code>.</p>
<p>Rust has many traits for converting values or references into others, which provides a lot of convenience in what would otherwise require a lot of explicit conversions.
<a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef&lt;T&gt;</code></a> is such a conversion trait, that can convert itself into <code>&amp;T</code>. 
Here, we use <code>AsRef&lt;Path&gt;</code> as a generic with a trait bound to support many different kinds of values to the <code>path</code> argument in <code>require_file</code>.
For example, we can call <code>context.require_file(&quot;test.txt&quot;)</code> because <code>str</code>, which is the type of string constants, <a href="https://doc.rust-lang.org/src/std/path.rs.html#3136-3141">implements <code>AsRef&lt;Path&gt;</code></a>.
You can also see this as a kind of method overloading, without having to provide concrete overloads for all supported types.</p>
</div>
</details>
<p>Now we need to implement this method for <code>NonIncrementalContext</code>.
However, because we will be performing similar file system operations in the incremental context as well, we will create some utility functions for this first.</p>
<p>Add the <code>fs</code> module to <code>pie/src/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_1"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -5,6 +5,7 @@
 use std::path::Path;
 
 pub mod context;
+mod fs;
 
 /// A unit of computation in a programmatic incremental build system.
 pub trait Task: Clone + Eq + Hash + Debug {
`;
    let target = document.getElementById('diff2html_1');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Create file <code>pie/src/fs.rs</code> with:</p>
<pre><code class="language-rust ">use std::{fs, io};
use std::fs::{File, Metadata};
use std::path::Path;

/// Gets the metadata for given `path`, returning:
/// - `Ok(Some(metadata))` if a file or directory exists at given path,
/// - `Ok(None)` if no file or directory exists at given path,
/// - `Err(e)` if there was an error getting the metadata for given path.
pub fn metadata(path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Option&lt;Metadata&gt;, io::Error&gt; {
  match fs::metadata(path) {
    Err(e) if e.kind() == io::ErrorKind::NotFound =&gt; Ok(None),
    Err(e) =&gt; Err(e),
    Ok(m) =&gt; Ok(Some(m))
  }
}

/// Attempt to open file at given `path`, returning:
/// - `Ok(Some(file))` if the file exists at given path, 
/// - `Ok(None)` if no file exists at given path (but a directory could exist at given path),
/// - `Err(e)` if there was an error getting the metadata for given path, or if there was an error opening the file.
///
/// This function is necessary due to Windows returning an error when attempting to open a directory.
pub fn open_if_file(path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
  let file = match metadata(&amp;path)? {
    Some(metadata) if metadata.is_file() =&gt; Some(File::open(&amp;path)?),
    _ =&gt; None,
  };
  Ok(file)
}
</code></pre>
<p>The <code>metadata</code> function gets the filesystem metadata given a path, and <code>open_if_file</code> opens the file for given path.
The reason for these functions is that the standard library function <code>std::fs::metadata</code> treats non-existent files as an error, whereas we don't want to treat it as an error and just return <code>None</code>.
Furthermore, <code>open_if_file</code> works around an issue where opening a directory on Windows (and possibly other operating systems) is an error, where we want to treat it as <code>None</code> again.
The documentation comments explain the exact behaviour.</p>
<details id="admonition-rust-help-1" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="2_incrementality/1_require_file/index.html#admonition-rust-help-1"></a></p>
</summary>
<div>
<p>The <code>?</code> operator makes it easy to <a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">propgate errors</a>.
Because errors are just values in Rust, to propgate an error, you'd normally have to match each result and manually propagate the error.
The <code>r?</code> operator applied to a <code>Result</code> <code>r</code> does this for you, it basically desugars to something like <code>match r { Err(e) =&gt; return Err(e), _ =&gt; {} }</code>.</p>
<p>Comments with three forward slashes <code>///</code> are <a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments">documentation comments</a> that document the function/struct/enum/trait/etc. they are applied to.</p>
</div>
</details>
<p>We will write some tests to confirm the behaviour, but for that we need utilities to create temporary files and directories.
Furthermore, we will be writing more unit tests, integration tests, and even benchmarks in this tutorial, so we will set up these utilities in such a way that they are reachable by all these use cases.
The only way to do that in Rust right now, is to create a separate crate and have the <code>pie</code> crate depend on it.</p>
<p>And yes, we went from adding file dependencies, to creating file system utilities, to testing those file system utilities, to creating testing utilities, and now to making a crate for those testing utilities.
Sorry about that 😅, we will start unwinding this stack soon!</p>
<p>Next to the <code>pie</code> directory, create a directory named <code>dev_shared</code>.
Create the <code>dev_shared/Cargo.toml</code> file with the following contents:</p>
<pre><code class="language-toml ">[package]
name = &quot;dev_shared&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
tempfile = &quot;3&quot;
</code></pre>
<p>We've added the <code>tempfile</code> dependency here already, which is a crate that creates and automatically cleans up temporary files and directories.</p>
<details id="admonition-rust-help-2" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="2_incrementality/1_require_file/index.html#admonition-rust-help-2"></a></p>
</summary>
<div>
<p>We use other libraries (crates) by <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">specifying dependencies</a>.
Because basically every Rust library adheres to <a href="https://semver.org/">semantic versioning</a>, we can use <code>&quot;3&quot;</code> as a version requirement which indicates that we will use the most up-to-date <code>3.x.x</code> version.</p>
</div>
</details>
<p>Create the main library file <code>dev_shared/src/lib.rs</code>, with functions for creating temporary files and directories:</p>
<pre><code class="language-rust ">use std::io;

use tempfile::{NamedTempFile, TempDir};

/// Creates a new temporary file that gets cleaned up when dropped.
pub fn create_temp_file() -&gt; Result&lt;NamedTempFile, io::Error&gt; { NamedTempFile::new() }

/// Creates a new temporary directory that gets cleaned up when dropped.
pub fn create_temp_dir() -&gt; Result&lt;TempDir, io::Error&gt; { TempDir::new() }</code></pre>
<p>Your directory structure should now look like this:</p>
<pre><code>├── pie
│   ├── Cargo.toml
│   ├── Cargo.lock
│   ├── target
│   └── src
│       ├── fs.rs
│       ├── context
│       │   ├── non_incremental.rs
│       │   └── mod.rs
│       └── lib.rs
└── dev_shared
    ├── Cargo.toml
    └── src
        └── lib.rs
</code></pre>
<p>To access these utility functions in the <code>pie</code> crate, add a dependency to <code>dev_shared</code> in <code>pie/Cargo.toml</code> along with another create that will help testing:</p>
<div class="diff2html" id="diff2html_2"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/Cargo.toml
+++ pie/Cargo.toml
@@ -2,3 +2,7 @@
 name = "pie"
 version = "0.1.0"
 edition = "2021"
+
+[dev-dependencies]
+dev_shared = { path = "../dev_shared" }
+assert_matches = "1"
`;
    let target = document.getElementById('diff2html_2');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We've also added the <a href="https://crates.io/crates/assert_matches">assert_matches</a> crate, which is a handy library for asserting that a value matches a pattern.
Note that these dependencies are added under <code>dev-dependencies</code>, indicating that these dependencies are only available when running tests, benchmarks, and examples.
Therefore, users of our library will not depend on these crates, which is good, because temporary file management and assertions are not necessary to users of the library.</p>
<p>Back to testing our filesystem utilities.
Add the following tests to <code>pie/src/fs.rs</code>:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use std::fs::remove_file;
  use std::io;

  use assert_matches::assert_matches;

  use dev_shared::{create_temp_dir, create_temp_file};

  use super::*;

  #[test]
  fn test_metadata_ok() -&gt; Result&lt;(), io::Error&gt; {
    let temp_file = create_temp_file()?;
    let metadata = metadata(temp_file)?;
    assert_matches!(metadata, Some(metadata) =&gt; {
      assert!(metadata.is_file());  
    });
    Ok(())
  }

  #[test]
  fn test_metadata_none() -&gt; Result&lt;(), io::Error&gt; {
    let temp_file = create_temp_file()?;
    remove_file(&amp;temp_file)?;
    let metadata = metadata(&amp;temp_file)?;
    assert!(metadata.is_none());
    Ok(())
  }

  #[test]
  fn test_open_if_file() -&gt; Result&lt;(), io::Error&gt; {
    let temp_file = create_temp_file()?;
    let file = open_if_file(&amp;temp_file)?;
    assert!(file.is_some());
    Ok(())
  }

  #[test]
  fn test_open_if_file_non_existent() -&gt; Result&lt;(), io::Error&gt; {
    let temp_file = create_temp_file()?;
    remove_file(&amp;temp_file)?;
    let file = open_if_file(&amp;temp_file)?;
    assert!(file.is_none());
    Ok(())
  }

  #[test]
  fn test_open_if_file_on_directory() -&gt; Result&lt;(), io::Error&gt; {
    let temp_dir = create_temp_dir()?;
    let file = open_if_file(temp_dir)?;
    assert!(file.is_none());
    Ok(())
  }
}</code></pre>
<p>We test whether the functions conform to the specified behaviour.
Unfortunately, we can't easily test when <code>metadata</code> and <code>open_if_file</code> should return an error, because we cannot disable read permissions on files via the Rust standard library.</p>
<p>We use our <code>create_temp_file</code> and <code>create_temp_dir</code> utility functions to create temporary files and directories.
The <code>tempfile</code> library takes care of deleting temporary files when they go out of scope (at the end of the test).</p>
<p>We use <code>assert_matches!</code> to assert that <code>metadata</code> is <code>Some(metadata)</code>, binding <code>metadata</code> in the <code> =&gt; { ... }</code> block in which we assert that the metadata describes a file.
We will use this macro more in future integration tests.</p>
<details id="admonition-rust-help-3" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="2_incrementality/1_require_file/index.html#admonition-rust-help-3"></a></p>
</summary>
<div>
<p>Tests can <a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html#using-resultt-e-in-tests">return <code>Result</code></a>.
When a test returns an <code>Err</code>, the test fails.
This allows us to write more concise tests using error propagation.</p>
</div>
</details>
<p>Now we are done unwinding our stack and have filesystem and testing utilities.
Make the non-incremental context compatible by changing <code>pie/src/context/non_incremental.rs</code>:</p>
<div class="diff2html" id="diff2html_3"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/non_incremental.rs
+++ pie/src/context/non_incremental.rs
@@ -1,8 +1,17 @@
+use std::fs::File;
+use std::io;
+use std::path::Path;
+
 use crate::{Context, Task};
+use crate::fs::open_if_file;
 
 pub struct NonIncrementalContext;
 
 impl<T: Task> Context<T> for NonIncrementalContext {
+  fn require_file<P: AsRef<Path>>(&mut self, path: P) -> Result<Option<File>, io::Error> {
+    open_if_file(&path)
+  }
+
   fn require_task(&mut self, task: &T) -> T::Output {
     task.execute(self)
   }
`;
    let target = document.getElementById('diff2html_3');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Since the non-incremental context does not track anything, we only try to open the file and return it, matching the contract in the documentation comment of the <code>Context::require_file</code> trait method.</p>
<p>Confirm everything works with <code>cargo test</code>.</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="2_incrementality/1_require_file/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="2_incrementality/1_require_file/../../gen/2_incrementality/1_require_file/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stamps"><a class="header" href="#stamps">Stamps</a></h1>
<p>To check whether we need to execute a task, we need to check the dependencies of that task to see if any of them are inconsistent.
To make this consistency checking configurable, we will use stamps.
A dependency is inconsistent if after stamping, the new stamp is different from the old stamp.
Therefore, we will implement a <code>FileStamper</code> that stamps files and produces a <code>FileStamp</code>, and an <code>OutputStamper</code> that stamps task outputs and produces an <code>OutputStamp</code>.</p>
<p>Add the <code>stamp</code> module to <code>pie/src/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_0"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -4,6 +4,7 @@
 use std::io;
 use std::path::Path;
 
+pub mod stamp;
 pub mod context;
 mod fs;
 
`;
    let target = document.getElementById('diff2html_0');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>This module is public as users of the library will construct stampers.</p>
<h2 id="file-stamps"><a class="header" href="#file-stamps">File stamps</a></h2>
<p>Create the <code>pie/src/stamp.rs</code> file and add:</p>
<pre><code class="language-rust ">use std::fmt::Debug;
use std::io;
use std::path::Path;
use std::time::SystemTime;

use crate::fs::metadata;

#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]
pub enum FileStamper {
  Exists,
  Modified,
}

#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]
pub enum FileStamp {
  Exists(bool),
  Modified(Option&lt;SystemTime&gt;),
}

impl FileStamper {
  pub fn stamp(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;FileStamp, io::Error&gt; {
    match self {
      FileStamper::Exists =&gt; {
        Ok(FileStamp::Exists(path.as_ref().try_exists()?))
      }
      FileStamper::Modified =&gt; {
        let Some(metadata) = metadata(path)? else {
          return Ok(FileStamp::Modified(None));
        };
        Ok(FileStamp::Modified(Some(metadata.modified()?)))
      }
    }
  }
}</code></pre>
<p>We're implementing <code>FileStamper</code> as an enum for simplicity.</p>
<p>A <code>FileStamper</code> has a single method <code>stamp</code> which takes something that can be dereferenced to a path, and produces a <code>FileStamp</code> or an error if creating the stamp failed.
For now, we implement only two kinds of file stampers: <code>Exists</code> and <code>Modified</code>.
The <code>Exists</code> stamper just returns a boolean indicating whether a file exists.
It can be used to create a file dependency where a task behaves differently based on whether a file exists or not.
The <code>Modified</code> stamper returns the last modification date if the file exists, or <code>None</code> if the file does not exist.</p>
<p>We derive <code>Eq</code> for stamps so that we can compare them.
Equal (same) stamps indicate a consistent dependency, unequal (different) indicates inconsistent.
We also derive <code>Eq</code> for stampers, because the stamper of a dependency could change, making the dependency inconsistent.</p>
<h2 id="task-output-stamps"><a class="header" href="#task-output-stamps">Task output stamps</a></h2>
<p>We implement task output stampers in a similar way.
Add to <code>pie/src/stamp.rs</code>:</p>
<pre><code class="language-rust ">#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]
pub enum OutputStamper {
  Inconsequential,
  Equals,
}

#[derive(Clone, Eq, PartialEq, Debug)]
pub enum OutputStamp&lt;O&gt; {
  Inconsequential,
  Equals(O),
}

impl OutputStamper {
  pub fn stamp&lt;O&gt;(&amp;self, output: O) -&gt; OutputStamp&lt;O&gt; {
    match self {
      OutputStamper::Inconsequential =&gt; OutputStamp::Inconsequential,
      OutputStamper::Equals =&gt; OutputStamp::Equals(output),
    }
  }
}</code></pre>
<p>The <code>Inconsequential</code> stamper simply ignores the output and always returns the same stamp (thus is always equal).
It can be used to create a task dependency where we are interested in some side effect of a task, but don't care about its output.
The <code>Equals</code> stamper simply wraps the output of a task, so the stamp is equal when the output is equal.</p>
<p>Output stamps are generic over the task output type <code>O</code>.</p>
<details id="admonition-trait-bounds-and-derive-macros" class="admonition info">
<summary class="admonition-title">
<p>Trait bounds and derive macros</p>
<p><a class="admonition-anchor-link" href="2_incrementality/2_stamp/index.html#admonition-trait-bounds-and-derive-macros"></a></p>
</summary>
<div>
<p>Because <code>O</code> is used in the enum, the <code>derive</code> attributes on <code>OutputStamp</code> create bounds over <code>O</code>.
Thus, <code>OutputStamp</code> is only <code>Clone</code> when <code>O</code> is <code>Clone</code>, <code>OutputStamp</code> is only <code>Eq</code> when <code>O</code> is <code>Eq</code>, and so forth.
Because we declared <code>Task::Output</code> with bound <code>Clone + Eq + Debug</code>, we can be sure that <code>OutputStamp</code> is always <code>Clone</code>, <code>Eq</code>, and <code>Debug</code>.</p>
</div>
</details>
<details id="admonition-user-defined-stamps" class="admonition info">
<summary class="admonition-title">
<p>User-defined stamps</p>
<p><a class="admonition-anchor-link" href="2_incrementality/2_stamp/index.html#admonition-user-defined-stamps"></a></p>
</summary>
<div>
<p><code>FileStamper</code> and <code>OutputStamper</code> could also be a trait which would allow users of the library to implement their own stampers.
For simplicity, we do not explore that option in this tutorial.
If you feel adventurous, you could try to implement this after you've finished the tutorial.
Do note that this introduces a lot of extra generics and trait bounds everywhere, which can be a bit cumbersome.</p>
</div>
</details>
<h2 id="tests"><a class="header" href="#tests">Tests</a></h2>
<p>Finally, we write some tests.
Add to <code>pie/src/stamp.rs</code>:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use std::fs::{remove_file, write};
  use std::io;

  use dev_shared::create_temp_file;

  use super::*;

  #[test]
  fn test_exists_file_stamper() -&gt; Result&lt;(), io::Error&gt; {
    let stamper = FileStamper::Exists;
    let temp_file = create_temp_file()?;
    let stamp = stamper.stamp(&amp;temp_file)?;
    assert_eq!(stamp, stamper.stamp(&amp;temp_file)?);

    remove_file(&amp;temp_file)?;
    assert_ne!(stamp, stamper.stamp(&amp;temp_file)?);

    Ok(())
  }

  #[test]
  fn test_modified_file_stamper() -&gt; Result&lt;(), io::Error&gt; {
    let stamper = FileStamper::Modified;
    let temp_file = create_temp_file()?;
    let stamp = stamper.stamp(&amp;temp_file)?;
    assert_eq!(stamp, stamper.stamp(&amp;temp_file)?);

    write(&amp;temp_file, format!(&quot;{:?}&quot;, stamp))?;
    let new_stamp = stamper.stamp(&amp;temp_file)?;
    assert_ne!(stamp, new_stamp);
    let stamp = new_stamp;

    remove_file(&amp;temp_file)?;
    assert_ne!(stamp, stamper.stamp(&amp;temp_file)?);

    Ok(())
  }

  #[test]
  fn test_inconsequential_output_stamper() {
    let stamper = OutputStamper::Inconsequential;
    let stamp = stamper.stamp(&amp;1);
    assert_eq!(stamp, stamper.stamp(&amp;1));
    assert_eq!(stamp, stamper.stamp(&amp;2));
  }

  #[test]
  fn test_equals_output_stamper() {
    let stamper = OutputStamper::Equals;
    let stamp = stamper.stamp(&amp;1);
    assert_eq!(stamp, stamper.stamp(&amp;1));
    assert_ne!(stamp, stamper.stamp(&amp;2));
  }
}</code></pre>
<p>We test file stamps by creating a stamp, changing the file, creating a new stamp, and then compare the stamps.
We test task output stamps by just passing a different output value to the <code>stamp</code> function, and then compare the stamps.</p>
<p>Run <code>cargo test</code> to confirm the stamp implementation.</p>
<div id="admonition-warning" class="admonition warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="2_incrementality/2_stamp/index.html#admonition-warning"></a></p>
</div>
<div>
<p>Test <code>test_modified_file_stamper</code> will likely fail. Do continue to the next section, because we're going to fix it!</p>
</div>
</div>
<h2 id="testing-with-file-modified-time-correctly"><a class="header" href="#testing-with-file-modified-time-correctly">Testing with file modified time, correctly</a></h2>
<p>Unfortunately, these tests may fail on some operating systems (Linux and Windows in my testing), due to an imprecise file last modified timer.
What can happen is that we write to a file, making the OS update its modified time to <code>1000</code> (as an example, not a real timestamp), then very quickly write to the file again, making the OS update its modified time to <code>1000</code> again.
Then, our test will fail because the stamp didn't change even though we expect it to change.</p>
<p>This can happen with an imprecise timer that only increases once every millisecond (again, an example, not a real number) when we perform writes in between that millisecond.
Even worse, our test can be flaky, sometimes succeeding if we write in between those milliseconds, sometimes failing if we write within a millisecond.</p>
<p>To solve this, add a function to the filesystem testing utility crate.
Change <code>dev_shared/src/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_1"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- dev_shared/src/lib.rs
+++ dev_shared/src/lib.rs
@@ -1,4 +1,7 @@
+use std::fs::{metadata, write};
 use std::io;
+use std::path::Path;
+use std::time::SystemTime;
 
 use tempfile::{NamedTempFile, TempDir};
 
@@ -7,3 +10,29 @@
 
 /// Creates a new temporary directory that gets cleaned up when dropped.
 pub fn create_temp_dir() -> Result<TempDir, io::Error> { TempDir::new() }
+
+/// Keeps writing ${"`"}contents${"`"} to file at ${"`"}path${"`"} until its last modified time changes, then returns the modified time.
+/// This is required because some OSs have imprecise modified timers, where the file modified time does not change when 
+/// writing in quick succession.
+///
+/// # Errors
+///
+/// Returns an error when any file operation fails.
+pub fn write_until_modified(path: impl AsRef<Path>, contents: impl AsRef<[u8]>) -> Result<SystemTime, io::Error> {
+  let path = path.as_ref();
+  let contents = contents.as_ref();
+  fn get_modified(path: impl AsRef<Path>) -> Result<SystemTime, io::Error> {
+    let modified = match metadata(path) {
+      Err(e) if e.kind() == io::ErrorKind::NotFound => SystemTime::UNIX_EPOCH,
+      Err(e) => Err(e)?,
+      Ok(m) => m.modified()?
+    };
+    Ok(modified)
+  }
+  let modified = get_modified(path)?;
+  loop {
+    write(path, contents)?;
+    if modified != get_modified(path)? { break; }
+  }
+  Ok(modified)
+}
`;
    let target = document.getElementById('diff2html_1');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>The <code>write_until_modified</code> function writes to the file, but ensures its modified time will change.
Now change the tests in <code>pie/src/stamp.rs</code> to use this function:</p>
<div class="diff2html" id="diff2html_2"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/stamp.rs
+++ pie/src/stamp.rs
@@ -2,10 +2,10 @@
 
 #[cfg(test)]
 mod test {
-  use std::fs::{remove_file, write};
+  use std::fs::remove_file;
   use std::io;
 
-  use dev_shared::create_temp_file;
+  use dev_shared::{create_temp_file, write_until_modified};
 
   use super::*;
 
@@ -29,7 +29,9 @@
     let stamp = stamper.stamp(&temp_file)?;
     assert_eq!(stamp, stamper.stamp(&temp_file)?);
 
-    write(&temp_file, format!("{:?}", stamp))?;
+    // Write until file modified time changes. Required on some OSs due to imprecise modified timer causing the modified 
+    // stamp to be the same after fast consecutive writes.
+    write_until_modified(&temp_file, format!("{:?}", stamp))?;
     let new_stamp = stamper.stamp(&temp_file)?;
     assert_ne!(stamp, new_stamp);
     let stamp = new_stamp;
`;
    let target = document.getElementById('diff2html_2');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Now we use <code>write_until_modified</code> to write to the file, ensuring its modified time will change, ensuring the stamp will change when it should.
Run <code>cargo test</code> to confirm the stamp implementation, which should succeed now.</p>
<h2 id="stamps-in-context"><a class="header" href="#stamps-in-context">Stamps in Context</a></h2>
<p>We now have a module dedicated to stamps.
However, stampers are constructed by users of the library that author tasks, and they need to pass in these stampers when creating dependencies.
Therefore, we need to update the <code>Context</code> trait to allow passing in these stampers.</p>
<p>Change <code>Context</code> in <code>pie/src/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_3"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -4,6 +4,8 @@
 use std::io;
 use std::path::Path;
 
+use stamp::{FileStamper, OutputStamper};
+
 pub mod stamp;
 pub mod context;
 mod fs;
@@ -19,12 +21,25 @@
 /// Programmatic incremental build context, enabling tasks to create dynamic dependencies that context implementations 
 /// use for incremental execution.
 pub trait Context<T: Task> {
-  /// Requires file at given ${"`"}path${"`"}, recording a dependency to it. Call this method *just before reading from the file*, 
-  /// so that the dependency corresponds to the data that you are reading. Returns:
+  /// Requires file at given ${"`"}path${"`"}, recording a dependency to it (using the default require file stamper). Call this 
+  /// method *just before reading from the file*, so that the dependency corresponds to the data that you are reading. 
+  /// Returns:
   /// - ${"`"}Ok(Some(file))${"`"} if a file exists at given ${"`"}path${"`"}, 
   /// - ${"`"}Ok(None)${"`"} if no file exists at given ${"`"}path${"`"} (but a directory could exist at given ${"`"}path${"`"}),
-  /// - ${"`"}Err(e)${"`"} if there was an error getting the metadata for given ${"`"}path${"`"}, or if there was an error opening the file. 
-  fn require_file<P: AsRef<Path>>(&mut self, path: P) -> Result<Option<File>, io::Error>;
+  /// - ${"`"}Err(e)${"`"} if there was an error getting the metadata for given ${"`"}path${"`"}, if there was an error opening the file, or 
+  ///   if there was an error stamping the file.
+  fn require_file<P: AsRef<Path>>(&mut self, path: P) -> Result<Option<File>, io::Error> {
+    self.require_file_with_stamper(path, self.default_require_file_stamper())
+  }
+  /// Requires file at given ${"`"}path${"`"}, recording a dependency to it (using given ${"`"}stamper${"`"}). Call this method 
+  /// *just before reading from the file*, so that the dependency corresponds to the data that you are reading. Returns:
+  /// - ${"`"}Ok(Some(file))${"`"} if a file exists at given ${"`"}path${"`"}, 
+  /// - ${"`"}Ok(None)${"`"} if no file exists at given ${"`"}path${"`"} (but a directory could exist at given ${"`"}path${"`"}),
+  /// - ${"`"}Err(e)${"`"} if there was an error getting the metadata for given ${"`"}path${"`"}, if there was an error opening the file, or 
+  ///   if there was an error stamping the file.
+  fn require_file_with_stamper<P: AsRef<Path>>(&mut self, path: P, stamper: FileStamper) -> Result<Option<File>, io::Error>;
+  /// Returns the default require file stamper.
+  fn default_require_file_stamper(&self) -> FileStamper { FileStamper::Modified }
 
   /// Requires given ${"`"}task${"`"}, recording a dependency and selectively executing it. Returns its up-to-date output.
   fn require_task(&mut self, task: &T) -> T::Output;
`;
    let target = document.getElementById('diff2html_3');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We add the <code>require_file_with_stamper</code> method which allow passing in a stamper.
We add a default implementation for <code>require_file</code> that passes in a default stamper.
The default is provided by <code>default_require_file_stamper</code> which can be overridden by context implementations.</p>
<p>Now apply the same to tasks, changing <code>Context</code> again in <code>pie/src/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_4"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -41,6 +41,14 @@
   /// Returns the default require file stamper.
   fn default_require_file_stamper(&self) -> FileStamper { FileStamper::Modified }
 
-  /// Requires given ${"`"}task${"`"}, recording a dependency and selectively executing it. Returns its up-to-date output.
-  fn require_task(&mut self, task: &T) -> T::Output;
+  /// Requires given ${"`"}task${"`"}, recording a dependency (using the default output stamper) and selectively executing it. 
+  /// Returns its up-to-date output.
+  fn require_task(&mut self, task: &T) -> T::Output {
+    self.require_task_with_stamper(task, self.default_output_stamper())
+  }
+  /// Requires given ${"`"}task${"`"}, recording a dependency (using given ${"`"}stamper${"`"}) and selectively executing it. Returns its
+  /// up-to-date output.
+  fn require_task_with_stamper(&mut self, task: &T, stamper: OutputStamper) -> T::Output;
+  /// Returns the default output stamper.
+  fn default_output_stamper(&self) -> OutputStamper { OutputStamper::Equals }
 }
`;
    let target = document.getElementById('diff2html_4');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Update <code>NonIncrementalContext</code> in <code>src/context/non_incremental.rs</code> to implement the new methods:</p>
<div class="diff2html" id="diff2html_5"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/non_incremental.rs
+++ pie/src/context/non_incremental.rs
@@ -4,15 +4,16 @@
 
 use crate::{Context, Task};
 use crate::fs::open_if_file;
+use crate::stamp::{FileStamper, OutputStamper};
 
 pub struct NonIncrementalContext;
 
 impl<T: Task> Context<T> for NonIncrementalContext {
-  fn require_file<P: AsRef<Path>>(&mut self, path: P) -> Result<Option<File>, io::Error> {
+  fn require_file_with_stamper<P: AsRef<Path>>(&mut self, path: P, _stamper: FileStamper) -> Result<Option<File>, io::Error> {
     open_if_file(&path)
   }
 
-  fn require_task(&mut self, task: &T) -> T::Output {
+  fn require_task_with_stamper(&mut self, task: &T, _stamper: OutputStamper) -> T::Output {
     task.execute(self)
   }
 }
`;
    let target = document.getElementById('diff2html_5');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We just ignore the stampers in <code>NonIncrementalContext</code>, as they are only needed for incrementality.</p>
<p>Run <code>cargo test</code> to confirm everything still works.</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="2_incrementality/2_stamp/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="2_incrementality/2_stamp/../../gen/2_incrementality/2_stamp/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-dependencies"><a class="header" href="#dynamic-dependencies">Dynamic Dependencies</a></h1>
<p>Now that we've implemented stamps, we can implement dynamic dependencies and their consistency checking.
A dependency is inconsistent if after stamping, the new stamp is different from the old stamp.
Therefore, dependencies need to keep track of their stamper and their previous stamp.
To that end, we will implement the <code>FileDependency</code> and <code>TaskDependency</code> types with methods for consistency checking.
We will also implement a <code>Dependency</code> type that abstracts over <code>FileDependency</code> and <code>TaskDependency</code>, which we will need for the dependency graph implementation in the next chapter.</p>
<p>Add the <code>dependency</code> module to <code>pie/src/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_0"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -7,6 +7,7 @@
 use stamp::{FileStamper, OutputStamper};
 
 pub mod stamp;
+pub mod dependency;
 pub mod context;
 mod fs;
 
`;
    let target = document.getElementById('diff2html_0');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Users of the library will not construct dependencies.
They will create dependencies (and choose stampers) via <code>Context</code> methods.
However, dependencies will be used in the public API for debug logging later, so we make the module public.</p>
<h2 id="file-dependencies"><a class="header" href="#file-dependencies">File dependencies</a></h2>
<p>Create the <code>pie/src/dependency.rs</code> file and add:</p>
<pre><code class="language-rust ">use std::fmt::Debug;
use std::fs::File;
use std::io;
use std::path::PathBuf;

use crate::{Context, Task};
use crate::fs::open_if_file;
use crate::stamp::{FileStamp, FileStamper, OutputStamp, OutputStamper};

#[derive(Clone, Eq, PartialEq, Debug)]
pub struct FileDependency {
  path: PathBuf,
  stamper: FileStamper,
  stamp: FileStamp,
}

impl FileDependency {
  /// Creates a new file dependency with `path` and `stamper`, returning:
  /// - `Ok(file_dependency)` normally,
  /// - `Err(e)` if stamping failed.
  #[allow(dead_code)]
  pub fn new(path: impl Into&lt;PathBuf&gt;, stamper: FileStamper) -&gt; Result&lt;Self, io::Error&gt; {
    let path = path.into();
    let stamp = stamper.stamp(&amp;path)?;
    let dependency = FileDependency { path, stamper, stamp };
    Ok(dependency)
  }
  /// Creates a new file dependency with `path` and `stamper`, returning:
  /// - `Ok((file_dependency, Some(file)))` if a file exists at given path,
  /// - `Ok((file_dependency, None))` if no file exists at given path (but a directory could exist at given path),
  /// - `Err(e)` if stamping or opening the file failed.
  pub fn new_with_file(path: impl Into&lt;PathBuf&gt;, stamper: FileStamper) -&gt; Result&lt;(Self, Option&lt;File&gt;), io::Error&gt; {
    let path = path.into();
    let stamp = stamper.stamp(&amp;path)?;
    let file = open_if_file(&amp;path)?;
    let dependency = FileDependency { path, stamper, stamp };
    Ok((dependency, file))
  }

  /// Returns the path of this dependency.
  #[allow(dead_code)]
  pub fn path(&amp;self) -&gt; &amp;PathBuf { &amp;self.path }
  /// Returns the stamper of this dependency.
  #[allow(dead_code)]
  pub fn stamper(&amp;self) -&gt; &amp;FileStamper { &amp;self.stamper }
  /// Returns the stamp of this dependency.
  #[allow(dead_code)]
  pub fn stamp(&amp;self) -&gt; &amp;FileStamp { &amp;self.stamp }

  /// Checks whether this file dependency is inconsistent, returning:
  /// - `Ok(Some(stamp))` if this dependency is inconsistent (with `stamp` being the new stamp of the dependency),
  /// - `Ok(None)` if this dependency is consistent,
  /// - `Err(e)` if there was an error checking this dependency for consistency.
  pub fn is_inconsistent(&amp;self) -&gt; Result&lt;Option&lt;FileStamp&gt;, io::Error&gt; {
    let new_stamp = self.stamper.stamp(&amp;self.path)?;
    if new_stamp == self.stamp {
      Ok(None)
    } else {
      Ok(Some(new_stamp))
    }
  }
}</code></pre>
<p>A <code>FileDependency</code> stores the <code>path</code> the dependency is about, the <code>stamper</code> used to create a stamp for this dependency, and the <code>stamp</code> that was created at the time the file dependency was made.
The <code>FileDependency::new_with_file</code> function also returns the opened file if it exists, so that users of this function can read from the file without having to open it again.
We add getter methods to get parts of the file dependency without allowing mutation.
Since we will use those getter methods later, we annotate them with <code>#[allow(dead_code)]</code> to disable unused warnings.</p>
<p>A file dependency is inconsistent when the stored stamp is not equal to a stamp that we create at the time of checking, implemented in <code>FileDependency::is_inconsistent</code>.
For example, if we created a file dependency (with modified stamper) for a file that was modified yesterday, then modify the file, and then call <code>is_inconsistent</code> on the file dependency, it would return <code>Some(new_stamp)</code> indicating that the dependency is inconsistent.</p>
<p>We implement an <code>is_inconsistent</code> method here instead of an <code>is_consistent</code> method, so that we can return the changed stamp when the dependency is inconsistent, which we will use for debug logging purposes later.</p>
<p>Creating and checking a file dependency can fail due to file operations failing (for example, cannot access the file), so we propagate those errors.</p>
<h2 id="task-dependencies"><a class="header" href="#task-dependencies">Task dependencies</a></h2>
<p>Task dependencies are implemented in a similar way.
Add to <code>pie/src/dependency.rs</code>:</p>
<pre><code class="language-rust ">#[derive(Clone, Eq, PartialEq, Debug)]
pub struct TaskDependency&lt;T, O&gt; {
  task: T,
  stamper: OutputStamper,
  stamp: OutputStamp&lt;O&gt;,
}

impl&lt;T: Task&gt; TaskDependency&lt;T, T::Output&gt; {
  /// Creates a new `task` dependency with `stamper` and `output`.
  pub fn new(task: T, stamper: OutputStamper, output: T::Output) -&gt; Self {
    let stamp = stamper.stamp(output);
    Self { task, stamper, stamp }
  }

  /// Returns the task of this dependency.
  #[allow(dead_code)]
  pub fn task(&amp;self) -&gt; &amp;T { &amp;self.task }
  /// Returns the stamper of this dependency.
  #[allow(dead_code)]
  pub fn stamper(&amp;self) -&gt; &amp;OutputStamper { &amp;self.stamper }
  /// Returns the stamp of this dependency.
  #[allow(dead_code)]
  pub fn stamp(&amp;self) -&gt; &amp;OutputStamp&lt;T::Output&gt; { &amp;self.stamp }
  
  /// Checks whether this task dependency is inconsistent, returning:
  /// - `Some(stamp)` if this dependency is inconsistent (with `stamp` being the new stamp of the dependency),
  /// - `None` if this dependency is consistent.
  pub fn is_inconsistent&lt;C: Context&lt;T&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Option&lt;OutputStamp&lt;T::Output&gt;&gt; {
    let output = context.require_task(&amp;self.task);
    let new_stamp = self.stamper.stamp(output);
    if new_stamp == self.stamp {
      None
    } else {
      Some(new_stamp)
    }
  }
}</code></pre>
<p>A <code>TaskDependency</code> stores the <code>task</code> the dependency is about, along with its <code>stamper</code> and <code>stamp</code> that is created when the dependency is created.
Task dependencies are generic over the type of tasks <code>T</code>, and their type of outputs <code>O</code>.
We also add immutable getters here.</p>
<details id="admonition-trait-bounds-on-structs" class="admonition info">
<summary class="admonition-title">
<p>Trait bounds on structs</p>
<p><a class="admonition-anchor-link" href="2_incrementality/3_dependency/index.html#admonition-trait-bounds-on-structs"></a></p>
</summary>
<div>
<p>We chose not to put a <code>Task</code> trait bound on <code>TaskDependency</code>, and instead put the bound on the impl.
There are several up and downsides that should be considered when making such a decision.</p>
<p>The main upside for putting the <code>Task</code> bound on the <code>TaskDependency</code> struct, is that we can leave out <code>O</code> and use <code>OutputStamp&lt;T::Output&gt;</code> as the type of the <code>stamp</code> field.
This cuts down a generic parameter, which reduces boilerplate.
The downside is that we need to then put the <code>Task</code> bound on every struct that uses <code>TaskDependency</code>, which increases boilerplate.</p>
<p>In this case, we chose not to put the trait bound on the struct to prevent that trait bound from bubbling up into other structs that use <code>TaskDependency</code>, as it would need to appear in almost every struct in the library.</p>
</div>
</details>
<p>A task dependency is inconsistent if, after recursively checking it, its stamp has changed, implemented in <code>TaskDependency::is_inconsistent</code>.
Usually, this will be using the <code>Equals</code> task output stamper, so a task dependency is usually inconsistent when the output of the task changes.
Because we need to recursively check the task, <code>TaskDependency::is_inconsistent</code> requires a context to be passed in.
Again, there is more mutual recursion here.</p>
<p>This recursive consistency checking is one of the core ideas that make programmatic incremental build systems possible.
But why is this so important? Why do we need recursive checking?
Well, we want our build system to be <em>sound</em>, meaning that we must execute <em>all</em> tasks that are affected by a change.
When we <em>do not execute</em> a task that <em>is affected by a change</em>, we are <em>unsound</em>, and introduce an <em>incrementality bug</em>! </p>
<p>Because of dynamic dependencies, a change in a leaf in the dependency tree may affect a task at the root.
For example, a compilation task depends on a task that reads a configuration file, which depends on the configuration file.
A change to a configuration file (leaf) affects a task that reads the configuration file, which in turn affects the compilation task (root).
Therefore, we need to recursively check the dependency tree in order to execute all tasks affected by changes.</p>
<p>A different way to think about this, is to think about the invariant of the dependency consistency checking.
The invariant is that a dependency is consistent if and only if the subtree of that dependency is consistent, and the dependency itself is consistent.
The easiest way to adhere to this invariant, is recursive checking.</p>
<p>A final note about recursive checking is that tasks can be executed during it, and executing task can lead to new dynamic dependencies.
However, recursive checking handles this without problems because these dependencies are created through the <code>Context</code>, which in turn will call <code>is_inconsistent</code> when needed.</p>
<h2 id="dependency-enum"><a class="header" href="#dependency-enum">Dependency enum</a></h2>
<p>Finally, we create a <code>Dependency</code> enum that abstracts over these two kinds of dependencies.
Add to <code>pie/src/dependency.rs</code>:</p>
<pre><code class="language-rust ">#[derive(Clone, Eq, PartialEq, Debug)]
pub enum Dependency&lt;T, O&gt; {
  RequireFile(FileDependency),
  RequireTask(TaskDependency&lt;T, O&gt;),
}

#[derive(Clone, Eq, PartialEq, Debug)]
pub enum Inconsistency&lt;O&gt; {
  File(FileStamp),
  Task(OutputStamp&lt;O&gt;),
}

impl&lt;T: Task&gt; Dependency&lt;T, T::Output&gt; {
  /// Checks whether this dependency is inconsistent, returning:
  /// - `Ok(Some(stamp))` if the dependency is inconsistent (with `stamp` being the new stamp of the dependency),
  /// - `Ok(None)` if the dependency is consistent,
  /// - `Err(e)` if there was an error checking the dependency for consistency.
  pub fn is_inconsistent&lt;C: Context&lt;T&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Result&lt;Option&lt;Inconsistency&lt;T::Output&gt;&gt;, io::Error&gt; {
    let option = match self {
      Dependency::RequireFile(d) =&gt; d.is_inconsistent()?
        .map(|s| Inconsistency::File(s)),
      Dependency::RequireTask(d) =&gt; d.is_inconsistent(context)
        .map(|s| Inconsistency::Task(s)),
    };
    Ok(option)
  }
}</code></pre>
<p><code>Dependency</code> just merges the two kinds of dependencies and provides an <code>is_inconsistent</code> method that calls the corresponding method.
We return the changed stamp here as well for debug logging later.
We wrap the changed stamp in an <code>Inconsistency</code> enum, and map to the correct variant if there is an inconsistency.</p>
<p>Because <code>Dependency</code> can store a <code>TaskDependency</code>, we need to propagate the <code>T</code> and <code>O</code> generics.
Likewise, <code>Inconsistency</code> propagates the <code>O</code> generic for <code>OutputStamp</code>.</p>
<details id="admonition-user-defined-dependencies" class="admonition info">
<summary class="admonition-title">
<p>User-defined dependencies</p>
<p><a class="admonition-anchor-link" href="2_incrementality/3_dependency/index.html#admonition-user-defined-dependencies"></a></p>
</summary>
<div>
<p>Like with stampers, <code>Dependency</code> could also be a trait to allow users of the library to define their own dependencies.
However, as we will see later, these dynamic dependencies also require validation, and I am unsure how such a <code>Dependency</code> trait should look.
Therefore, we don't have an appendix on how to implement this.
But, if you have an idea on how to this nicely (after you've completed this tutorial), please get in touch!</p>
</div>
</details>
<h2 id="tests-1"><a class="header" href="#tests-1">Tests</a></h2>
<p>As usual, we write some tests to confirm the behaviour.
Add tests to <code>pie/src/dependency.rs</code>:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use std::fs::write;
  use std::io::{self, Read};

  use dev_shared::{create_temp_file, write_until_modified};

  use crate::context::non_incremental::NonIncrementalContext;

  use super::*;

  /// Task that reads file at given path and returns it contents as a string.
  #[derive(Clone, PartialEq, Eq, Hash, Debug)]
  struct ReadStringFromFile(PathBuf);

  impl Task for ReadStringFromFile {
    type Output = String;
    fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
      let mut string = String::new();
      let file = context.require_file(&amp;self.0).expect(&quot;failed to require file&quot;);
      if let Some(mut file) = file {
        file.read_to_string(&amp;mut string).expect(&quot;failed to read from file&quot;);
      };
      string
    }
  }

  #[test]
  fn test_file_dependency_consistency() -&gt; Result&lt;(), io::Error&gt; {
    let mut context = NonIncrementalContext;

    let temp_file = create_temp_file()?;
    write(&amp;temp_file, &quot;test1&quot;)?;

    let file_dependency = FileDependency::new(temp_file.path(), FileStamper::Modified)?;
    let dependency: Dependency&lt;ReadStringFromFile, String&gt; = Dependency::RequireFile(file_dependency.clone());
    assert!(file_dependency.is_inconsistent()?.is_none());
    assert!(dependency.is_inconsistent(&amp;mut context)?.is_none());

    // Change the file, changing the stamp the stamper will create next time, making the file dependency inconsistent.
    write_until_modified(&amp;temp_file, &quot;test2&quot;)?;
    assert!(file_dependency.is_inconsistent()?.is_some());
    assert!(dependency.is_inconsistent(&amp;mut context)?.is_some());

    Ok(())
  }

  #[test]
  fn test_task_dependency_consistency() -&gt; Result&lt;(), io::Error&gt; {
    let mut context = NonIncrementalContext;

    let temp_file = create_temp_file()?;
    write(&amp;temp_file, &quot;test1&quot;)?;
    let task = ReadStringFromFile(temp_file.path().to_path_buf());
    let output = context.require_task(&amp;task);

    let task_dependency = TaskDependency::new(task.clone(), OutputStamper::Equals, output);
    let dependency = Dependency::RequireTask(task_dependency.clone());
    assert!(task_dependency.is_inconsistent(&amp;mut context).is_none());
    assert!(dependency.is_inconsistent(&amp;mut context)?.is_none());

    // Change the file, causing the task to return a different output, changing the stamp the stamper will create next 
    // time, making the task dependency inconsistent.
    write_until_modified(&amp;temp_file, &quot;test2&quot;)?;
    assert!(task_dependency.is_inconsistent(&amp;mut context).is_some());
    assert!(dependency.is_inconsistent(&amp;mut context)?.is_some());

    Ok(())
  }
}</code></pre>
<p>We test a file dependency by asserting that <code>is_inconsistent</code> returns <code>Some</code> after changing the file.</p>
<p>Testing task dependencies requires a bit more work.
We create task <code>ReadStringFromFile</code> that reads a string from a file, and then returns that string as output.
We require the task to get its output (<code>&quot;test1&quot;</code>), and create a task dependency with it.
Then, we change the file and check consistency of the task dependency.
That recursively requires the task, the context will execute the task, and the task now returns (<code>&quot;test2&quot;</code>).
Since we use the <code>Equals</code> output stamper, and <code>&quot;test1&quot;</code> does not equal <code>&quot;test2&quot;</code>, the dependency is inconsistent and returns a stamp containing <code>&quot;test2&quot;</code>.</p>
<p>Note that we are both testing the specific dependencies (<code>FileDependency</code> and <code>TaskDependency</code>), and the general <code>Dependency</code>.</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="2_incrementality/3_dependency/index.html#admonition-note"></a></p>
</div>
<div>
<p>Normally, a task such as <code>ReadStringFromFile</code> shound return a <code>Result&lt;String, io::Error&gt;</code>, but for testing purposes we are just using panics with <code>expect</code>.</p>
<p>In the file dependency case, using <code>Dependency</code> requires an explicit type annotation because there is no task to infer the type from.
We just use <code>Dependency&lt;ReadStringFromFile, String&gt;</code> as the type, and this is fine even though we don't use <code>ReadStringFromFile</code> in that test, because the <code>Dependency::RequireFile</code> variant does not use those types.</p>
</div>
</div>
<p>Run <code>cargo test</code> to confirm everything still works.
You will get some warnings about unused things, but that is ok as we will use them in the next section.</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="2_incrementality/3_dependency/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="2_incrementality/3_dependency/../../gen/2_incrementality/3_dependency/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependency-graph-store"><a class="header" href="#dependency-graph-store">Dependency Graph Store</a></h1>
<p>To do incremental building, we need to keep track of all files, tasks, their dependencies, and task outputs, in a dependency graph.
This will be the responsibility of the <code>Store</code> data structure.
Context implementations will use methods on <code>Store</code> to query and mutate the dependency graph.
In other words, <code>Store</code> encapsulates the dependency graph.</p>
<p>However, writing a dependency graph data structure is outside of the scope of this tutorial, so we will be using the <code>pie_graph</code> library which we prepared exactly for this use case.
The graph from this library is a directed acyclic graph (DAG), meaning that edges are directed and there may be no cycles in edges, as that would prohibit topological orderings.</p>
<details id="admonition-graph-library" class="admonition info">
<summary class="admonition-title">
<p>Graph library</p>
<p><a class="admonition-anchor-link" href="2_incrementality/4_store/index.html#admonition-graph-library"></a></p>
</summary>
<div>
<p>The <code>pie_graph</code> library is a modified version of the great <a href="https://github.com/declanvk/incremental-topo/"><code>incremental-topo</code></a> library which implements incremental topological ordering: it keeps the topological ordering up-to-date incrementally while nodes and edges are added and removed.
That is exactly what we need, as dynamic dependencies prevents us from calculating the topological ordering in one go, and calculating the topological ordering after every task execution is prohibitively expensive.
The implementation in the <code>incremental-topo</code> library is based on a <a href="http://www.doc.ic.ac.uk/~phjk/Publications/DynamicTopoSortAlg-JEA-07.pdf">paper by D. J. Pearce and P. H. J. Kelly</a> that describes several dynamic topological sort algorithms for directed acyclic graphs.</p>
</div>
</details>
<p>Add the <code>pie_graph</code> dependency to <code>pie/Cargo.toml</code>:</p>
<div class="diff2html" id="diff2html_0"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/Cargo.toml
+++ pie/Cargo.toml
@@ -3,6 +3,9 @@
 version = "0.1.0"
 edition = "2021"
 
+[dependencies]
+pie_graph = "0.0.1"
+
 [dev-dependencies]
 dev_shared = { path = "../dev_shared" }
 assert_matches = "1"
`;
    let target = document.getElementById('diff2html_0');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<h2 id="store-basics"><a class="header" href="#store-basics">Store basics</a></h2>
<p>Add the <code>store</code> module to <code>pie/src/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_1"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -10,6 +10,7 @@
 pub mod dependency;
 pub mod context;
 mod fs;
+mod store;
 
 /// A unit of computation in a programmatic incremental build system.
 pub trait Task: Clone + Eq + Hash + Debug {
`;
    let target = document.getElementById('diff2html_1');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>This module is private, as users of the library should not interact with the store.
Only <code>Context</code> implementations will use the store.</p>
<p>Create the <code>pie/src/store.rs</code> file and add the following to get started:</p>
<pre><code class="language-rust ">use std::path::{Path, PathBuf};

use pie_graph::{DAG, Node};

use crate::dependency::{Dependency, FileDependency, TaskDependency};
use crate::Task;

/// Stores files and tasks, and their dependencies, in a DAG (directed acyclic graph). Provides operations to mutate
/// and query this graph.
pub struct Store&lt;T, O&gt; {
  graph: DAG&lt;NodeData&lt;T, O&gt;, Dependency&lt;T, O&gt;&gt;,
}

#[derive(Debug)]
enum NodeData&lt;T, O&gt; {
  File(PathBuf),
  Task {
    task: T,
    output: Option&lt;O&gt;,
  },
}

impl&lt;T: Task&gt; Default for Store&lt;T, T::Output&gt; {
  fn default() -&gt; Self {
    Self {
      graph: DAG::default(),
    }
  }
}</code></pre>
<p>The <code>Store</code> is generic over tasks <code>T</code> and their outputs <code>O</code>, like we have done before with <code>Dependency</code>.</p>
<p>The <code>DAG</code> type from <code>pie_graph</code> represents a DAG with nodes and edges, and data attached to those nodes and edges.
The nodes in our graph are either files or tasks, and the edges are dependencies.</p>
<p>The first generic argument to <code>DAG</code> is the type of data to attach to nodes, which is <code>NodeData&lt;T, O&gt;</code> in our case.
Because nodes can be files or tasks, <code>NodeData&lt;T, O&gt;</code> enumerates these, storing the path for files, and the task along with its output for tasks.
We store file paths as <code>PathBuf</code>, which is the owned version of <code>Path</code> (similar to <code>String</code> being the owned version of <code>str</code>).
The task output is stored as <code>Option&lt;O&gt;</code> because we can add a task to the graph without having executed it, so we don't have its output yet.</p>
<p>The second argument is the type of data to attach to edges, which is <code>Dependency&lt;T, O&gt;</code>, using the <code>Dependency</code> enum we defined earlier.</p>
<p>We implement <code>Default</code> for the store to initialize it.</p>
<details id="admonition-deriving-default" class="admonition info">
<summary class="admonition-title">
<p>Deriving default</p>
<p><a class="admonition-anchor-link" href="2_incrementality/4_store/index.html#admonition-deriving-default"></a></p>
</summary>
<div>
<p>We cannot derive this <code>Default</code> implementation even though it seems we should be able to, because the derived implementation will require <code>T</code> and <code>O</code> to be <code>Default</code>, and this is not always the case.
This is because the <code>Default</code> derive macro is conservative and adds a <code>: Default</code> bound to <em>every</em> generic argument in the <code>Default</code> trait implementation, and there is no way to disable this behaviour.
Therefore, we implement <code>Default</code> ourselves.</p>
<p>There are several crates that have more configurable derive macros for these things, but adding an extra dependency to generate a few lines of code is not worth the extra compilation time, so we just implement it manually here.</p>
</div>
</details>
<h2 id="graph-nodes"><a class="header" href="#graph-nodes">Graph nodes</a></h2>
<p>A node in <code>DAG</code> is represented by a <code>Node</code>, which is a transparent identifier (sometimes called a <a href="https://en.wikipedia.org/wiki/Handle_(computing)">handle</a>) that points to the node and its data.
We can create nodes in the graph, and then query attached data (<code>NodeData</code>) given a node.
So <code>DAG</code> allows us to go from <code>Node</code> to a <code>PathBuf</code> and task <code>T</code> through attached <code>NodeData</code>.</p>
<p>However, we want each unique file and task to be represented by a single unique node in the graph.
We need this for incrementality so that if the build system encounters the same task twice, we can find the corresponding task node in the graph the second time, check if it is consistent, and return its output if it is.</p>
<p>To ensure unique nodes, we need to maintain the reverse mapping from <code>PathBuf</code> and <code>T</code> to <code>Node</code> ourselves, which we will do with <code>HashMap</code>s.
This is also the reason for the <code>Eq</code> and <code>Hash</code> trait bounds on the <code>Task</code> trait, so we can use them as keys in <code>HashMap</code>s.</p>
<p>Change <code>pie/src/store.rs</code> to add hash maps to map between these things:</p>
<div class="diff2html" id="diff2html_2"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/store.rs
+++ pie/src/store.rs
@@ -1,3 +1,4 @@
+use std::collections::HashMap;
 use std::path::{Path, PathBuf};
 
 use pie_graph::{DAG, Node};
@@ -9,6 +10,8 @@
 /// and query this graph.
 pub struct Store<T, O> {
   graph: DAG<NodeData<T, O>, Dependency<T, O>>,
+  file_to_node: HashMap<PathBuf, Node>,
+  task_to_node: HashMap<T, Node>,
 }
 
 #[derive(Debug)]
@@ -24,6 +27,8 @@
   fn default() -> Self {
     Self {
       graph: DAG::default(),
+      file_to_node: HashMap::default(),
+      task_to_node: HashMap::default(),
     }
   }
 }
`;
    let target = document.getElementById('diff2html_2');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>To prevent accidentally using a file node as a task node, and vice versa, change <code>pie/src/store.rs</code> to add specific types of nodes:</p>
<div class="diff2html" id="diff2html_3"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/store.rs
+++ pie/src/store.rs
@@ -1,3 +1,4 @@
+use std::borrow::Borrow;
 use std::collections::HashMap;
 use std::path::{Path, PathBuf};
 
@@ -10,8 +11,8 @@
 /// and query this graph.
 pub struct Store<T, O> {
   graph: DAG<NodeData<T, O>, Dependency<T, O>>,
-  file_to_node: HashMap<PathBuf, Node>,
-  task_to_node: HashMap<T, Node>,
+  file_to_node: HashMap<PathBuf, FileNode>,
+  task_to_node: HashMap<T, TaskNode>,
 }
 
 #[derive(Debug)]
@@ -23,6 +24,24 @@
   },
 }
 
+/// Newtype for file ${"`"}Node${"`"}s.
+#[repr(transparent)]
+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
+pub struct FileNode(Node);
+
+impl Borrow<Node> for &FileNode {
+  fn borrow(&self) -> &Node { &self.0 }
+}
+
+/// Newtype for task ${"`"}Node${"`"}s.
+#[repr(transparent)]
+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
+pub struct TaskNode(Node);
+
+impl Borrow<Node> for &TaskNode {
+  fn borrow(&self) -> &Node { &self.0 }
+}
+
 impl<T: Task> Default for Store<T, T::Output> {
   fn default() -> Self {
     Self {
`;
    let target = document.getElementById('diff2html_3');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>The <code>FileNode</code> and <code>TaskNode</code> types are <a href="https://rust-unofficial.github.io/patterns/patterns/behavioural/newtype.html">newtypes</a> that wrap a <code>Node</code> into a specific type of node.
The <code>Borrow</code> implementations will make subsequent code a bit more concise by automatically converting <code>&amp;FileNode</code> and <code>&amp;TaskNode</code>s to <code>&amp;Node</code>s.</p>
<details id="admonition-newtypes" class="admonition info">
<summary class="admonition-title">
<p>Newtypes</p>
<p><a class="admonition-anchor-link" href="2_incrementality/4_store/index.html#admonition-newtypes"></a></p>
</summary>
<div>
<p>Because the <code>Node</code>s inside the newtypes are not public, it is not possible to construct a <code>FileNode</code> or <code>TaskNode</code> outside of this module.
Therefore, if we only accept and create <code>FileNode</code> and <code>TaskNode</code> in the <code>Store</code> API, it is not possible to use the wrong kind of node.</p>
<p>The <code>Borrow</code> implementation does leak outside of this module, but not outside of this crate (library).
This is because the visibility of a trait implementation is the intersection of the visibilities of the trait and type it is implemented on.
<code>Borrow</code> is public, but <code>FileNode</code> and <code>TaskNode</code> are only public within this crate.
Thefore, modules of this crate can extract the <code>Node</code> out of <code>FileNode</code> and <code>TaskNode</code>.
However, that <code>Node</code> cannot be used to construct a <code>FileNode</code> or <code>TaskNode</code>, so it is not a problem.</p>
</div>
</details>
<p>Now we will add methods create nodes and to query their attached data.
Add the following code to <code>pie/src/store.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;T: Task&gt; Store&lt;T, T::Output&gt; {
  /// Gets the file node for `path`, or creates a file node by adding it to the dependency graph.
  pub fn get_or_create_file_node(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; FileNode {
    let path = path.as_ref();
    if let Some(file_node) = self.file_to_node.get(path) {
      *file_node
    } else {
      let node = self.graph.add_node(NodeData::File(path.to_path_buf()));
      let node = FileNode(node);
      self.file_to_node.insert(path.to_path_buf(), node);
      node
    }
  }
  /// Gets the path for `node`. 
  ///
  /// # Panics
  ///
  /// Panics if `node` was not found in the dependency graph.
  #[allow(dead_code)]
  pub fn get_file_path(&amp;self, node: &amp;FileNode) -&gt; &amp;PathBuf {
    let Some(NodeData::File(path)) = self.graph.get_node_data(node) else {
      panic!(&quot;BUG: node {:?} was not found in the dependency graph&quot;, node);
    };
    path
  }
  
  /// Gets the task node for `task`, or creates a task node by adding it to the dependency graph.
  pub fn get_or_create_task_node(&amp;mut self, task: &amp;T) -&gt; TaskNode {
    if let Some(node) = self.task_to_node.get(task) {
      *node
    } else {
      let node = self.graph.add_node(NodeData::Task {
        task: task.clone(),
        output: None,
      });
      let node = TaskNode(node);
      self.task_to_node.insert(task.clone(), node);
      node
    }
  }
  /// Gets the task for `node`. 
  ///
  /// # Panics
  ///
  /// Panics if `node` was not found in the dependency graph.
  pub fn get_task(&amp;self, node: &amp;TaskNode) -&gt; &amp;T {
    let Some(NodeData::Task { task, .. }) = self.graph.get_node_data(node) else {
      panic!(&quot;BUG: node {:?} was not found in the dependency graph&quot;, node);
    };
    task
  }
}</code></pre>
<p>The <code>get_or_create_file_node</code> method creates file nodes.
When we want to go from a file path (using <code>impl AsRef&lt;Path&gt;</code>) to a <code>FileNode</code>, either we have already added this file path to the graph and want to get the <code>FileNode</code> for it, or we have not yet added it to the graph yet and should add it.
The former is handled by the if branch in <code>get_or_create_file_node</code>, where we just retrieve the <code>FileNode</code> from the <code>file_to_node</code> hash map.
The latter is handled by the else branch where we add the node to the graph with <code>graph.add_node</code> which attaches the <code>NodeData::File</code> data to the node, and then returns a <code>FileNode</code> which we insert into the <code>file_to_node</code> map.</p>
<p>The <code>get_file_path</code> method does the inverse.
We get the attached data given a node, and extract the file path from it.</p>
<p>Note that we are using <code>panic!</code> here to indicate that invalid usage of this method is an <em>unrecoverable programming error</em> that should not occur.
Returning an <code>Option&lt;&amp;PathBuf&gt;</code> makes no sense here, as the caller of this method has no way to recover from this.
Because this is not an end-user-facing API (<code>store</code> module is private), we control all the calls to this method, and thus we are responsible for using these methods in a valid way. 
Therefore, when we call these methods, we should document why it is valid (if this is not immediately obvious), and we need to test whether we really use it in a valid way.</p>
<p>We're also documenting the panics in a <code># Panics</code> section in the documentation comment, as is common practice in Rust.</p>
<details id="admonition-triggering-these-panics" class="admonition info">
<summary class="admonition-title">
<p>Triggering these panics</p>
<p><a class="admonition-anchor-link" href="2_incrementality/4_store/index.html#admonition-triggering-these-panics"></a></p>
</summary>
<div>
<p>Because only <code>Store</code> can create <code>FileNode</code>s and <code>TaskNode</code>s, and all methods only take these values as inputs, these panics will not happen under normal usage.
The only way to trigger these panics (in safe Rust) would be to create two stores, and use the nodes from one store in another.
However, since this is a private module, we just need to make sure that we don't do that.</p>
<p>There are some tricks to prevent even this kind of invalid usage.
For example, the <a href="https://docs.rs/generativity/latest/generativity/">generativity</a> crate generates unique identifiers based on lifetimes.
However, that is a bit overkill, especially for an internal API, so we won't be using that.</p>
</div>
</details>
<p>We implement similar methods for task nodes in <code>get_or_create_task_node</code> and <code>get_task</code>.</p>
<h2 id="task-outputs"><a class="header" href="#task-outputs">Task outputs</a></h2>
<p>When we do not need to execute a task because it is consistent, we still need to return its output.
Therefore, we store the task output in <code>NodeData::Task</code> and add methods to query and manipulate task outputs.
Add the following code to <code>pie/src/store.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;T: Task&gt; Store&lt;T, T::Output&gt; {
  /// Checks whether task `node` has an output. Returns `false` if `node` does not have an output. 
  ///
  /// # Panics
  ///
  /// Panics if `node` was not found in the dependency graph.
  pub fn task_has_output(&amp;self, node: &amp;TaskNode) -&gt; bool {
    let Some(NodeData::Task { output, .. }) = self.graph.get_node_data(node) else {
      panic!(&quot;BUG: node {:?} was not found in the dependency graph&quot;, node);
    };
    output.is_some()
  }
  /// Gets the output for task `node`. 
  ///
  /// # Panics
  ///
  /// Panics if `node` was not found in the dependency graph, or if the task has no output.
  pub fn get_task_output(&amp;self, node: &amp;TaskNode) -&gt; &amp;T::Output {
    let Some(NodeData::Task { output: Some(output), .. }) = self.graph.get_node_data(node) else {
      panic!(&quot;BUG: node {:?} was not found in the dependency graph, or does not have an output&quot;, node);
    };
    output
  }
  /// Sets the output for task `node` to `new_output`.
  ///
  /// # Panics
  ///
  /// Panics if task `node` was not found in the dependency graph.
  pub fn set_task_output(&amp;mut self, node: &amp;TaskNode, new_output: T::Output) {
    let Some(NodeData::Task { output, .. }) = self.graph.get_node_data_mut(node) else {
      panic!(&quot;BUG: node {:?} was not found in the dependency graph&quot;, node);
    };
    output.replace(new_output);
  }
}</code></pre>
<p>The <code>task_has_output</code>, <code>get_task_output</code>, and <code>set_task_output</code> methods manipulate task outputs in <code>NodeData::Task</code>.</p>
<p>Again, we are using panics here to indicate unrecoverable programming errors.</p>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>Now we need methods to query and manipulate dependencies.
The edges in the graph are dependencies between tasks and files.
Tasks can depend on other tasks and files, but there are no dependencies between files.
An edge does not have its own dedicated representation, and is simply represented by two nodes: the source node and the destination node of the edge.</p>
<p>Add the following code to <code>pie/src/store.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;T: Task&gt; Store&lt;T, T::Output&gt; {
  /// Get all dependencies of task `src`. 
  ///
  /// # Panics
  ///
  /// Panics in development builds if `src` was not found in the dependency graph.
  pub fn get_dependencies_of_task&lt;'a&gt;(&amp;'a self, src: &amp;'a TaskNode) -&gt; impl Iterator&lt;Item=&amp;'a Dependency&lt;T, T::Output&gt;&gt; + 'a {
    debug_assert!(self.graph.contains_node(src), &quot;BUG: node {:?} was not found in the dependency graph&quot;, src);
    self.graph.get_outgoing_edge_data(src)
  }
  /// Add a file require `dependency` from task `src` to file `dst`.
  ///
  /// # Panics
  ///
  /// Panics if `src` or `dst` were not found in the dependency graph, or if a cycle is created by adding this dependency.
  pub fn add_file_require_dependency(&amp;mut self, src: &amp;TaskNode, dst: &amp;FileNode, dependency: FileDependency) {
    match self.graph.add_edge(src, dst, Dependency::RequireFile(dependency)) {
      Err(pie_graph::Error::NodeMissing) =&gt; panic!(&quot;BUG: source node {:?} or destination node {:?} was not found in the dependency graph&quot;, src, dst),
      Err(pie_graph::Error::CycleDetected) =&gt; panic!(&quot;BUG: cycle detected when adding file dependency from {:?} to {:?}&quot;, src, dst),
      _ =&gt; {},
    }
  }
  /// Adds a task require `dependency` from task `src` to task `dst`.
  ///
  /// # Errors
  ///
  /// Returns `Err(())` if adding this dependency to the graph creates a cycle.
  ///
  /// # Panics
  ///
  /// Panics if `src` or `dst` were not found in the dependency graph.
  pub fn add_task_require_dependency(&amp;mut self, src: &amp;TaskNode, dst: &amp;TaskNode, dependency: TaskDependency&lt;T, T::Output&gt;) -&gt; Result&lt;(), ()&gt; {
    match self.graph.add_edge(src, dst, Dependency::RequireTask(dependency)) {
      Err(pie_graph::Error::NodeMissing) =&gt; panic!(&quot;BUG: source node {:?} or destination node {:?} was not found in the dependency graph&quot;, src, dst),
      Err(pie_graph::Error::CycleDetected) =&gt; Err(()),
      _ =&gt; Ok(()),
    }
  }
}</code></pre>
<p>The <code>get_dependencies_of_task</code> method gets the dependencies (edge data of outgoing edges) of a task, and returns it as an iterator (which is empty if task has no dependencies).
This method needs explicit lifetime annotations due to the signature of <code>get_outgoing_edge_data</code> and the way we return an iterator using <code>impl Iterator&lt;...</code>.
We're using <code>debug_assert!</code> here to trigger a panic indicating an unrecoverable programming error only in development mode, because this check is too expensive to run in release (optimized) mode.</p>
<p>The <code>add_file_require_dependency</code> method adds a file dependency.
Adding an edge to the graph can result in cycles, which are not allowed in a directed <em>acyclic</em> graph (DAG).
Therefore, <code>graph.add_edge</code> can return an <code>Err</code> indicating that there is a cycle.
In case of files, this cannot happen because files do not have outgoing dependencies, and the API enforces this by never taking a <code>FileNode</code> as a source (<code>src</code>) of an edge.</p>
<p>Tasks can depend on other tasks, so they can create cycles.
In <code>add_task_require_dependency</code>, we propagate the cycle detected error (by returning <code>Err(())</code>) to the caller because the caller has more information to create an error message for the user that made a cyclic task dependency.</p>
<h2 id="resetting-tasks"><a class="header" href="#resetting-tasks">Resetting tasks</a></h2>
<p>Finally, when we determine that a task is inconsistent and needs to be executed, we first need to remove its output and remove its outgoing dependencies, as those will interfere with incrementality when not removed.
We do NOT want to remove incoming dependencies, as that would remove dependencies from other tasks to this task, which breaks incrementality, so we can't just remove and re-add the task to the graph.
Add the <code>reset_task</code> method that does this to <code>pie/src/store.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;T: Task&gt; Store&lt;T, T::Output&gt; {
  /// Reset task `src`, removing its output and removing all its outgoing dependencies.
  ///
  /// # Panics
  ///
  /// Panics if task `src` was not found in the dependency graph.
  pub fn reset_task(&amp;mut self, src: &amp;TaskNode) {
    if let Some(NodeData::Task { output, .. }) = self.graph.get_node_data_mut(src) {
      *output = None;
    } else {
      panic!(&quot;BUG: node {:?} was not found in the dependency graph&quot;, src);
    }
    self.graph.remove_outgoing_edges_of_node(src);
  }
}</code></pre>
<p>This will reset the task output back to <code>None</code>, and remove all outgoing edges (dependencies).</p>
<h2 id="tests-2"><a class="header" href="#tests-2">Tests</a></h2>
<p>Now we've implemented everything we need for implementing the top-down context, but first we will write some tests.</p>
<h3 id="testing-file-mapping"><a class="header" href="#testing-file-mapping">Testing file mapping</a></h3>
<p>Add the following code to <code>pie/src/store.rs</code> for testing the file mapping:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use crate::Context;
  use crate::stamp::{FileStamper, OutputStamper};

  use super::*;

  /// Task that returns its owned string. Never executed, just used for testing the store.
  #[derive(Clone, PartialEq, Eq, Hash, Debug)]
  struct StringConstant(String);

  impl StringConstant {
    pub fn new(string: impl Into&lt;String&gt;) -&gt; Self { Self(string.into()) }
  }

  impl Task for StringConstant {
    type Output = String;
    fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, _context: &amp;mut C) -&gt; Self::Output {
      self.0.clone()
    }
  }

  #[test]
  fn test_file_mapping() {
    let mut store: Store&lt;StringConstant, String&gt; = Store::default();

    let path_a = PathBuf::from(&quot;hello.txt&quot;);
    let node_a = store.get_or_create_file_node(&amp;path_a);
    assert_eq!(node_a, store.get_or_create_file_node(&amp;path_a)); // Same node
    assert_eq!(&amp;path_a, store.get_file_path(&amp;node_a)); // Same file path

    let path_b = PathBuf::from(&quot;world.txt&quot;);
    let node_b = store.get_or_create_file_node(&amp;path_b);
    assert_eq!(node_b, store.get_or_create_file_node(&amp;path_b));
    assert_eq!(&amp;path_b, store.get_file_path(&amp;node_b));

    assert_ne!(node_a, node_b); // Different nodes
  }

  #[test]
  #[should_panic]
  fn test_file_mapping_panics() {
    let mut fake_store: Store&lt;StringConstant, String&gt; = Store::default();
    let fake_node = fake_store.get_or_create_file_node(&quot;hello.txt&quot;);
    let store: Store&lt;StringConstant, String&gt; = Store::default();
    store.get_file_path(&amp;fake_node);
  }
}</code></pre>
<p>We create a simple task <code>StringConstant</code> because we need a <code>Task</code> implementation to test <code>Store</code>, as <code>Store</code> is generic over a <code>Task</code> type.
We will never execute it because <code>Store</code> does not execute tasks.</p>
<p>Test <code>test_file_mapping</code> checks whether the file node mapping works as expected:</p>
<ul>
<li><code>get_or_create_file_node</code> calls with the same path should produce the same <code>FileNode</code>.</li>
<li><code>get_or_create_file_node</code> calls with different paths should produce different <code>FileNode</code>s.</li>
</ul>
<p>This works because <code>&quot;hello.txt&quot;</code> and <code>&quot;world.txt&quot;</code> are different paths, thus their <code>Eq</code> and <code>Hash</code> implementations ensure they get separate spots in the <code>file_to_node</code> hash map.</p>
<p>Test <code>test_file_mapping_panics</code> triggers the panic in <code>get_file_path</code> by creating a <code>FileNode</code> with a &quot;fake store&quot;, and then using that rogue file node in another store.
While it is unlikely that we will make this mistake when using <code>Store</code>, it is good to confirm that this panics.</p>
<details id="admonition-rust-help" class="admonition info">
<summary class="admonition-title">
<p>Rust help</p>
<p><a class="admonition-anchor-link" href="2_incrementality/4_store/index.html#admonition-rust-help"></a></p>
</summary>
<div>
<p>The <code>#[should_panic]</code> attribute makes the test succeed if it panics, and fail if it does not panic.</p>
</div>
</details>
<h3 id="testing-task-mapping"><a class="header" href="#testing-task-mapping">Testing task mapping</a></h3>
<p>Test the task mapping by inserting the following code into the <code>test</code> module (before the last <code>}</code>):</p>
<pre><code class="language-rust ">  #[test]
  fn test_task_mapping() {
    let mut store = Store::default();

    let task_a = StringConstant::new(&quot;Hello&quot;);
    let node_a = store.get_or_create_task_node(&amp;task_a);
    assert_eq!(node_a, store.get_or_create_task_node(&amp;task_a)); // Same node
    assert_eq!(&amp;task_a, store.get_task(&amp;node_a)); // Same task

    let task_b = StringConstant::new(&quot;World&quot;);
    let node_b = store.get_or_create_task_node(&amp;task_b);
    assert_eq!(node_b, store.get_or_create_task_node(&amp;task_b));
    assert_eq!(&amp;task_b, store.get_task(&amp;node_b));

    assert_ne!(node_a, node_b); // Different nodes
  }

  #[test]
  #[should_panic]
  fn test_task_mapping_panics() {
    let mut fake_store = Store::default();
    let fake_node = fake_store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    let store: Store&lt;StringConstant, String&gt; = Store::default();
    store.get_task(&amp;fake_node);
  }</code></pre>
<p>We test this in the same way as the file mapping.
Again, this works because <code>StringConstant(&quot;Hello&quot;)</code> and <code>StringConstant(&quot;World&quot;)</code> are different due to their derived <code>Eq</code> and <code>Hash</code> implementations, which make them different due to the strings being different. 
Likewise, <code>StringConstant::new(&quot;Hello&quot;)</code> and <code>StringConstant::new(&quot;Hello&quot;)</code> are equal even if they are created with 2 separate invocations of <code>new</code>.</p>
<p>These (in)equalities might seem quite obvious, but it is important to keep in mind because incrementality can only work if we can identify equal tasks at a later time, so that we can check their dependencies and return their cached output when those dependencies are consistent.
Later on we will also see that this is important for soundness of the incremental build system.</p>
<h3 id="testing-task-outputs"><a class="header" href="#testing-task-outputs">Testing task outputs</a></h3>
<p>Test task outputs by inserting the following code into the <code>test</code> module:</p>
<pre><code class="language-rust ">  #[test]
  fn test_task_outputs() {
    let mut store = Store::default();
    let output_a = &quot;Hello&quot;.to_string();
    let task_a = StringConstant::new(&amp;output_a);
    let node_a = store.get_or_create_task_node(&amp;task_a);

    let output_b = &quot;World&quot;.to_string();
    let task_b = StringConstant::new(&amp;output_b);
    let node_b = store.get_or_create_task_node(&amp;task_b);

    // Assert that tasks have no output by default.
    assert!(!store.task_has_output(&amp;node_a));
    assert!(!store.task_has_output(&amp;node_b));

    // Set output for task A, assert that A has that output but B is unchanged.
    store.set_task_output(&amp;node_a, output_a.clone());
    assert!(store.task_has_output(&amp;node_a));
    assert_eq!(store.get_task_output(&amp;node_a), &amp;output_a);
    assert!(!store.task_has_output(&amp;node_b));

    // Set output for task B, assert that B has that output but A is unchanged.
    store.set_task_output(&amp;node_b, output_b.clone());
    assert!(store.task_has_output(&amp;node_a));
    assert_eq!(store.get_task_output(&amp;node_a), &amp;output_a);
    assert!(store.task_has_output(&amp;node_b));
    assert_eq!(store.get_task_output(&amp;node_b), &amp;output_b);
  }

  #[test]
  #[should_panic]
  fn test_task_has_output_panics() {
    let mut fake_store = Store::default();
    let fake_node = fake_store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    let store: Store&lt;StringConstant, String&gt; = Store::default();
    store.task_has_output(&amp;fake_node);
  }

  #[test]
  #[should_panic]
  fn test_get_task_output_panics() {
    let mut store = Store::default();
    let node = store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    store.get_task_output(&amp;node);
  }

  #[test]
  #[should_panic]
  fn test_set_task_output_panics() {
    let mut fake_store = Store::default();
    let fake_node = fake_store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    let mut store: Store&lt;StringConstant, String&gt; = Store::default();
    store.set_task_output(&amp;fake_node, &quot;Hello&quot;.to_string());
  }
  </code></pre>
<p>Test <code>test_task_outputs</code> ensures that:</p>
<ul>
<li><code>task_has_output</code> only returns true if given task has an output, </li>
<li>and that <code>get_task_output</code> returns the output set by <code>set_task_output</code> for given task.</li>
</ul>
<p>Test <code>test_get_task_output_panics</code> triggers a panic when we call <code>get_task_output</code> for a task that has no output, which is an invalid usage of <code>Store</code> that is more likely to happen than the other panics. </p>
<h3 id="testing-dependencies"><a class="header" href="#testing-dependencies">Testing dependencies</a></h3>
<p>Test dependencies by inserting the following code into the <code>test</code> module:</p>
<pre><code class="language-rust ">  #[test]
  fn test_dependencies() {
    let mut store = Store::default();
    let output_a = &quot;Hello&quot;.to_string();
    let task_a = StringConstant::new(output_a.clone());
    let node_a = store.get_or_create_task_node(&amp;task_a);
    let output_b = &quot;World&quot;.to_string();
    let task_b = StringConstant::new(output_b.clone());
    let node_b = store.get_or_create_task_node(&amp;task_b);
    let path_c = PathBuf::from(&quot;hello.txt&quot;);
    let node_c = store.get_or_create_file_node(&amp;path_c);

    assert_eq!(store.get_dependencies_of_task(&amp;node_a).next(), None);
    assert_eq!(store.get_dependencies_of_task(&amp;node_b).next(), None);

    // Add file dependency from task A to file C.
    let file_dependency_a2c = FileDependency::new(&amp;path_c, FileStamper::Exists).unwrap();
    store.add_file_require_dependency(&amp;node_a, &amp;node_c, file_dependency_a2c.clone());
    let deps_of_a: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;node_a).cloned().collect();
    assert_eq!(deps_of_a.get(0), Some(&amp;Dependency::RequireFile(file_dependency_a2c.clone())));
    assert_eq!(deps_of_a.get(1), None);
    assert_eq!(store.get_dependencies_of_task(&amp;node_b).next(), None);

    // Add task dependency from task B to task A.
    let task_dependency_b2a = TaskDependency::new(task_a.clone(), OutputStamper::Equals, output_a.clone());
    let result = store.add_task_require_dependency(&amp;node_b, &amp;node_a, task_dependency_b2a.clone());
    assert_eq!(result, Ok(()));
    let deps_of_a: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;node_a).cloned().collect();
    assert_eq!(deps_of_a.get(0), Some(&amp;Dependency::RequireFile(file_dependency_a2c.clone())));
    assert_eq!(deps_of_a.get(1), None);
    let deps_of_b: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;node_b).cloned().collect();
    assert_eq!(deps_of_b.get(0), Some(&amp;Dependency::RequireTask(task_dependency_b2a.clone())));
    assert_eq!(deps_of_b.get(1), None);

    // Add file dependency from task B to file C.
    let file_dependency_b2c = FileDependency::new(&amp;path_c, FileStamper::Exists).unwrap();
    store.add_file_require_dependency(&amp;node_b, &amp;node_c, file_dependency_b2c.clone());
    let deps_of_a: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;node_a).cloned().collect();
    assert_eq!(deps_of_a.get(0), Some(&amp;Dependency::RequireFile(file_dependency_a2c.clone())));
    assert_eq!(deps_of_a.get(1), None);
    let deps_of_b: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;node_b).cloned().collect();
    assert_eq!(deps_of_b.get(0), Some(&amp;Dependency::RequireTask(task_dependency_b2a.clone())));
    assert_eq!(deps_of_b.get(1), Some(&amp;Dependency::RequireFile(file_dependency_b2c.clone())));
    assert_eq!(deps_of_b.get(2), None);

    // Add task dependency from task A to task B, creating a cycle.
    let task_dependency_a2b = TaskDependency::new(task_a.clone(), OutputStamper::Equals, output_a.clone());
    let result = store.add_task_require_dependency(&amp;node_a, &amp;node_b, task_dependency_a2b);
    assert_eq!(result, Err(())); // Creates a cycle: error
  }

  #[test]
  #[should_panic]
  fn test_get_dependencies_of_task_panics() {
    let mut fake_store = Store::default();
    let fake_node = fake_store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    let store: Store&lt;StringConstant, String&gt; = Store::default();
    let _ = store.get_dependencies_of_task(&amp;fake_node);
  }

  #[test]
  #[should_panic]
  fn test_add_file_require_dependency_panics() {
    let mut fake_store = Store::default();
    let fake_file_node = fake_store.get_or_create_file_node(&quot;hello.txt&quot;);
    let fake_task_node = fake_store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    let mut store: Store&lt;StringConstant, String&gt; = Store::default();
    let dependency = FileDependency::new(&quot;hello.txt&quot;, FileStamper::Exists).unwrap();
    store.add_file_require_dependency(&amp;fake_task_node, &amp;fake_file_node, dependency);
  }

  #[test]
  #[should_panic]
  fn test_add_task_require_dependency_panics() {
    let mut fake_store = Store::default();
    let output = &quot;Hello&quot;.to_string();
    let task = StringConstant::new(&amp;output);
    let fake_task_node = fake_store.get_or_create_task_node(&amp;task);
    let mut store: Store&lt;StringConstant, String&gt; = Store::default();
    let dependency = TaskDependency::new(task, OutputStamper::Equals, output);
    let _ = store.add_task_require_dependency(&amp;fake_task_node, &amp;fake_task_node, dependency);
  }</code></pre>
<p>The <code>test_dependencies</code> test is a bit more involved because it ensures that:</p>
<ul>
<li><code>get_dependencies_of_task</code> returns the dependencies of given task. If the task has no dependencies, the iterator is empty. We test if an iterator is empty by getting the first element of the iterator with <code>.next()</code> and assert that it is <code>None</code>.</li>
<li><code>get_dependencies_of_task</code> returns the dependencies of given task in the order in which they were added, which will be important for soundness later. The graph library returns dependencies in insertion order.</li>
<li><code>add_task_require_dependency</code> adds a dependency to the correct task.</li>
<li>creating a cycle with <code>add_task_require_dependency</code> results in it returning <code>Err(())</code>.</li>
</ul>
<p>Note that the <code>StringConstant</code> task does not actually create file or task dependencies, but since <code>Store</code> never executes a task, we can pretend that it does in tests. </p>
<h3 id="testing-task-reset"><a class="header" href="#testing-task-reset">Testing task reset</a></h3>
<p>Finally, test task reset by inserting the following code into the <code>test</code> module:</p>
<pre><code class="language-rust ">  #[test]
  fn test_reset() {
    let mut store = Store::default();
    let output_a = &quot;Hello&quot;.to_string();
    let task_a = StringConstant::new(output_a.clone());
    let task_a_node = store.get_or_create_task_node(&amp;task_a);
    let output_b = &quot;World&quot;.to_string();
    let task_b = StringConstant::new(output_b.clone());
    let task_b_node = store.get_or_create_task_node(&amp;task_b);
    let path = PathBuf::from(&quot;hello.txt&quot;);
    let file_node = store.get_or_create_file_node(&amp;path);

    // Set outputs for task A and B.
    store.set_task_output(&amp;task_a_node, output_a.clone());
    assert!(store.task_has_output(&amp;task_a_node));
    assert_eq!(store.get_task_output(&amp;task_a_node), &amp;output_a);
    store.set_task_output(&amp;task_b_node, output_b.clone());
    assert!(store.task_has_output(&amp;task_b_node));
    assert_eq!(store.get_task_output(&amp;task_b_node), &amp;output_b);

    // Add file dependency for task A and B.
    let file_dependency = FileDependency::new(&amp;path, FileStamper::Exists).unwrap();
    store.add_file_require_dependency(&amp;task_a_node, &amp;file_node, file_dependency.clone());
    let deps_of_a: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;task_a_node).cloned().collect();
    assert_eq!(deps_of_a.get(0), Some(&amp;Dependency::RequireFile(file_dependency.clone())));
    assert_eq!(deps_of_a.get(1), None);
    store.add_file_require_dependency(&amp;task_b_node, &amp;file_node, file_dependency.clone());
    let deps_of_b: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;task_b_node).cloned().collect();
    assert_eq!(deps_of_b.get(0), Some(&amp;Dependency::RequireFile(file_dependency.clone())));
    assert_eq!(deps_of_b.get(1), None);

    // Reset only task A.
    store.reset_task(&amp;task_a_node);
    // Assert that task A is reset.
    assert!(!store.task_has_output(&amp;task_a_node));
    assert_eq!(store.get_dependencies_of_task(&amp;task_a_node).next(), None);
    // Assert that task B is unchanged.
    assert!(store.task_has_output(&amp;task_b_node));
    assert_eq!(store.get_task_output(&amp;task_b_node), &amp;output_b);
    let deps_of_b: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;task_b_node).cloned().collect();
    assert_eq!(deps_of_b.get(0), Some(&amp;Dependency::RequireFile(file_dependency.clone())));
    assert_eq!(deps_of_b.get(1), None);
  }

  #[test]
  #[should_panic]
  fn test_reset_task_panics() {
    let mut fake_store = Store::default();
    let fake_node = fake_store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    let mut store: Store&lt;StringConstant, String&gt; = Store::default();
    store.reset_task(&amp;fake_node);
  }</code></pre>
<p>Here, we ensure that a task with an output and dependencies, does not have an output and dependencies after a reset, while leaving another task untouched.</p>
<p>Confirm that the store implementation works with <code>cargo test</code>.</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="2_incrementality/4_store/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="2_incrementality/4_store/../../gen/2_incrementality/4_store/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="top-down-context"><a class="header" href="#top-down-context">Top-down Context</a></h1>
<p>We've implemented all the prerequisites for incremental top-down building.
Now we will create the <code>TopDownContext</code> type which implements the <code>Context</code> trait in an incremental way. </p>
<h2 id="top-down-context-basics"><a class="header" href="#top-down-context-basics">Top-down context basics</a></h2>
<p>Add the <code>top_down</code> module to <code>pie/src/context/mod.rs</code>:</p>
<div class="diff2html" id="diff2html_0"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/mod.rs
+++ pie/src/context/mod.rs
@@ -1 +1,2 @@
 pub mod non_incremental;
+pub mod top_down;
`;
    let target = document.getElementById('diff2html_0');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Create the <code>pie/src/context/top_down.rs</code> file and add the following to get started:</p>
<pre><code class="language-rust ">use std::fs::File;
use std::io;
use std::path::Path;

use crate::{Context, fs, Task};
use crate::dependency::{FileDependency, TaskDependency};
use crate::stamp::{FileStamper, OutputStamper};
use crate::store::{Store, TaskNode};

pub struct TopDownContext&lt;T, O&gt; {
  store: Store&lt;T, O&gt;,
}

impl&lt;T: Task&gt; TopDownContext&lt;T, T::Output&gt; {
  pub fn new() -&gt; Self {
    Self {
      store: Store::default(),
    }
  }
}

impl&lt;T: Task&gt; Context&lt;T&gt; for TopDownContext&lt;T, T::Output&gt; {
  fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
    todo!()
  }

  fn require_task_with_stamper(&amp;mut self, task: &amp;T, stamper: OutputStamper) -&gt; T::Output {
    todo!()
  }
}</code></pre>
<p>The <code>TopDownContext</code> type is generic over tasks <code>T</code> and their outputs <code>O</code>, owns a <code>Store</code>, and can be created using <code>new</code>.</p>
<p><code>TopDownContext</code> implements <code>Context</code>, and the main challenge will be implementing the <code>require_file_with_stamper</code> and <code>require_task_with_stamper</code> methods <em>incrementally</em> and <em>correctly</em>.</p>
<h2 id="requiring-files-1"><a class="header" href="#requiring-files-1">Requiring files</a></h2>
<p>Tasks such as <code>ReadStringFromFile</code> which we've used in tests before call <code>context.require_file</code> to declare that they depend on a file in the filesystem.
For incrementality, we need to add this dependency to the dependency graph.
This dependency will go from the <em>current executing task</em> to the file.
Therefore, we will need to keep track of the current executing task.</p>
<p>Change <code>pie/src/context/mod.rs</code> to add a field for tracking the current executing task, and use it in <code>require_file_with_stamper</code>:</p>
<div class="diff2html" id="diff2html_1"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -9,18 +9,23 @@
 
 pub struct TopDownContext<T, O> {
   store: Store<T, O>,
+  current_executing_task: Option<TaskNode>,
 }
 
 impl<T: Task> TopDownContext<T, T::Output> {
   pub fn new() -> Self {
     Self {
       store: Store::default(),
+      current_executing_task: None,
     }
   }
 }
 
 impl<T: Task> Context<T> for TopDownContext<T, T::Output> {
   fn require_file_with_stamper<P: AsRef<Path>>(&mut self, path: P, stamper: FileStamper) -> Result<Option<File>, io::Error> {
+    let Some(current_executing_task_node) = &self.current_executing_task else {
+      return fs::open_if_file(path); // No current executing task, so no dependency needs to be made.
+    };
     todo!()
   }
 
`;
    let target = document.getElementById('diff2html_1');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We're not setting <code>current_executing_task</code> yet, as that is the responsibility of <code>require_task_with_stamper</code> which we will implement later.
In <code>require_file_with_stamper</code> we're now getting the current executing task.
If there is no current executing task, which only happens if a user directly calls <code>require_file</code> on a context, we don't make a dependency and just open the file.</p>
<p>Now we need to add the file dependency, change <code>pie/src/context/mod.rs</code> to do this: </p>
<div class="diff2html" id="diff2html_2"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -26,7 +26,11 @@
     let Some(current_executing_task_node) = &self.current_executing_task else {
       return fs::open_if_file(path); // No current executing task, so no dependency needs to be made.
     };
-    todo!()
+    let path = path.as_ref();
+    let node = self.store.get_or_create_file_node(path);
+    let (dependency, file) = FileDependency::new_with_file(path, stamper)?;
+    self.store.add_file_require_dependency(current_executing_task_node, &node, dependency);
+    Ok(file)
   }
 
   fn require_task_with_stamper(&mut self, task: &T, stamper: OutputStamper) -> T::Output {
`;
    let target = document.getElementById('diff2html_2');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We simply create or get an existing file node, create a file dependency, and add the file require dependency to the graph via <code>store</code>.
Errors are propagated to the caller, so they can react accordingly to filesystem operation failures.</p>
<h2 id="requiring-tasks"><a class="header" href="#requiring-tasks">Requiring tasks</a></h2>
<p>To implement <code>require_task_with_stamper</code>, we need to check whether we should execute a task.
A task should be executed either if it's new (it does not have an output stored yet), or if at least one of its dependencies is inconsistent.
If we don't execute it, then it must have an output value and all its dependencies are consistent, so we just return its output value.</p>
<p>Change <code>pie/src/context/mod.rs</code> to implement this logic:</p>
<div class="diff2html" id="diff2html_3"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -34,6 +34,22 @@
   }
 
   fn require_task_with_stamper(&mut self, task: &T, stamper: OutputStamper) -> T::Output {
-    todo!()
+    let node = self.store.get_or_create_task_node(task);
+
+    // Get required task output by executing it if needed, or by getting the output from the store if not needed.
+    let output = if self.should_execute_task(&node) {
+      self.store.reset_task(&node);
+      let previous_executing_task = self.current_executing_task.replace(node);
+      let output = task.execute(self);
+      self.current_executing_task = previous_executing_task;
+      self.store.set_task_output(&node, output.clone());
+      output
+    } else {
+      // Correctness: when ${"`"}should_execute_task${"`"} returns ${"`"}true${"`"}, the above block is executed. Otherwise this block is 
+      // executed and ${"`"}should_execute_task${"`"} ensures that the task has an output.
+      self.store.get_task_output(&node).clone()
+    };
+
+    output
   }
 }
`;
    let target = document.getElementById('diff2html_3');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We first create or get an existing file node.
Then, we check whether the task should be executed with <code>should_execute_task</code> which we still need to implement.</p>
<p>If that returns true, we reset the task, set the current executing task, actually execute the task, restore the previous executing task, and set the task output.
Otherwise, we get the output of the task from the store, which cannot panic because <code>should_execute_task</code> ensures that the task has an output if it returns false.
Finally, we return the output.</p>
<p>We still need to create a task dependency. Change <code>pie/src/context/mod.rs</code> to add the dependency:</p>
<div class="diff2html" id="diff2html_4"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -50,6 +50,15 @@
       self.store.get_task_output(&node).clone()
     };
 
+    // Create task require dependency if a task is currently executing (i.e., we are not requiring the initial task).
+    if let Some(current_executing_task_node) = &self.current_executing_task {
+      let dependency = TaskDependency::new(task.clone(), stamper, output.clone());
+      if self.store.add_task_require_dependency(current_executing_task_node, &node, dependency).is_err() {
+        let current_executing_task = self.store.get_task(current_executing_task_node);
+        panic!("Cyclic task dependency; current executing task '{:?}' is requiring task '{:?}' which was already required", current_executing_task, task);
+      }
+    }
+
     output
   }
 }
`;
    let target = document.getElementById('diff2html_4');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>If there is no current executing task, which occurs when a user requires the initial task, we skip creating a dependency.
Otherwise, we create a dependency and add it to the store.
However, creating a task dependency can create cycles, and we need to handle that error.</p>
<p>At this point, we need to make a hard decision about the API of our library.
<code>require_task_with_stamper</code> returns the task output, with no opportunity to return an error.
If we want to propagate this error, we'd need to change the <code>Context::require_task</code> API to return <code>Result&lt;T::Output, CycleError&gt;</code>.
However, because tasks call these methods on <code>Context</code>, we'd also need to change <code>Task::execute</code> to return <code>Result&lt;T::Output, CycleError&gt;</code>.
That would require all tasks to propagate these cycle errors every time they require another task.</p>
<p>Furthermore, some tasks want to return their own kinds of errors, where <code>T::Output</code> will be <code>Result&lt;AnOutput, AnError&gt;</code>.
In that case, the concrete return type would be <code>Result&lt;Result&lt;AnOutput, AnError&gt;, CycleError&gt;</code>, which is annoying to deal with.</p>
<p>On the other hand, we can panic when a cycle is found, which requires no changes to the API.
We do end up in a mostly unrecoverable state, so a panic is a valid option.
However, this is not ideal, because it means the build system can panic due to invalid task dependencies created by the user of the system.
Panics will (most of the time) stop the program, which can be annoying to deal with.</p>
<p>This is a hard trade-off to make.
Either we propagate errors which will not end the program but will introduce a lot of boilerplate and annoyance in task implementations.
Or we panic which will end the program but introduces no boilerplate.</p>
<p>In this tutorial, we will go with panics on cycles, because it results in a much simpler system.</p>
<details id="admonition-recovering-from-panics" class="admonition info">
<summary class="admonition-title">
<p>Recovering from panics</p>
<p><a class="admonition-anchor-link" href="2_incrementality/5_context/index.html#admonition-recovering-from-panics"></a></p>
</summary>
<div>
<p>Panics either abort the program (when panics are set to abort in <code>Cargo.toml</code>), or unwind the call stack and then end the program.</p>
<p>When panics abort, there is nothing we can do about it. 
A panic will immediately abort the program.
When panics unwind, the call stack is unwound, which still runs all destructors (<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>), and this unwinding can be caught.</p>
<p>We can catch unwinding panics with <a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a>, which is a way to recover from panics.
This does require that the types used in the closure passed to <code>catch_unwind</code> are <a href="https://doc.rust-lang.org/std/panic/trait.UnwindSafe.html">unwind safe</a>.
This is because panics exit a function early, which can mess up some invariants of your code.
For example, a call to set a task output can be skipped when a panic occurs, breaking a code invariant.
Therefore, types such as <code>&amp;mut T</code> are not unwind safe by default, because these invariants can break under panics.</p>
<p>Note that unwind safety is something different than the general safety guarantees provided by Rust: type-safe, memory-safe, thread-safe.
An unwind unsafe type is still type-safe, memory-safe, and thread-safe.</p>
<p>Unwind safety can be more easily achieved by using owned types which run destructors when the function call ends, which work under normal circumstances, but also when unwinding panics.</p>
<p>In the context of the PIE build system, if we panic on unrecoverable errors, but want to allow catching these panics, we need to think about unwind safety.
At any point we panic, we need to think about keeping the system in a valid state.</p>
<p>Another way to recover from panics is to run the panicking code on a different thread.
If the code panics, it will only end that thread, effectively allowing panic recovery.
However, this does require some form of thread-safety, beause you are moving a computation to a different thread.
Furthermore, some platforms do not have access to threads, such as WASM, where this approach would not work.</p>
<p>A final note is that care must be taken when <a href="https://doc.rust-lang.org/nomicon/ffi.html#ffi-and-unwinding">unwiding panics across foreign function interfaces (FFI)</a>.</p>
</div>
</details>
<h2 id="checking-tasks"><a class="header" href="#checking-tasks">Checking tasks</a></h2>
<p>The final piece to our puzzle is the <code>should_execute_task</code> implementation.</p>
<p>Add the following code to <code>pie/src/context/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_5"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -62,3 +62,23 @@
     output
   }
 }
+
+impl<T: Task> TopDownContext<T, T::Output> {
+  /// Checks whether given task should be executed, returning ${"`"}true${"`"} if it should be executed. A task should be executed
+  /// if any of its dependencies are inconsistent, or when it has no output.
+  fn should_execute_task(&mut self, node: &TaskNode) -> bool {
+    // Borrow: because we pass ${"`"}self${"`"} (which is ${"`"}&mut self${"`"}) to ${"`"}is_inconsistent${"`"} for recursive consistency checking, 
+    //         we need to clone and collect dependencies into a ${"`"}Vec${"`"}. Otherwise we have an immutable borrow of ${"`"}self${"`"}
+    //         through ${"`"}self.store${"`"} while we create a mutable borrow of ${"`"}self${"`"}, which is not allowed.
+    let dependencies: Vec<_> = self.store.get_dependencies_of_task(node).cloned().collect();
+    for dependency in dependencies {
+      match dependency.is_inconsistent(self) {
+        Ok(Some(_)) => return true,
+        _ => {} // Consistent: continue checking
+      }
+    }
+    // Task has no dependencies or all dependencies are consistent. Should only execute if it has no output, meaning
+    // that it has never been executed before.
+    return !self.store.task_has_output(node);
+  }
+}
`;
    let target = document.getElementById('diff2html_5');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>The premise of <code>should_execute_task</code> is simple: go over the dependencies of a task until <code>dependency.is_inconsistent</code> is true, at which we return true.
If all dependencies are consistent, then return true only if the task has no output.
Otherwise, return false.</p>
<p>However, there are some complications due to borrowing.
Checking if a task dependency is inconsistent requires recursive checking: <code>TaskDependency::is_inconsistent</code> requires a <code>&amp;mut Context</code> to call <code>Context::require_task</code>, which in turn can require this method again. 
To that end, we pass <code>self</code> to <code>is_inconsistent</code>, because <code>self</code> is an instance of <code>TopDownContext</code> which implements <code>Context</code>.</p>
<p>In this method, <code>self</code> is <code>&amp;mut self</code>, a mutable borrow.
Therefore, we cannot have <em>any other borrows</em> active while <code>is_inconsistent</code> is being called, because that would violate one of the safety mechanisms of Rust where mutable borrows are <em>exclusive</em>.
Getting the task's dependencies from the store requires a borrow, so we cannot hold onto that borrow.
We get around that here by cloning the dependencies and collecting them into a <code>Vec</code>.</p>
<p>We also document this fact in a comment to explain to readers (us in the future) why we do this cloning, preventing refactorings only to hit that same borrowing issue again. </p>
<p>Cloning and collecting does have a performance overhead as we need to clone the dependencies and heap allocate a <code>Vec</code> to store them.
For this tutorial, that is fine, but in a real-world application we should minimize cloning if possible and look into reducing heap allocations.</p>
<details id="admonition-reference-counting" class="admonition info">
<summary class="admonition-title">
<p>Reference counting</p>
<p><a class="admonition-anchor-link" href="2_incrementality/5_context/index.html#admonition-reference-counting"></a></p>
</summary>
<div>
<p>Cloning a <code>Dependency</code> results in heap allocations, because cloning <code>FileDependency</code> clones a <code>PathBuf</code> which is a heap allocated string (basically a <code>Vec&lt;u8&gt;</code>), and cloning a <code>TaskDependency</code> clones the <code>Task</code>, which may require allocations as well.</p>
<p>One way to avoid heap allocations in both kinds of dependencies is to store the <code>PathBuf</code> and <code>Task</code> in a <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">reference-counting pointer <code>Rc</code></a>.
Then, there will only be one heap allocated <code>PathBuf</code> and <code>Task</code>, and cloning just increments the reference count.
The upside is that this approach is easy to implement and reduces allocations.
The downside is that clones require incrementing the reference count, which is a write operation that does have a tiny bit of overhead.
In many cases, this overhead is smaller than cloning data when the data is large enough or requires heap allocations.
In our case, it would probably be worth doing this, but benchmarking is required to confirm this.</p>
<p>Note that instead of always wrapping tasks in a <code>Rc</code>, task authors could implement <code>Task</code> on <code>Rc&lt;TheirTask&gt;</code> instead.
Since <code>Rc</code> implements <code>Clone</code>, any time we <code>task.clone()</code>, we would just increase the reference count instead.</p>
<p>When working in a multi-threaded situation, you would use the thread-safe <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> instead.</p>
</div>
</details>
<details id="admonition-string-optimizations" class="admonition info">
<summary class="admonition-title">
<p>String optimizations</p>
<p><a class="admonition-anchor-link" href="2_incrementality/5_context/index.html#admonition-string-optimizations"></a></p>
</summary>
<div>
<p>A technique for reducing allocations on strings (and string-like types such as <code>PathBuf</code>) is to apply <a href="https://fasterthanli.me/articles/small-strings-in-rust">small string optimization</a>, where small strings are stored inline instead of requiring a heap allocation.
This only works if the strings are usually small enough to fit inline on the stack (for example, 32 bytes).</p>
<p>Another technique for strings is string interning, where equal strings are stored in a central place and then re-used everywhere.
This technique is great when we use the same string a lot of times.
That may be a good strategy for a build system, where we work with the same file paths over and over.</p>
<p>There are several crates implementing these techniques, but I have not used one myself yet, so I cannot recommend one.</p>
</div>
</details>
<details id="admonition-avoiding-heap-allocations-from-collecting-into-vecs" class="admonition info">
<summary class="admonition-title">
<p>Avoiding heap allocations from collecting into Vecs</p>
<p><a class="admonition-anchor-link" href="2_incrementality/5_context/index.html#admonition-avoiding-heap-allocations-from-collecting-into-vecs"></a></p>
</summary>
<div>
<p>Collecting the elements of an iterator into a <code>Vec</code> requires heap allocations as <code>Vec</code> is allocated on the heap.
We can avoid or at least reduce the number of heap allocations by re-using the same <code>Vec</code> instead of creating a new one.
Instead of collecting, you would store the <code>Vec</code> in the struct, clear it, and then <code>extend</code> it with the iterator.</p>
<p>When you <code>clear</code> a <code>Vec</code>, it removes all the elements, but keeps the heap allocated space.
Only if you would add more elements than it has space for, another heap allocation would be required, which will happen less and less frequently when you keep reusing the same <code>Vec</code>.
The downside is that you are keeping this heap allocated space for as long as you keep reusing the same <code>Vec</code>, which could waste some memory, but usually this is not a big problem.
You could of course call <code>vec.shrink_to_fit()</code> after not using it for a while to free up this space.</p>
<p>However, we cannot apply this technique here, because if we store the <code>Vec</code> in <code>TopDownContext</code>, we would run into the same borrowing problem again.
This technique also requires that you have mutable access to the <code>Vec</code> in order to mutate it.</p>
<p>Both of these limitations can be overcome by using a <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell</code></a>.
<code>Cell</code> allows mutation to its inner value in an immutable context.
The catch is that you <em>cannot get a reference to its inner value</em>, you can only <code>take</code> the value out, mutate it, and then <code>set</code> it back.
Unfortunately, even this technique cannot be fully applied to <code>should_execute_task</code>, because it is called recursively and therefore the <code>Cell</code> will be empty when we try to <code>take</code> the <code>Vec</code> out.</p>
<p>If we want to avoid heap allocations from collecting new <code>Vec</code>s in <code>should_execute_task</code>, we would need to come up with a creative solution.
But this is outside of the scope of even this extra information block, so we'll just leave it at that.</p>
</div>
</details>
<p>Finally, we need to do something with dependency checking failures.
We've ignored the case where <code>dependency.is_inconsistent</code> returns <code>Err</code>.
When dependency checking result in an error, we should store the error for the user to investigate, and assume the dependency is inconsistent.</p>
<p>Change <code>pie/src/context/mod.rs</code> to store dependency check errors and give users access to it:</p>
<div class="diff2html" id="diff2html_6"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -10,6 +10,7 @@
 pub struct TopDownContext<T, O> {
   store: Store<T, O>,
   current_executing_task: Option<TaskNode>,
+  dependency_check_errors: Vec<io::Error>,
 }
 
 impl<T: Task> TopDownContext<T, T::Output> {
@@ -17,8 +18,13 @@
     Self {
       store: Store::default(),
       current_executing_task: None,
+      dependency_check_errors: Vec::default(),
     }
   }
+
+  pub fn get_dependency_check_errors(&self) -> impl Iterator<Item=&io::Error> {
+    self.dependency_check_errors.iter()
+  }
 }
 
 impl<T: Task> Context<T> for TopDownContext<T, T::Output> {
`;
    let target = document.getElementById('diff2html_6');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>And then change <code>pie/src/context/mod.rs</code> to store these errors:</p>
<div class="diff2html" id="diff2html_7"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -27,6 +27,7 @@
   }
 }
 
+
 impl<T: Task> Context<T> for TopDownContext<T, T::Output> {
   fn require_file_with_stamper<P: AsRef<Path>>(&mut self, path: P, stamper: FileStamper) -> Result<Option<File>, io::Error> {
     let Some(current_executing_task_node) = &self.current_executing_task else {
@@ -80,6 +81,10 @@
     for dependency in dependencies {
       match dependency.is_inconsistent(self) {
         Ok(Some(_)) => return true,
+        Err(e) => { // Error while checking: store error and assume inconsistent
+          self.dependency_check_errors.push(e);
+          return true;
+        }
         _ => {} // Consistent: continue checking
       }
     }
`;
    let target = document.getElementById('diff2html_7');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>It took us a while, but now we've implemented an incremental build system with dynamic dependencies 🎉.
Let's set up a simple example to see the fruits of our labour.</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="2_incrementality/5_context/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="2_incrementality/5_context/../../gen/2_incrementality/5_example/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="incrementality-example"><a class="header" href="#incrementality-example">Incrementality Example</a></h1>
<p>In this example, we will run our build system and show off simple incrementality with a task that reads a string from a file.</p>
<h2 id="readstringfromfile-task"><a class="header" href="#readstringfromfile-task"><code>ReadStringFromFile</code> task</a></h2>
<p>Create the <code>pie/examples</code> directory, and create the <code>pie/examples/incrementality.rs</code> file with the following contents:</p>
<pre><code class="language-rust ">#![allow(unused_imports, unused_variables)]

use std::io::{self, Read};
use std::path::{Path, PathBuf};

use dev_shared::{create_temp_dir, write_until_modified};
use pie::{Context, Task};
use pie::context::top_down::TopDownContext;
use pie::stamp::FileStamper;

/// Task that reads a string from a file.
#[derive(Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]
struct ReadStringFromFile(PathBuf, FileStamper);

impl ReadStringFromFile {
  fn new(path: impl AsRef&lt;Path&gt;, stamper: FileStamper) -&gt; Self {
    Self(path.as_ref().to_path_buf(), stamper)
  }
}

impl Task for ReadStringFromFile {
  type Output = Result&lt;String, io::ErrorKind&gt;;
  fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
    println!(&quot;Reading from {} with {:?} stamper&quot;, self.0.file_name().unwrap().to_string_lossy(), self.1);
    let file = context.require_file_with_stamper(&amp;self.0, self.1).map_err(|e| e.kind())?;
    if let Some(mut file) = file {
      let mut string = String::new();
      file.read_to_string(&amp;mut string).map_err(|e| e.kind())?;
      Ok(string)
    } else {
      Err(io::ErrorKind::NotFound)
    }
  }
}</code></pre>
<p>The <code>ReadStringFromFile</code> task is similar to the one we defined earlier in a test, but this one accepts a <code>FileStamper</code> as input, and propagates errors by returning a <code>Result</code>.
We cannot use <code>std::io::Error</code> as the error in the <code>Result</code>, because it does not implement <code>Clone</code> nor <code>Eq</code>, which need to be implemented for task outputs.
Therefore, we use <code>std::io::ErrorKind</code> which does implement these traits.</p>
<h2 id="exploring-incrementality"><a class="header" href="#exploring-incrementality">Exploring incrementality</a></h2>
<p>We've implemented the task, now add a <code>main</code> function to <code>pie/examples/incrementality.rs</code>:</p>
<pre><code class="language-rust ">fn main() -&gt; Result&lt;(), io::Error&gt; {
  let temp_dir = create_temp_dir()?;
  let input_file = temp_dir.path().join(&quot;input.txt&quot;);
  write_until_modified(&amp;input_file, &quot;Hi&quot;)?;

  let mut context = TopDownContext::new();
  let read_task = ReadStringFromFile::new(&amp;input_file, FileStamper::Modified);

  println!(&quot;A) New task: expect `read_task` to execute&quot;);
  // `read_task` is new, meaning that we have no cached output for it, thus it must be executed.
  let output = context.require_task(&amp;read_task)?;
  assert_eq!(&amp;output, &quot;Hi&quot;);

  Ok(())
}</code></pre>
<p>We create a temporary file, create a task, create a context, and require our first task.
Run this example with <code>cargo run --example incremental</code>.
You should see the <code>println!</code> in <code>ReadStringFromFile</code> appear in your console as the incremental context correctly determines that this task is new (i.e., has no output) and must be executed.
It should look something like:</p>
<pre><code>   Compiling pie v0.1.0 (/pie)
    Finished dev [unoptimized + debuginfo] target(s) in 0.96s
     Running `/pie/target/debug/examples/incremental`
A) New task: expect `read_task` to execute
Reading from input.txt with Modified stamper
</code></pre>
<h3 id="reuse"><a class="header" href="#reuse">Reuse</a></h3>
<p>If we require the task again, what should happen?</p>
<p>Insert the following code into the <code>main</code> method:</p>
<pre><code class="language-rust ">  println!(&quot;\nB) Reuse: expect no execution&quot;);
  // `read_task` is not new and its file dependency is still consistent. It is consistent because the modified time of 
  // `input_file` has not changed, thus the modified stamp is equal.
  let output = context.require_task(&amp;read_task)?;
  assert_eq!(&amp;output, &quot;Hi&quot;);</code></pre>
<p>Running with <code>cargo run --example incremental</code> should produce output like:</p>
<pre><code>   Compiling pie v0.1.0 (/pie)
    Finished dev [unoptimized + debuginfo] target(s) in 0.49s
     Running `/pie/target/debug/examples/incremental`
A) New task: expect `read_task` to execute
Reading from input.txt with Modified stamper

B) Reuse: expect no execution
</code></pre>
<p>We don't see the <code>println!</code> from <code>ReadStringFromFile</code>, so it was not executed, so our incremental build system has correctly reused its output!</p>
<p>Normally we would write a test to confirm that the task was executed the first time, and that it was not executed the second time.
However, this is not trivial.
How do we know if the task was executed?
We could track it with a global mutable boolean that <code>ReadStringFromFile</code> keeps track of, but this quickly becomes a mess.
Therefore, we will look into creating a proper testing infrastructure in the next chapter.</p>
<p>For now, we will continue this example with a couple more interesting cases.
The comments in the code explain in more detail why the build system behaves in this way.</p>
<h3 id="inconsistent-file-dependency"><a class="header" href="#inconsistent-file-dependency">Inconsistent file dependency</a></h3>
<p>Insert into the <code>main</code> method:</p>
<pre><code class="language-rust ">  write_until_modified(&amp;input_file, &quot;Hello&quot;)?;
  println!(&quot;\nC) Inconsistent file dependency: expect `read_task` to execute&quot;);
  // The file dependency of `read_task` is inconsistent due to the changed modified time of `input_file`.
  let output = context.require_task(&amp;read_task)?;
  assert_eq!(&amp;output, &quot;Hello&quot;);</code></pre>
<p>If we change the file (using <code>write_until_modified</code> to ensure that the modified time changes to trigger the <code>Modified</code> file stamper) and require the task, it should execute, because the file dependency of the task is no longer consistent.</p>
<h3 id="different-tasks"><a class="header" href="#different-tasks">Different tasks</a></h3>
<p>Insert into the <code>main</code> method:</p>
<pre><code class="language-rust ">  let input_file_b = temp_dir.path().join(&quot;input_b.txt&quot;);
  write_until_modified(&amp;input_file_b, &quot;Test&quot;)?;
  let read_task_b_modified = ReadStringFromFile::new(&amp;input_file_b, FileStamper::Modified);
  let read_task_b_exists = ReadStringFromFile::new(&amp;input_file_b, FileStamper::Exists);
  println!(&quot;\nD) Different tasks: expect `read_task_b_modified` and `read_task_b_exists` to execute&quot;);
  // Task `read_task`, `read_task_b_modified` and `read_task_b_exists` are different, due to their `Eq` implementation 
  // determining that their paths and stampers are different. Therefore, `read_task_b_modified` and `read_task_b_exists`
  // are new tasks, and must be executed.
  let output = context.require_task(&amp;read_task_b_modified)?;
  assert_eq!(&amp;output, &quot;Test&quot;);
  let output = context.require_task(&amp;read_task_b_exists)?;
  assert_eq!(&amp;output, &quot;Test&quot;);</code></pre>
<p>The identity of tasks is determined by their <code>Eq</code> and <code>Hash</code> implementations, which are typically derived to compare and hash all their fields.
Therefore, if we create read tasks for different input file <code>input_file_b</code> and different stamper <code>FileStamper::Exists</code>, these read tasks are not equal to the existing read task, and thus are <em>new</em> tasks with a different identity.
We require <code>read_task_b_modified</code> and <code>read_task_b_exists</code>, they are new, and are therefore executed.</p>
<h3 id="same-file-different-stampers"><a class="header" href="#same-file-different-stampers">Same file different stampers</a></h3>
<p>Insert into the <code>main</code> method:</p>
<pre><code class="language-rust ">  write_until_modified(&amp;input_file_b, &quot;Test Test&quot;)?;
  println!(&quot;\nE) Different stampers: expect only `read_task_b_modified` to execute&quot;);
  // Both `read_task_b_modified` and `read_task_b_exists` read from the same file, but they use different stampers.
  // Therefore, `read_task_b_modified` must be executed because the modified time has changed, but `read_task_b_exists`
  // will not be executed because its file dependency stamper only checks for existence of the file, and the existence 
  // of the file has not changed.
  //
  // Note that using an `Exists` stamper for this task does not make a lot of sense, since it will only read the file 
  // on first execute and when it is recreated. But this is just to demonstrate different stampers.
  let output = context.require_task(&amp;read_task_b_modified)?;
  assert_eq!(&amp;output, &quot;Test Test&quot;);
  let output = context.require_task(&amp;read_task_b_exists)?;
  assert_eq!(&amp;output, &quot;Test&quot;);
</code></pre>
<p>Here we write to <code>input_file_b</code> and then require <code>read_task_b_modified</code> and <code>read_task_b_exists</code>.
We expect <code>read_task_b_modified</code> to be executed, but <code>read_task_b_exists</code> to be skipped, because its file dependency only checks for the existence of the input file, which has not changed.
This shows that tasks can depend on the same file with different stampers, which influences whether the tasks are affected by a file change individually.</p>
<p>Of course, using an <code>Exists</code> stamper for <code>ReadStringFromFile</code> does not make a lot of sense, but this is for demonstration purposes only.</p>
<p>Running <code>cargo run --example incremental</code> now should produce output like:</p>
<pre><code>   Compiling pie v0.1.0 (/pie)
    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
     Running `/pie/target/debug/examples/incremental`
A) New task: expect `read_task` to execute
Reading from input.txt with Modified stamper

B) Reuse: expect no execution

C) Inconsistent file dependency: expect `read_task` to execute
Reading from input.txt with Modified stamper

D) Different tasks: expect `read_task_b_modified` and `read_task_b_exists` to execute
Reading from input_b.txt with Modified stamper
Reading from input_b.txt with Exists stamper

E) Different stampers: expect only `read_task_b_modified` to execute
Reading from input_b.txt with Modified stamper
</code></pre>
<p>Feel free to experiment more with this example (or new example files) before continuing.
In the next chapter, we will define minimality and soundness, set up an infrastructure for testing those properties, and fix issues uncovered by testing.</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="2_incrementality/6_example/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="2_incrementality/6_example/../../gen/2_incrementality/6_example/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimality-and-soundness"><a class="header" href="#minimality-and-soundness">Minimality and Soundness</a></h1>
<p>So far, the definitions we've used for minimality (incrementality) and soundness (correctness) have been a bit vague.
Let's define this more concretely and precisely.</p>
<p>An incremental and sound build system executes a task, if and only if, it is new or affected by a change.
A task is new if it has not been executed before.
When it is not new, a task is affected by a change when any of its dependencies are inconsistent.
A file dependency is inconsistent if its file stamp changes.
A task dependency is inconsistent if, after recursively checking the task, its output stamp changes. 
The recursive nature of checking task dependencies ensures that indirect changes can affect tasks and cause them to be correctly executed.</p>
<p>By defining minimality and soundness in terms of dependencies, a task author forgetting to create a dependency or not choosing the correct stamper, does not change whether our build system is minimal and sound.
PIE works under the assumption that task authors correctly list all dependencies that mark their task as affected by a change when it actually is. </p>
<details id="admonition-preventing-task-authoring-mistakes" class="admonition info">
<summary class="admonition-title">
<p>Preventing task authoring mistakes</p>
<p><a class="admonition-anchor-link" href="3_min_sound/index.html#admonition-preventing-task-authoring-mistakes"></a></p>
</summary>
<div>
<p>It is of course possible to make mistakes when authoring tasks, for example by creating a dependency to the wrong file, or by forgetting to create a file dependency.
Unfortunately, there is no easy way to solve this.</p>
<p>We will be writing a build event tracking system later, for which we will make an implementation that writes the entire build log to standard output.
This build log can help debug mistakes by precisely showing what the build system is doing.</p>
<p>A technique to catch file dependency mistakes is by sandboxing the filesystem to only have access to files that have been required.
For example, Bazel can perform <a href="https://bazel.build/docs/sandboxing">sandboxing</a>, but it is not fully cross-platform, and still allows reading files from absolute paths.
If a cross-platform and bulletproof sandboxing library exists, it could help catch file dependency mistakes in programmatic incremental build systems.</p>
<p>Finally, the ultimate technique to catch file dependency mistakes is by automatically creating these dependencies using filesystem tracing, instead of having the task author make them.
For example, the <a href="https://github.com/ndmitchell/rattle">Rattle</a> build system uses <a href="https://github.com/jacereda/fsatrace">fsatrace</a> to automatically create file dependencies, freeing task authors from having to think about file dependencies
However, filesystem tracing is also not fully cross-platform and bulletproof, so it cannot always be used.
Again, if a cross-platform and bulletproof filesystem tracing library exists, it would be extremely useful for programmatic incremental build systems.</p>
</div>
</details>
<p>In this chapter, we will show minimality and soundness by testing.
However, before testing, we make minimality and soundness more precise by changing the API to work with <em>sessions</em>, and implement build event tracking that is needed for testing.
We will continue as follows:</p>
<ol>
<li>Introduce sessions and change the API to work with sessions: <code>Session</code> type for performing builds in a session, and the <code>Pie</code> type as the entry point that manages sessions.</li>
<li>Create infrastructure to track build events for testing and debugging purposes. Create the <code>Tracker</code> trait, and implement a <code>WritingTracker</code> for debugging and <code>EventTracker</code> for testing.</li>
<li>Create integration tests that test incrementality and soundness.</li>
<li>Find a soundness hole where multiple tasks write to the same file. Fix it by tracking file write dependencies separately from read dependencies, and catch these mistakes with dynamic verification.</li>
<li>Find a soundness hole where a task reads from a file before another task writes to it. Fix it by catching these mistakes with dynamic verification.</li>
<li>Find a soundness hole where cyclic task execution can still occur. Fix it by changing how task dependencies are stored.</li>
</ol>
<details id="admonition-proving-minimality-and-soundness" class="admonition info">
<summary class="admonition-title">
<p>Proving minimality and soundness?</p>
<p><a class="admonition-anchor-link" href="3_min_sound/index.html#admonition-proving-minimality-and-soundness"></a></p>
</summary>
<div>
<p>While proving minimality and soundness would be a very interesting exercise, I am not at all an expert in formal proofs in proof assistants such as <a href="https://coq.inria.fr/">Coq</a>, <a href="https://wiki.portal.chalmers.se/agda/pmwiki.php">Agda</a>, etc.
If that is something that interests you, do pursue it and get in touch!</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimality-with-sessions"><a class="header" href="#minimality-with-sessions">Minimality with Sessions</a></h1>
<p>A task is consistent if its dependencies are consistent, and consistency of file dependencies is based on the filesystem.
However, the filesystem can change during a build, meaning that a task can be affected by multiple different changes in one build.
For example, after executing a task, it could immediately be affected by a change in a source file again without the build system knowing about it, and that would not be minimal nor sound.</p>
<p>Therefore, we will introduce the concept of a <em>session</em>.
Builds are only performed in a session, and at most one session may exist at any given time.
In one session, each task is checked or executed <em>at most once</em>, meaning that changes made to source files during a session are <em>not guaranteed to be detected</em>.</p>
<p>The result is that if a task is deemed inconsistent at the time it is checked, it will be executed, and will not be checked nor executed any more that session.
If a task is deemed consistent at the time it is checked, it will not be checked any more that session.
This simplifies minimality and soundness, as we do not need to worry about checking tasks multiple times.
Furthermore, it is also an optimisation, as requiring the same task many times only results in one check.</p>
<p>We will continue as follows:</p>
<ol>
<li>Create the <code>Session</code> type to hold all session data, and the <code>Pie</code> type as an entry point into the build system that manages a session.</li>
<li>Update <code>TopDownContext</code> to work with <code>Session</code>.</li>
<li>Update the incrementality example to work with <code>Session</code> and <code>Pie</code>.</li>
<li>Ensure minimality by keeping track whether a task has been required this session.</li>
</ol>
<h2 id="pie-and-session"><a class="header" href="#pie-and-session">PIE and Session</a></h2>
<p>Change the imports in <code>pie/src/lib.rs</code>: </p>
<div class="diff2html" id="diff2html_0"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -6,6 +6,9 @@
 
 use stamp::{FileStamper, OutputStamper};
 
+use crate::context::top_down::TopDownContext;
+use crate::store::{Store, TaskNode};
+
 pub mod stamp;
 pub mod dependency;
 pub mod context;
`;
    let target = document.getElementById('diff2html_0');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Now add the <code>Pie</code> and <code>Session</code> types to <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust ">/// Main entry point into PIE, a sound and incremental programmatic build system.
pub struct Pie&lt;T, O&gt; {
  store: Store&lt;T, O&gt;,
}

impl&lt;T: Task&gt; Default for Pie&lt;T, T::Output&gt; {
  fn default() -&gt; Self { Self { store: Store::default() } }
}

impl&lt;T: Task&gt; Pie&lt;T, T::Output&gt; {
  /// Creates a new build session. Only one session may be active at once, enforced via mutable (exclusive) borrow.
  pub fn new_session(&amp;mut self) -&gt; Session&lt;T, T::Output&gt; { Session::new(self) }
  /// Runs `f` inside a new build session.
  pub fn run_in_session&lt;R&gt;(&amp;mut self, f: impl FnOnce(Session&lt;T, T::Output&gt;) -&gt; R) -&gt; R {
    let session = self.new_session();
    f(session)
  }
}

/// A session in which builds are executed.
pub struct Session&lt;'p, T, O&gt; {
  store: &amp;'p mut Store&lt;T, O&gt;,
  current_executing_task: Option&lt;TaskNode&gt;,
  dependency_check_errors: Vec&lt;io::Error&gt;,
}

impl&lt;'p, T: Task&gt; Session&lt;'p, T, T::Output&gt; {
  fn new(pie: &amp;'p mut Pie&lt;T, T::Output&gt;) -&gt; Self {
    Self {
      store: &amp;mut pie.store,
      current_executing_task: None,
      dependency_check_errors: Vec::default(),
    }
  }

  /// Requires `task`, returning its up-to-date output.
  pub fn require(&amp;mut self, task: &amp;T) -&gt; T::Output {
    todo!(&quot;Create TopDownContext with this session, and require the task&quot;)
  }

  /// Gets all errors produced during dependency checks.
  pub fn dependency_check_errors(&amp;self) -&gt; &amp;[io::Error] { &amp;self.dependency_check_errors }
}</code></pre>
<p>We set up the types such that <code>Pie</code> owns the store, and <code>Session</code> owns all data for a build session that <code>TopDownContext</code> previously owned.
We put the store in <code>Pie</code> because we want to keep the dependency graph and task outputs between build sessions, otherwise we cannot be incremental.</p>
<p>A <code>Session</code> is created with <code>Pie::new_session</code>, which borrows <code>Pie</code> mutibly, ensuring that there can only be one <code>Session</code> instance (per <code>Pie</code> instance).
<code>run_in_session</code> is a convenience method that runs given function inside a new session.</p>
<p><code>Session::require</code> should require the task with the top-down context and return its up-to-date output, which we will implement once we've changed <code>TopDownContext</code>.
The dependency check errors can be accessed with <code>Session::dependency_check_errors</code>.</p>
<p>Note that <code>Session</code> also has access to <code>Store</code>, because <code>TopDownContext</code> needs access to the store.
The store is mutibly borrowed from <code>Pie</code>.
Therefore, the <code>Session</code> struct is generic over the <code>'p</code> lifetime, where the <code>p</code> stands for <code>Pie</code>.
We can leave out this lifetime in <code>Pie::new_session</code>, because the compiler infers it from us, but we must be explicit in structs and most impls.</p>
<p>Check that the code compiles (but gives warnings) with <code>cargo check</code>.</p>
<p>Now we need to modify <code>TopDownContext</code> to work with <code>Session</code>.</p>
<h2 id="update-topdowncontext"><a class="header" href="#update-topdowncontext">Update TopDownContext</a></h2>
<p>Change <code>TopDownContext</code> to only contain a mutable reference to <code>Session</code> in <code>pie/src/context/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_1"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -2,28 +2,20 @@
 use std::io;
 use std::path::Path;
 
-use crate::{Context, fs, Task};
+use crate::{Context, fs, Session, Task};
 use crate::dependency::{FileDependency, TaskDependency};
 use crate::stamp::{FileStamper, OutputStamper};
-use crate::store::{Store, TaskNode};
+use crate::store::TaskNode;
 
-pub struct TopDownContext<T, O> {
-  store: Store<T, O>,
-  current_executing_task: Option<TaskNode>,
-  dependency_check_errors: Vec<io::Error>,
+pub struct TopDownContext<'p, 's, T, O> {
+  session: &'s mut Session<'p, T, O>,
 }
 
-impl<T: Task> TopDownContext<T, T::Output> {
-  pub fn new() -> Self {
-    Self {
-      store: Store::default(),
-      current_executing_task: None,
-      dependency_check_errors: Vec::default(),
-    }
-  }
+impl<'p, 's, T: Task> TopDownContext<'p, 's, T, T::Output> {
+  pub fn new(session: &'s mut Session<'p, T, T::Output>) -> Self { Self { session } }
 
-  pub fn get_dependency_check_errors(&self) -> impl Iterator<Item=&io::Error> {
-    self.dependency_check_errors.iter()
+  pub fn require_initial(&mut self, task: &T) -> T::Output {
+    self.require_task(task)
   }
 }
 
`;
    let target = document.getElementById('diff2html_1');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Here, we use lifetime <code>'s</code> to denote the lifetime of a session, and make <code>TopDownContext</code> generic over it.
<code>new</code> now just accepts a mutable reference to the session.
The <code>get_dependency_check_errors</code> method can be removed.
We add a <code>require_initial</code> convenience method for <code>Session</code>.</p>
<p>In the rest of the file, we need to update the <code>impl</code> lines to include the lifetimes, and we need to replace most instances of <code>self</code> with <code>self.session</code>.
You could do this with the following find-replace regex: <code>self\.([\w\d_]+)\.</code> -&gt; <code>self.session.$1.</code></p>
<p>Change <code>pie/src/context/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_2"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -20,40 +20,40 @@
 }
 
 
-impl<T: Task> Context<T> for TopDownContext<T, T::Output> {
+impl<'p, 's, T: Task> Context<T> for TopDownContext<'p, 's, T, T::Output> {
   fn require_file_with_stamper<P: AsRef<Path>>(&mut self, path: P, stamper: FileStamper) -> Result<Option<File>, io::Error> {
-    let Some(current_executing_task_node) = &self.current_executing_task else {
+    let Some(current_executing_task_node) = &self.session.current_executing_task else {
       return fs::open_if_file(path); // No current executing task, so no dependency needs to be made.
     };
     let path = path.as_ref();
-    let node = self.store.get_or_create_file_node(path);
+    let node = self.session.store.get_or_create_file_node(path);
     let (dependency, file) = FileDependency::new_with_file(path, stamper)?;
-    self.store.add_file_require_dependency(current_executing_task_node, &node, dependency);
+    self.session.store.add_file_require_dependency(current_executing_task_node, &node, dependency);
     Ok(file)
   }
 
   fn require_task_with_stamper(&mut self, task: &T, stamper: OutputStamper) -> T::Output {
-    let node = self.store.get_or_create_task_node(task);
+    let node = self.session.store.get_or_create_task_node(task);
 
     // Get required task output by executing it if needed, or by getting the output from the store if not needed.
     let output = if self.should_execute_task(&node) {
-      self.store.reset_task(&node);
-      let previous_executing_task = self.current_executing_task.replace(node);
+      self.session.store.reset_task(&node);
+      let previous_executing_task = self.session.current_executing_task.replace(node);
       let output = task.execute(self);
-      self.current_executing_task = previous_executing_task;
-      self.store.set_task_output(&node, output.clone());
+      self.session.current_executing_task = previous_executing_task;
+      self.session.store.set_task_output(&node, output.clone());
       output
     } else {
       // Correctness: when ${"`"}should_execute_task${"`"} returns ${"`"}true${"`"}, the above block is executed. Otherwise this block is 
       // executed and ${"`"}should_execute_task${"`"} ensures that the task has an output.
-      self.store.get_task_output(&node).clone()
+      self.session.store.get_task_output(&node).clone()
     };
 
     // Create task require dependency if a task is currently executing (i.e., we are not requiring the initial task).
-    if let Some(current_executing_task_node) = &self.current_executing_task {
+    if let Some(current_executing_task_node) = &self.session.current_executing_task {
       let dependency = TaskDependency::new(task.clone(), stamper, output.clone());
-      if self.store.add_task_require_dependency(current_executing_task_node, &node, dependency).is_err() {
-        let current_executing_task = self.store.get_task(current_executing_task_node);
+      if self.session.store.add_task_require_dependency(current_executing_task_node, &node, dependency).is_err() {
+        let current_executing_task = self.session.store.get_task(current_executing_task_node);
         panic!("Cyclic task dependency; current executing task '{:?}' is requiring task '{:?}' which was already required", current_executing_task, task);
       }
     }
@@ -62,19 +62,19 @@
   }
 }
 
-impl<T: Task> TopDownContext<T, T::Output> {
+impl<'p, 's, T: Task> TopDownContext<'p, 's, T, T::Output> {
   /// Checks whether given task should be executed, returning ${"`"}true${"`"} if it should be executed. A task should be executed
   /// if any of its dependencies are inconsistent, or when it has no output.
   fn should_execute_task(&mut self, node: &TaskNode) -> bool {
     // Borrow: because we pass ${"`"}self${"`"} (which is ${"`"}&mut self${"`"}) to ${"`"}is_inconsistent${"`"} for recursive consistency checking, 
     //         we need to clone and collect dependencies into a ${"`"}Vec${"`"}. Otherwise we have an immutable borrow of ${"`"}self${"`"}
     //         through ${"`"}self.store${"`"} while we create a mutable borrow of ${"`"}self${"`"}, which is not allowed.
-    let dependencies: Vec<_> = self.store.get_dependencies_of_task(node).cloned().collect();
+    let dependencies: Vec<_> = self.session.store.get_dependencies_of_task(node).cloned().collect();
     for dependency in dependencies {
       match dependency.is_inconsistent(self) {
         Ok(Some(_)) => return true,
         Err(e) => { // Error while checking: store error and assume inconsistent
-          self.dependency_check_errors.push(e);
+          self.session.dependency_check_errors.push(e);
           return true;
         }
         _ => {} // Consistent: continue checking
@@ -82,6 +82,6 @@
     }
     // Task has no dependencies or all dependencies are consistent. Should only execute if it has no output, meaning
     // that it has never been executed before.
-    return !self.store.task_has_output(node);
+    return !self.session.store.task_has_output(node);
   }
 }
`;
    let target = document.getElementById('diff2html_2');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Now we change <code>Session</code> to use <code>TopDownContext</code>. </p>
<h2 id="update-session"><a class="header" href="#update-session">Update Session</a></h2>
<p>Change <code>pie/src/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_3"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -95,7 +95,8 @@
 
   /// Requires ${"`"}task${"`"}, returning its up-to-date output.
   pub fn require(&mut self, task: &T) -> T::Output {
-    todo!("Create TopDownContext with this session, and require the task")
+    self.current_executing_task = None;
+    TopDownContext::new(self).require_initial(task)
   }
 
   /// Gets all errors produced during dependency checks.
`;
    let target = document.getElementById('diff2html_3');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We reset the <code>current_executing_task</code> to <code>None</code>, to be sure that we start a build without an executing task.
Then, we just create a <code>TopDownContext</code> and call <code>require_initial</code>.</p>
<p>Finally, we can now make the <code>context</code> module private, as users of the library run builds using <code>Session</code>, instead of having to create a context implementation.
Change <code>pie/src/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_4"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -11,7 +11,7 @@
 
 pub mod stamp;
 pub mod dependency;
-pub mod context;
+mod context;
 mod fs;
 mod store;
 
`;
    let target = document.getElementById('diff2html_4');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Check that the code compiles with <code>cargo check --lib</code>.
This only checks if the library builds, but not any examples.
We need to update the incrementality example to work with these changes.</p>
<h2 id="update-incremental-example"><a class="header" href="#update-incremental-example">Update incremental example</a></h2>
<p>Change <code>pie/examples/incremental.rs</code> to use sessions:</p>
<div class="diff2html" id="diff2html_5"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/examples/incremental.rs
+++ pie/examples/incremental.rs
@@ -1,11 +1,8 @@
-#![allow(unused_imports, unused_variables)]
-
 use std::io::{self, Read};
 use std::path::{Path, PathBuf};
 
 use dev_shared::{create_temp_dir, write_until_modified};
-use pie::{Context, Task};
-use pie::context::top_down::TopDownContext;
+use pie::{Context, Pie, Task};
 use pie::stamp::FileStamper;
 
 /// Task that reads a string from a file.
@@ -38,24 +35,24 @@
   let input_file = temp_dir.path().join("input.txt");
   write_until_modified(&input_file, "Hi")?;
 
-  let mut context = TopDownContext::new();
+  let mut pie = Pie::default();
   let read_task = ReadStringFromFile::new(&input_file, FileStamper::Modified);
 
   println!("A) New task: expect ${"`"}read_task${"`"} to execute");
   // ${"`"}read_task${"`"} is new, meaning that we have no cached output for it, thus it must be executed.
-  let output = context.require_task(&read_task)?;
+  let output = pie.new_session().require(&read_task)?;
   assert_eq!(&output, "Hi");
 
   println!("\nB) Reuse: expect no execution");
   // ${"`"}read_task${"`"} is not new and its file dependency is still consistent. It is consistent because the modified time of 
   // ${"`"}input_file${"`"} has not changed, thus the modified stamp is equal.
-  let output = context.require_task(&read_task)?;
+  let output = pie.new_session().require(&read_task)?;
   assert_eq!(&output, "Hi");
 
   write_until_modified(&input_file, "Hello")?;
   println!("\nC) Inconsistent file dependency: expect ${"`"}read_task${"`"} to execute");
   // The file dependency of ${"`"}read_task${"`"} is inconsistent due to the changed modified time of ${"`"}input_file${"`"}.
-  let output = context.require_task(&read_task)?;
+  let output = pie.new_session().require(&read_task)?;
   assert_eq!(&output, "Hello");
 
   let input_file_b = temp_dir.path().join("input_b.txt");
@@ -66,9 +63,10 @@
   // Task ${"`"}read_task${"`"}, ${"`"}read_task_b_modified${"`"} and ${"`"}read_task_b_exists${"`"} are different, due to their ${"`"}Eq${"`"} implementation 
   // determining that their paths and stampers are different. Therefore, ${"`"}read_task_b_modified${"`"} and ${"`"}read_task_b_exists${"`"}
   // are new tasks, and must be executed.
-  let output = context.require_task(&read_task_b_modified)?;
+  let mut session = pie.new_session();
+  let output = session.require(&read_task_b_modified)?;
   assert_eq!(&output, "Test");
-  let output = context.require_task(&read_task_b_exists)?;
+  let output = session.require(&read_task_b_exists)?;
   assert_eq!(&output, "Test");
 
   write_until_modified(&input_file_b, "Test Test")?;
@@ -80,9 +78,10 @@
   //
   // Note that using an ${"`"}Exists${"`"} stamper for this task does not make a lot of sense, since it will only read the file 
   // on first execute and when it is recreated. But this is just to demonstrate different stampers.
-  let output = context.require_task(&read_task_b_modified)?;
+  let mut session = pie.new_session();
+  let output = session.require(&read_task_b_modified)?;
   assert_eq!(&output, "Test Test");
-  let output = context.require_task(&read_task_b_exists)?;
+  let output = session.require(&read_task_b_exists)?;
   assert_eq!(&output, "Test");
 
   Ok(())
`;
    let target = document.getElementById('diff2html_5');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>When we only require one task, we replace <code>context.require_task</code> with <code>pie.new_session().require</code>.
When we want to require multiple tasks, we use <code>new_session</code> and call <code>session.require</code> multiple times.</p>
<p>It is very important to create a new session each time in this example, because a task is only checked/executed once each session.
If we use a single session, our changes are never seen, and we just execute each task once, which is not what we want.
Therefore, every time we make changes to source files, or expect that changes have been made to source files, we must create a new session.</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="3_min_sound/1_session/index.html#admonition-note"></a></p>
</div>
<div>
<p>In changes D and E, Rust is smart enough to allow creating a new session even though the previous <code>session</code> variable is still active, because it knows that we don't use that previous session anymore.</p>
</div>
</div>
<p>Check that the example works with <code>cargo run --example incremental</code>, and check that the rest of the code works by running <code>cargo test</code>.</p>
<h2 id="minimality"><a class="header" href="#minimality">Minimality</a></h2>
<p>Now we can ensure minimality by keeping track whether a task has been required this session.
Change <code>pie/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_6"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -1,3 +1,4 @@
+use std::collections::HashSet;
 use std::fmt::Debug;
 use std::fs::File;
 use std::hash::Hash;
@@ -81,6 +82,7 @@
 pub struct Session<'p, T, O> {
   store: &'p mut Store<T, O>,
   current_executing_task: Option<TaskNode>,
+  consistent: HashSet<TaskNode>,
   dependency_check_errors: Vec<io::Error>,
 }
 
@@ -89,6 +91,7 @@
     Self {
       store: &mut pie.store,
       current_executing_task: None,
+      consistent: HashSet::default(),
       dependency_check_errors: Vec::default(),
     }
   }
`;
    let target = document.getElementById('diff2html_6');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We add the <code>consistent</code> field to <code>Session</code> which is a hash set over task nodes.
We create a new one each session, because we only want to keep track of which tasks are consistent on a per-session basis.</p>
<p>Now change the top-down context in <code>pie/context/top_down.rs</code> to use this:</p>
<div class="diff2html" id="diff2html_7"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -36,7 +36,8 @@
     let node = self.session.store.get_or_create_task_node(task);
 
     // Get required task output by executing it if needed, or by getting the output from the store if not needed.
-    let output = if self.should_execute_task(&node) {
+    let already_consistent = self.session.consistent.contains(&node);
+    let output = if !already_consistent && self.should_execute_task(&node) {
       self.session.store.reset_task(&node);
       let previous_executing_task = self.session.current_executing_task.replace(node);
       let output = task.execute(self);
@@ -58,6 +59,7 @@
       }
     }
 
+    self.session.consistent.insert(node);
     output
   }
 }
`;
    let target = document.getElementById('diff2html_7');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>At the start of requiring a task, we check whether the task is already deemed consistent this session, using the <code>consistent</code> hash set in <code>Session</code>.
If the task is consistent, we skip execution by using <code>!already_consistent &amp;&amp;</code> in the if check.
Because <code>&amp;&amp;</code> is <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#lazy-boolean-operators">short-circuiting (also called lazy)</a>, we even skip the entire <code>should_execute</code> call that checks whether we should execute a task, when the task is already consistent.
This increases performance when a lot of consistent tasks are required.</p>
<p>Finally, at the end of <code>require</code>, we insert the task node into the <code>consistent</code> hash set, to denote that the task is now consistent this session.
That's it! This was a simple change due to the work we did before to get the <code>Session</code> API in place.</p>
<p>With this new API in place, minimality of task checking and execution in place, and all code adjusted to work with it, we can continue with tracking build events.</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="3_min_sound/1_session/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="3_min_sound/1_session/../../gen/3_min_sound/1_session/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracking-build-events"><a class="header" href="#tracking-build-events">Tracking Build Events</a></h1>
<p>So far we have had no convenient way to inspect what our build system is doing, apart from <code>println!</code> debugging or attaching a debugger to the program.
In this section, we will change that by tracking build events for debugging and integration testing purposes.</p>
<p>We will:</p>
<ol>
<li>Create a <code>Tracker</code> trait that receives build events through method calls. The <code>Tracker</code> trait can be implemented in different ways to handle build events in different ways.</li>
<li>Implement a <code>NoopTracker</code> that does nothing, removing the tracking overhead.</li>
<li>Make the build system generic over <code>Tracker</code>, such that <code>Context</code> implementations call methods on the tracker to create build events.</li>
<li>Implement a <code>WritingTracker</code> that writes build events to standard output or standard error, for debugging purposes.</li>
<li>Implement an <code>EventTracker</code> that stores build events for later inspection, for integration testing purposes.</li>
<li>Implement a <code>CompositeTracker</code> that forwards build events to 2 other trackers, so we can use multiple trackers at the same time.</li>
</ol>
<h2 id="tracker-trait"><a class="header" href="#tracker-trait"><code>Tracker</code> trait</a></h2>
<p>Add the <code>tracker</code> module to <code>pie/src/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_0"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -12,6 +12,7 @@
 
 pub mod stamp;
 pub mod dependency;
+pub mod tracker;
 mod context;
 mod fs;
 mod store;
`;
    let target = document.getElementById('diff2html_0');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Then create the <code>pie/src/tracker</code> directory, create the <code>pie/src/tracker/mod.rs</code> file, and add the following content:</p>
<pre><code class="language-rust ">use std::io;

use crate::dependency::{Dependency, FileDependency, Inconsistency, TaskDependency};
use crate::stamp::OutputStamper;
use crate::Task;

/// Trait for tracking build events. Can be used to implement logging, event tracing, progress tracking, metrics, etc.
#[allow(unused_variables)]
pub trait Tracker&lt;T: Task&gt; {
  /// Start: a new build.
  fn build_start(&amp;mut self) {}
  /// End: completed build.
  fn build_end(&amp;mut self) {}

  /// End: created a file `dependency`.
  fn require_file_end(&amp;mut self, dependency: &amp;FileDependency) {}
  /// Start: require `task` using `stamper`.
  fn require_task_start(&amp;mut self, task: &amp;T, stamper: &amp;OutputStamper) {}
  /// End: required a task, resulting in a task `dependency` and `output`, and the task `was_executed`.
  fn require_task_end(&amp;mut self, dependency: &amp;TaskDependency&lt;T, T::Output&gt;, output: &amp;T::Output, was_executed: bool) {}

  /// Start: check consistency of `dependency`. 
  fn check_dependency_start(&amp;mut self, dependency: &amp;Dependency&lt;T, T::Output&gt;) {}
  /// End: checked consistency of `dependency`, possibly found `inconsistency`.
  fn check_dependency_end(
    &amp;mut self,
    dependency: &amp;Dependency&lt;T, T::Output&gt;,
    inconsistency: Result&lt;Option&lt;&amp;Inconsistency&lt;T::Output&gt;&gt;, &amp;io::Error&gt;
  ) {}

  /// Start: execute `task`.
  fn execute_start(&amp;mut self, task: &amp;T) {}
  /// End: executed `task` resulting in `output`.
  fn execute_end(&amp;mut self, task: &amp;T, output: &amp;T::Output) {}
}</code></pre>
<p>The <code>Tracker</code> trait is generic over <code>Task</code>.</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="3_min_sound/2_tracker/index.html#admonition-note"></a></p>
</div>
<div>
<p>Here, we chose to put the <code>Task</code> constraint on the trait itself.
This will not lead to cascading constraints, as the <code>Tracker</code> trait will only be used as a constraint in <code>impl</code>s, not in structs or other traits.</p>
</div>
</div>
<p><code>Tracker</code> has methods corresponding to events that happen during a build, such as a build starting, requiring a file, requiring a task, checking a dependency, and executing a task.
All but the <code>require_file</code> event have start and end variants to give trackers control over nesting these kind of events. 
Then end variants usually have more parameters as more info is available when something is has finished.</p>
<p>Tracker methods accept <code>&amp;mut self</code> so that tracker implementations can perform mutation, such as storing a build event.
We provide default methods that do nothing so that implementors of <code>Tracker</code> only have to override the methods for events they are interested in.
We use <code>#[allow(unused_variables)]</code> on the trait to not give warnings for unused variables, as all variables are unused due to the empty default implementations.</p>
<details id="admonition-references-in-result-and-option" class="admonition info">
<summary class="admonition-title">
<p>References in Result and Option</p>
<p><a class="admonition-anchor-link" href="3_min_sound/2_tracker/index.html#admonition-references-in-result-and-option"></a></p>
</summary>
<div>
<p>The <code>check_dependency_end</code> method accepts the inconsistency as <code>Result&lt;Option&lt;&amp;Inconsistency&lt;T::Output&gt;&gt;, &amp;io::Error&gt;</code>.
The reason we accept it like this is that many methods in <code>Result</code> and <code>Option</code> take <code>self</code>, not <code>&amp;self</code>, and therefore cannot be called on <code>&amp;Result&lt;T, E&gt;</code> and <code>&amp;Option&lt;T&gt;</code>.</p>
<p>We can turn <code>&amp;Result&lt;T, E&gt;</code> into <code>Result&lt;&amp;T, &amp;E&gt;</code> with <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.as_ref"><code>as_ref</code></a> (same for <code>Option</code>).
Since trackers always want to work with <code>Result&lt;&amp;T, &amp;E&gt;</code>, it makes more sense for the caller of the tracker method to call <code>as_ref</code> to turn their result into <code>Result&lt;&amp;T, &amp;E&gt;</code>.</p>
<p>The final reason to accept <code>Result&lt;&amp;T, &amp;E&gt;</code> is that if you have a <code>&amp;T</code> or <code>&amp;E</code>, you can easily construct a <code>Result&lt;&amp;T, &amp;E&gt;</code> with <code>Ok(&amp;t)</code> and <code>Err(&amp;e)</code>.
However, you <em>cannot</em> construct a <code>&amp;Result&lt;T, E&gt;</code> from <code>&amp;T</code> or <code>&amp;E</code>, so <code>Result&lt;&amp;T, &amp;E&gt;</code> is a more flexible type.</p>
</div>
</details>
<details id="admonition-default-methods" class="admonition info">
<summary class="admonition-title">
<p>Default methods</p>
<p><a class="admonition-anchor-link" href="3_min_sound/2_tracker/index.html#admonition-default-methods"></a></p>
</summary>
<div>
<p>Adding a method to <code>Tracker</code> with a default implementation ensures that implementations of <code>Tracker</code> do not have to be changed to work with the new method.
This is both good and bad.
Good because we can add methods without breaking compatibility.
Bad because we can forget to handle a new method, which can lead to problems with for example a composite tracker that forwards events to 2 trackers.
In this tutorial we chose the convenient option, but be sure to think about these kind of tradeoffs yourself!</p>
</div>
</details>
<p>Check that the code compiles with <code>cargo test</code>.</p>
<h2 id="no-op-tracker"><a class="header" href="#no-op-tracker">No-op tracker</a></h2>
<p>Add a no-op tracker, which is a tracker that does nothing, by adding the following code to <code>pie/src/tracker/mod.rs</code>:</p>
<pre><code class="language-rust ">/// [`Tracker`] that does nothing.
#[derive(Copy, Clone, Debug)]
pub struct NoopTracker;
impl&lt;T: Task&gt; Tracker&lt;T&gt; for NoopTracker {}</code></pre>
<p>Due to the default methods that do nothing on <code>Tracker</code>, this implementation is extremely simple. </p>
<details id="admonition-removing-tracker-overhead" class="admonition info">
<summary class="admonition-title">
<p>Removing tracker overhead</p>
<p><a class="admonition-anchor-link" href="3_min_sound/2_tracker/index.html#admonition-removing-tracker-overhead"></a></p>
</summary>
<div>
<p>We will use generics to select which tracker implementation to use.
Therefore, all calls to trackers are statically dispatched, and could be inlined.
Because <code>NoopTracker</code> only has empty methods, and those empty methods can be inlined, using <code>NoopTracker</code> will effectively remove all tracking code from your binary, thus removing the overhead of tracking if you don't want it.</p>
<p>In this tutorial, we do not annotate methods with <a href="https://nnethercote.github.io/perf-book/inlining.html"><code>#[inline]</code></a>, meaning that the Rust compiler (and the LLVM backend) will make its own decisions on what to make inlineable and what not.
If you care about performance here, be sure to annotate those default empty methods with <code>#[inline]</code>.</p>
</div>
</details>
<h2 id="using-the-tracker-trait"><a class="header" href="#using-the-tracker-trait">Using the <code>Tracker</code> trait</a></h2>
<p>Now we will make the build system generic over <code>Tracker</code>, and insert <code>Tracker</code> calls in context implementations.</p>
<p>Make <code>Pie</code> and <code>Session</code> generic over <code>Tracker</code> by modifying <code>pie/src/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_1"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -9,6 +9,7 @@
 
 use crate::context::top_down::TopDownContext;
 use crate::store::{Store, TaskNode};
+use crate::tracker::{NoopTracker, Tracker};
 
 pub mod stamp;
 pub mod dependency;
@@ -61,36 +62,47 @@
 }
 
 /// Main entry point into PIE, a sound and incremental programmatic build system.
-pub struct Pie<T, O> {
+pub struct Pie<T, O, A = NoopTracker> {
   store: Store<T, O>,
+  tracker: A,
 }
 
 impl<T: Task> Default for Pie<T, T::Output> {
-  fn default() -> Self { Self { store: Store::default() } }
+  fn default() -> Self { Self::with_tracker(NoopTracker) }
 }
 
-impl<T: Task> Pie<T, T::Output> {
+impl<T: Task, A: Tracker<T>> Pie<T, T::Output, A> {
+  /// Creates a new [${"`"}Pie${"`"}] instance with given ${"`"}tracker${"`"}.
+  pub fn with_tracker(tracker: A) -> Self { Self { store: Store::default(), tracker } }
+  
   /// Creates a new build session. Only one session may be active at once, enforced via mutable (exclusive) borrow.
-  pub fn new_session(&mut self) -> Session<T, T::Output> { Session::new(self) }
+  pub fn new_session(&mut self) -> Session<T, T::Output, A> { Session::new(self) }
   /// Runs ${"`"}f${"`"} inside a new build session.
-  pub fn run_in_session<R>(&mut self, f: impl FnOnce(Session<T, T::Output>) -> R) -> R {
+  pub fn run_in_session<R>(&mut self, f: impl FnOnce(Session<T, T::Output, A>) -> R) -> R {
     let session = self.new_session();
     f(session)
   }
+
+  /// Gets the [${"`"}Tracker${"`"}] instance.
+  pub fn tracker(&self) -> &A { &self.tracker }
+  /// Gets the mutable [${"`"}Tracker${"`"}] instance.
+  pub fn tracker_mut(&mut self) -> &mut A { &mut self.tracker }
 }
 
 /// A session in which builds are executed.
-pub struct Session<'p, T, O> {
+pub struct Session<'p, T, O, A> {
   store: &'p mut Store<T, O>,
+  tracker: &'p mut A,
   current_executing_task: Option<TaskNode>,
   consistent: HashSet<TaskNode>,
   dependency_check_errors: Vec<io::Error>,
 }
 
-impl<'p, T: Task> Session<'p, T, T::Output> {
-  fn new(pie: &'p mut Pie<T, T::Output>) -> Self {
+impl<'p, T: Task, A: Tracker<T>> Session<'p, T, T::Output, A> {
+  fn new(pie: &'p mut Pie<T, T::Output, A>) -> Self {
     Self {
       store: &mut pie.store,
+      tracker: &mut pie.tracker,
       current_executing_task: None,
       consistent: HashSet::default(),
       dependency_check_errors: Vec::default(),
@@ -103,6 +115,11 @@
     TopDownContext::new(self).require_initial(task)
   }
 
+  /// Gets the [${"`"}Tracker${"`"}] instance.
+  pub fn tracker(&self) -> &A { &self.tracker }
+  /// Gets the mutable [${"`"}Tracker${"`"}] instance.
+  pub fn tracker_mut(&mut self) -> &mut A { &mut self.tracker }
+
   /// Gets all errors produced during dependency checks.
   pub fn dependency_check_errors(&self) -> &[io::Error] { &self.dependency_check_errors }
 }
`;
    let target = document.getElementById('diff2html_1');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We use <code>A</code> as the generic argument for tracker types in the source code.
The <code>Pie</code> struct owns the tracker, similarly to how it owns the store.
<code>Pie</code> can be created with a specific tracker with <code>with_tracker</code>, and provides access to the tracker with <code>tracker</code> and <code>tracker_mut</code>.</p>
<details id="admonition-default-type" class="admonition info">
<summary class="admonition-title">
<p>Default type</p>
<p><a class="admonition-anchor-link" href="3_min_sound/2_tracker/index.html#admonition-default-type"></a></p>
</summary>
<div>
<p>We assign <code>NoopTracker</code> as the default type for trackers in <code>Pie</code>, so that no tracking is performed when we use the <code>Pie</code> type without an explicit tracker type.
The <code>Default</code> implementation only works with <code>NoopTracker</code>, because we <code>impl Default for Pie&lt;T, T::Output&gt;</code>, which is equivalent to <code>impl Default for Pie&lt;T, T::Output, NoopTracker&gt;</code> due to the default type.</p>
</div>
</details>
<p>We make <code>Session</code> generic over trackers, and mutibly borrow the tracker from <code>Pie</code>, again like we do with the store.
For convenience, <code>Session</code> also provides access to the tracker with <code>tracker</code> and <code>tracker_mut</code>.</p>
<p>Now we make <code>TopDownContext</code> generic over <code>Tracker</code>, and insert calls to tracker methods.
Modify <code>pie/src/context/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_2"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -6,21 +6,25 @@
 use crate::dependency::{FileDependency, TaskDependency};
 use crate::stamp::{FileStamper, OutputStamper};
 use crate::store::TaskNode;
+use crate::tracker::Tracker;
 
-pub struct TopDownContext<'p, 's, T, O> {
-  session: &'s mut Session<'p, T, O>,
+pub struct TopDownContext<'p, 's, T, O, A> {
+  session: &'s mut Session<'p, T, O, A>,
 }
 
-impl<'p, 's, T: Task> TopDownContext<'p, 's, T, T::Output> {
-  pub fn new(session: &'s mut Session<'p, T, T::Output>) -> Self { Self { session } }
+impl<'p, 's, T: Task, A: Tracker<T>> TopDownContext<'p, 's, T, T::Output, A> {
+  pub fn new(session: &'s mut Session<'p, T, T::Output, A>) -> Self { Self { session } }
 
   pub fn require_initial(&mut self, task: &T) -> T::Output {
-    self.require_task(task)
+    self.session.tracker.build_start();
+    let output = self.require_task(task);
+    self.session.tracker.build_end();
+    output
   }
 }
 
 
-impl<'p, 's, T: Task> Context<T> for TopDownContext<'p, 's, T, T::Output> {
+impl<'p, 's, T: Task, A: Tracker<T>> Context<T> for TopDownContext<'p, 's, T, T::Output, A> {
   fn require_file_with_stamper<P: AsRef<Path>>(&mut self, path: P, stamper: FileStamper) -> Result<Option<File>, io::Error> {
     let Some(current_executing_task_node) = &self.session.current_executing_task else {
       return fs::open_if_file(path); // No current executing task, so no dependency needs to be made.
@@ -28,31 +32,38 @@
     let path = path.as_ref();
     let node = self.session.store.get_or_create_file_node(path);
     let (dependency, file) = FileDependency::new_with_file(path, stamper)?;
+    self.session.tracker.require_file_end(&dependency);
     self.session.store.add_file_require_dependency(current_executing_task_node, &node, dependency);
     Ok(file)
   }
 
   fn require_task_with_stamper(&mut self, task: &T, stamper: OutputStamper) -> T::Output {
+    self.session.tracker.require_task_start(task, &stamper);
     let node = self.session.store.get_or_create_task_node(task);
 
     // Get required task output by executing it if needed, or by getting the output from the store if not needed.
     let already_consistent = self.session.consistent.contains(&node);
-    let output = if !already_consistent && self.should_execute_task(&node) {
+    let should_execute = !already_consistent && self.should_execute_task(&node);
+    let output = if should_execute {
+      self.session.tracker.execute_start(task);
       self.session.store.reset_task(&node);
       let previous_executing_task = self.session.current_executing_task.replace(node);
       let output = task.execute(self);
       self.session.current_executing_task = previous_executing_task;
       self.session.store.set_task_output(&node, output.clone());
+      self.session.tracker.execute_end(task, &output);
       output
     } else {
-      // Correctness: when ${"`"}should_execute_task${"`"} returns ${"`"}true${"`"}, the above block is executed. Otherwise this block is 
+      // Correctness: when ${"`"}should_execute_task${"`"} returns ${"`"}true${"`"}, the above block is executed. Otherwise this block is
       // executed and ${"`"}should_execute_task${"`"} ensures that the task has an output.
       self.session.store.get_task_output(&node).clone()
     };
 
+    let dependency = TaskDependency::new(task.clone(), stamper, output.clone());
+    self.session.tracker.require_task_end(&dependency, &output, should_execute);
+
     // Create task require dependency if a task is currently executing (i.e., we are not requiring the initial task).
     if let Some(current_executing_task_node) = &self.session.current_executing_task {
-      let dependency = TaskDependency::new(task.clone(), stamper, output.clone());
       if self.session.store.add_task_require_dependency(current_executing_task_node, &node, dependency).is_err() {
         let current_executing_task = self.session.store.get_task(current_executing_task_node);
         panic!("Cyclic task dependency; current executing task '{:?}' is requiring task '{:?}' which was already required", current_executing_task, task);
@@ -64,16 +75,19 @@
   }
 }
 
-impl<'p, 's, T: Task> TopDownContext<'p, 's, T, T::Output> {
+impl<'p, 's, T: Task, A: Tracker<T>> TopDownContext<'p, 's, T, T::Output, A> {
   /// Checks whether given task should be executed, returning ${"`"}true${"`"} if it should be executed. A task should be executed
   /// if any of its dependencies are inconsistent, or when it has no output.
   fn should_execute_task(&mut self, node: &TaskNode) -> bool {
-    // Borrow: because we pass ${"`"}self${"`"} (which is ${"`"}&mut self${"`"}) to ${"`"}is_inconsistent${"`"} for recursive consistency checking, 
+    // Borrow: because we pass ${"`"}self${"`"} (which is ${"`"}&mut self${"`"}) to ${"`"}is_inconsistent${"`"} for recursive consistency checking,
     //         we need to clone and collect dependencies into a ${"`"}Vec${"`"}. Otherwise we have an immutable borrow of ${"`"}self${"`"}
     //         through ${"`"}self.store${"`"} while we create a mutable borrow of ${"`"}self${"`"}, which is not allowed.
     let dependencies: Vec<_> = self.session.store.get_dependencies_of_task(node).cloned().collect();
     for dependency in dependencies {
-      match dependency.is_inconsistent(self) {
+      self.session.tracker.check_dependency_start(&dependency);
+      let inconsistency = dependency.is_inconsistent(self);
+      self.session.tracker.check_dependency_end(&dependency, inconsistency.as_ref().map(|o| o.as_ref()));
+      match inconsistency {
         Ok(Some(_)) => return true,
         Err(e) => { // Error while checking: store error and assume inconsistent
           self.session.dependency_check_errors.push(e);
`;
    let target = document.getElementById('diff2html_2');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We make <code>TopDownContext</code> generic over trackers, and call methods on the tracker:</p>
<ul>
<li>In <code>require_initial</code> we call <code>build_start</code>/<code>build_end</code> to track builds.</li>
<li>In <code>require_file_with_stamper</code> we call <code>require_file_end</code> to track file dependencies.</li>
<li>In <code>require_file_with_stamper</code> we call <code>require_task_start</code>/<code>require_task_end</code> to track task dependencies. 
<ul>
<li>We extract <code>should_execute</code> into a variable, and pull <code>dependency</code> out of the <code>if</code>, so that we can pass them to <code>tracker.required_task</code>.</li>
<li>We also call <code>execute_start</code>/<code>execute_end</code> to track execution.</li>
</ul>
</li>
<li>In <code>should_execute_task</code> we call <code>check_dependency_start</code>/<code>check_dependency_end</code> to track dependency checking.
<ul>
<li>We extract <code>inconsistency</code> into a variable, and convert it into the right type for <code>check_dependency_end</code>.</li>
</ul>
</li>
</ul>
<p>Check that the code compiles with <code>cargo test</code>.
Existing code should keep working due to the <code>NoopTracker</code> default type in <code>Pie</code>.</p>
<p>We won't modify <code>NonIncrementalContext</code> to use a tracker, as <code>NonIncrementalContext</code> has no state, so we cannot pass a tracker to it.</p>
<h2 id="implement-writing-tracker"><a class="header" href="#implement-writing-tracker">Implement writing tracker</a></h2>
<p>Now we can implement some interesting trackers.
We start with a simple <code>WritingTracker</code> that writes build events to some writer.</p>
<p>Add the <code>writing</code> module to <code>pie/src/tracker/mod.rs</code>:</p>
<div class="diff2html" id="diff2html_3"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/tracker/mod.rs
+++ pie/src/tracker/mod.rs
@@ -4,6 +4,8 @@
 use crate::stamp::OutputStamper;
 use crate::Task;
 
+pub mod writing;
+
 /// Trait for tracking build events. Can be used to implement logging, event tracing, progress tracking, metrics, etc.
 #[allow(unused_variables)]
 pub trait Tracker<T: Task> {
`;
    let target = document.getElementById('diff2html_3');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Then create the <code>pie/src/tracker/writing.rs</code> file and add:</p>
<pre><code class="language-rust ">use std::io::{self, BufWriter, Stderr, Stdout, Write};

use crate::dependency::{Dependency, FileDependency, Inconsistency, TaskDependency};
use crate::stamp::OutputStamper;
use crate::Task;
use crate::tracker::Tracker;

/// [`Tracker`] that writes events to a [`Write`] instance, for example [`Stdout`].
#[derive(Clone, Debug)]
pub struct WritingTracker&lt;W&gt; {
  writer: W,
  indentation: u32,
}

impl WritingTracker&lt;BufWriter&lt;Stdout&gt;&gt; {
  /// Creates a [`WritingTracker`] that writes to buffered standard output.
  pub fn with_stdout() -&gt; Self { Self::new(BufWriter::new(io::stdout())) }
}
impl WritingTracker&lt;BufWriter&lt;Stderr&gt;&gt; {
  /// Creates a [`WritingTracker`] that writes to buffered standard error.
  pub fn with_stderr() -&gt; Self { Self::new(BufWriter::new(io::stderr())) }
}
impl&lt;W: Write&gt; WritingTracker&lt;W&gt; {
  /// Creates a [`WritingTracker`] that writes to `writer`.
  pub fn new(writer: W) -&gt; Self {
    Self {
      writer,
      indentation: 0,
    }
  }
}</code></pre>
<p>The <code>WritingTracker</code> is generic over a writer <code>W</code> that must implement <code>Write</code>, which is a standard trait for writing bytes to something.
<code>with_stdout</code> and <code>with_stderr</code> can be used to create buffered writers to standard output and standard error.
<code>new</code> can be used to create a writer to anything that implements <code>Write</code>, such as a <code>File</code>.</p>
<p>Add some utility functions for <code>WritingTracker</code> to <code>pie/src/tracker/writing.rs</code>: </p>
<pre><code class="language-rust ">#[allow(dead_code)]
impl&lt;W: Write&gt; WritingTracker&lt;W&gt; {
  fn writeln(&amp;mut self, args: std::fmt::Arguments) {
    self.write_indentation();
    let _ = writeln!(&amp;mut self.writer, &quot;{}&quot;, args);
  }
  fn write(&amp;mut self, args: std::fmt::Arguments) {
    let _ = write!(&amp;mut self.writer, &quot;{}&quot;, args);
  }
  fn write_nl(&amp;mut self) {
    let _ = write!(&amp;mut self.writer, &quot;\n&quot;);
  }

  fn indent(&amp;mut self) {
    self.indentation = self.indentation.saturating_add(1);
  }
  fn unindent(&amp;mut self) {
    self.indentation = self.indentation.saturating_sub(1);
  }
  fn write_indentation(&amp;mut self) {
    for _ in 0..self.indentation {
      let _ = write!(&amp;mut self.writer, &quot; &quot;);
    }
  }

  fn flush(&amp;mut self) {
    let _ = self.writer.flush();
  }
}</code></pre>
<p><code>writeln</code> and <code>write</code> will mainly be used for writing text.
The text to write is passed into these methods using <code>std::fmt::Arguments</code> for flexibility, accepting the result of <code>format_args!</code>.
<code>WritingTracker</code> keeps track of <code>indentation</code> to show recursive dependency checking and execution, which is controlled with <code>indent</code> and <code>unindent</code>.
Since we are usually writing to buffers, we must <code>flush</code> them to observe the output.</p>
<details id="admonition-failing-writes" class="admonition info">
<summary class="admonition-title">
<p>Failing writes</p>
<p><a class="admonition-anchor-link" href="3_min_sound/2_tracker/index.html#admonition-failing-writes"></a></p>
</summary>
<div>
<p>Writes can fail, but we silently ignore them in this tutorial (with <code>let _ = ...</code>) for simplicity.
You could panic when writing fails, but panicking when writing to standard output fails is probably going a bit too far.
You could store the latest write error and give access to it, which at least allows users of <code>WritingTracker</code> check for some errors.</p>
<p>In general, tracking events can fail, but the current <code>Tracker</code> API does not allow for propagating these errors with <code>Result</code>.
This in turn because <code>TopDownContext</code> does not return <code>Result</code> for <code>require_task</code> due to the trade-offs discussed in the section on <code>TopDownContext</code>.</p>
</div>
</details>
<details id="admonition-saturating-arithmetic" class="admonition info">
<summary class="admonition-title">
<p>Saturating arithmetic</p>
<p><a class="admonition-anchor-link" href="3_min_sound/2_tracker/index.html#admonition-saturating-arithmetic"></a></p>
</summary>
<div>
<p>We use <code>saturating_add</code> and <code>saturating_sub</code> for safety, which are saturating arithmetic operations that saturate at the numeric bounds instead of overflowing.
For example, <code>0u32.saturating_sub(1)</code> will result in <code>0</code> instead of overflowing into <code>4294967295</code>.</p>
<p>These saturating operations are not really needed when calls to <code>indent</code> and <code>unindent</code> are balanced.
However, if we make a mistake, it is better to write no indentation than to write 4294967295 spaces of indentation.</p>
<p>Alternatively, we could use standard arithmetic operations, which panic on overflow in debug/development mode, but silently overflow in release mode.</p>
</div>
</details>
<p>Now we can implement the tracker using these utility methods.
Add the <code>Tracker</code> implementation to <code>pie/src/tracker/writing.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;W: Write, T: Task&gt; Tracker&lt;T&gt; for WritingTracker&lt;W&gt; {
  fn build_start(&amp;mut self) {
    self.indentation = 0;
  }
  fn build_end(&amp;mut self) {
    self.writeln(format_args!(&quot;🏁&quot;));
    self.flush();
  }

  fn require_file_end(&amp;mut self, dependency: &amp;FileDependency) {
    self.writeln(format_args!(&quot;- {}&quot;, dependency.path().display()));
  }
  fn require_task_start(&amp;mut self, task: &amp;T, _stamper: &amp;OutputStamper) {
    self.writeln(format_args!(&quot;→ {:?}&quot;, task));
    self.indent();
    self.flush();
  }
  fn require_task_end(&amp;mut self, _dependency: &amp;TaskDependency&lt;T, T::Output&gt;, output: &amp;T::Output, _was_executed: bool) {
    self.unindent();
    self.writeln(format_args!(&quot;← {:?}&quot;, output));
    self.flush();
  }

  fn check_dependency_start(&amp;mut self, dependency: &amp;Dependency&lt;T, T::Output&gt;) {
    match dependency {
      Dependency::RequireTask(d) =&gt; {
        self.writeln(format_args!(&quot;? {:?}&quot;, d.task()));
        self.indent();
        self.flush();
      },
      _ =&gt; {},
    }
  }
  fn check_dependency_end(
    &amp;mut self,
    dependency: &amp;Dependency&lt;T, T::Output&gt;,
    inconsistency: Result&lt;Option&lt;&amp;Inconsistency&lt;T::Output&gt;&gt;, &amp;io::Error&gt;
  ) {
    match dependency {
      Dependency::RequireFile(d) =&gt; {
        match inconsistency {
          Err(e) =&gt; self.writeln(format_args!(&quot;✗ {} (err: {:?})&quot;, d.path().display(), e)),
          Ok(Some(Inconsistency::File(s))) =&gt;
            self.writeln(format_args!(&quot;✗ {} (old: {:?} ≠ new: {:?})&quot;, d.path().display(), d.stamp(), s)),
          Ok(None) =&gt; self.writeln(format_args!(&quot;✓ {}&quot;, d.path().display())),
          _ =&gt; {}, // Other variants cannot occur.
        }
      },
      Dependency::RequireTask(d) =&gt; {
        self.unindent();
        match inconsistency {
          Ok(Some(Inconsistency::Task(s))) =&gt;
            self.writeln(format_args!(&quot;✗ {:?} (old: {:?} ≠ new: {:?})&quot;, d.task(), d.stamp(), s)),
          Ok(None) =&gt; self.writeln(format_args!(&quot;✓ {:?}&quot;, d.task())),
          _ =&gt; {}, // Other variants cannot occur.
        }
      }
    }
    self.flush()
  }

  fn execute_start(&amp;mut self, task: &amp;T) {
    self.writeln(format_args!(&quot;▶ {:?}&quot;, task));
    self.indent();
    self.flush();
  }
  fn execute_end(&amp;mut self, _task: &amp;T, output: &amp;T::Output) {
    self.unindent();
    self.writeln(format_args!(&quot;◀ {:?}&quot;, output));
    self.flush();
  }
}</code></pre>
<p>We implement most tracker methods and write what is happening, using some unicode symbols to signify events:</p>
<ul>
<li><code>🏁</code>: end of a build,</li>
<li><code>-</code>: created a file dependency,</li>
<li><code>→</code>: start requiring a task,</li>
<li><code>←</code>: end of requiring a task,</li>
<li><code>?</code>: start checking a task dependency,</li>
<li><code>✓</code>: end of dependency checking, when the dependency is consistent,</li>
<li><code>✗</code>: end of dependency checking, when the dependency is inconsistent,</li>
<li><code>▶</code>: start of task execution,</li>
<li><code>◀</code>: end of task execution.</li>
</ul>
<p>We <code>flush</code> the writer after every event to ensure that bytes are written out.
When a task is required, checked, or executed, we increase indentation to signify the recursive checking/execution.
When a task is done being required, checked, or executed, we decrease the indentation again.
In <code>check_dependency_end</code> we write the old and new stamps if a dependency is inconsistent.</p>
<p>This tracker is very verbose.
You can add configuration booleans to control what should be written, but in this tutorial we will keep it simple like this.</p>
<p>Check that the code compiles with <code>cargo test</code>.</p>
<p>Let's try out our writing tracker in the incrementality example by modifying <code>pie/examples/incremental.rs</code>:</p>
<div class="diff2html" id="diff2html_4"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/examples/incremental.rs
+++ pie/examples/incremental.rs
@@ -4,6 +4,7 @@
 use dev_shared::{create_temp_dir, write_until_modified};
 use pie::{Context, Pie, Task};
 use pie::stamp::FileStamper;
+use pie::tracker::writing::WritingTracker;
 
 /// Task that reads a string from a file.
 #[derive(Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]
@@ -18,7 +19,6 @@
 impl Task for ReadStringFromFile {
   type Output = Result<String, io::ErrorKind>;
   fn execute<C: Context<Self>>(&self, context: &mut C) -> Self::Output {
-    println!("Reading from {} with {:?} stamper", self.0.file_name().unwrap().to_string_lossy(), self.1);
     let file = context.require_file_with_stamper(&self.0, self.1).map_err(|e| e.kind())?;
     if let Some(mut file) = file {
       let mut string = String::new();
@@ -35,7 +35,7 @@
   let input_file = temp_dir.path().join("input.txt");
   write_until_modified(&input_file, "Hi")?;
 
-  let mut pie = Pie::default();
+  let mut pie = Pie::with_tracker(WritingTracker::with_stdout());
   let read_task = ReadStringFromFile::new(&input_file, FileStamper::Modified);
 
   println!("A) New task: expect ${"`"}read_task${"`"} to execute");
`;
    let target = document.getElementById('diff2html_4');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We remove the <code>println!</code> statements from tasks and create <code>Pie</code> with <code>WritingTracker</code>.
Now run the example with <code>cargo run --example incremental</code>, and you should see the writing tracker print to standard output:</p>
<pre><code>   Compiling pie v0.1.0 (/pie)
    Finished dev [unoptimized + debuginfo] target(s) in 0.67s
     Running `/pie/target/debug/examples/incremental`
A) New task: expect `read_task` to execute
→ ReadStringFromFile(&quot;/tmp/.tmpWXechH/input.txt&quot;, Modified)
 ▶ ReadStringFromFile(&quot;/tmp/.tmpWXechH/input.txt&quot;, Modified)
  - /tmp/.tmpWXechH/input.txt
 ◀ Ok(&quot;Hi&quot;)
← Ok(&quot;Hi&quot;)
🏁

B) Reuse: expect no execution
→ ReadStringFromFile(&quot;/tmp/.tmpWXechH/input.txt&quot;, Modified)
 ✓ /tmp/.tmpWXechH/input.txt
← Ok(&quot;Hi&quot;)
🏁

C) Inconsistent file dependency: expect `read_task` to execute
→ ReadStringFromFile(&quot;/tmp/.tmpWXechH/input.txt&quot;, Modified)
 ✗ /tmp/.tmpWXechH/input.txt (old: Modified(Some(SystemTime { tv_sec: 1696430559, tv_nsec: 747593357 })) ≠ new: Modified(Some(SystemTime { tv_sec: 1696430559, tv_nsec: 751593462 })))
 ▶ ReadStringFromFile(&quot;/tmp/.tmpWXechH/input.txt&quot;, Modified)
  - /tmp/.tmpWXechH/input.txt
 ◀ Ok(&quot;Hello&quot;)
← Ok(&quot;Hello&quot;)
🏁

D) Different tasks: expect `read_task_b_modified` and `read_task_b_exists` to execute
→ ReadStringFromFile(&quot;/tmp/.tmpWXechH/input_b.txt&quot;, Modified)
 ▶ ReadStringFromFile(&quot;/tmp/.tmpWXechH/input_b.txt&quot;, Modified)
  - /tmp/.tmpWXechH/input_b.txt
 ◀ Ok(&quot;Test&quot;)
← Ok(&quot;Test&quot;)
🏁
→ ReadStringFromFile(&quot;/tmp/.tmpWXechH/input_b.txt&quot;, Exists)
 ▶ ReadStringFromFile(&quot;/tmp/.tmpWXechH/input_b.txt&quot;, Exists)
  - /tmp/.tmpWXechH/input_b.txt
 ◀ Ok(&quot;Test&quot;)
← Ok(&quot;Test&quot;)
🏁

E) Different stampers: expect only `read_task_b_modified` to execute
→ ReadStringFromFile(&quot;/tmp/.tmpWXechH/input_b.txt&quot;, Modified)
 ✗ /tmp/.tmpWXechH/input_b.txt (old: Modified(Some(SystemTime { tv_sec: 1696430559, tv_nsec: 751593462 })) ≠ new: Modified(Some(SystemTime { tv_sec: 1696430559, tv_nsec: 755593567 })))
 ▶ ReadStringFromFile(&quot;/tmp/.tmpWXechH/input_b.txt&quot;, Modified)
  - /tmp/.tmpWXechH/input_b.txt
 ◀ Ok(&quot;Test Test&quot;)
← Ok(&quot;Test Test&quot;)
🏁
→ ReadStringFromFile(&quot;/tmp/.tmpWXechH/input_b.txt&quot;, Exists)
 ✓ /tmp/.tmpWXechH/input_b.txt
← Ok(&quot;Test&quot;)
🏁
</code></pre>
<h2 id="implement-event-tracker"><a class="header" href="#implement-event-tracker">Implement event tracker</a></h2>
<p>The writing tracker is great for debugging purposes, but we cannot use it to check whether our build system is incremental and sound.
To check incrementality and soundness, we need to be able to check whether a task has executed or not, and check the order of build events.
Therefore, we will implement the <code>EventTracker</code> that stores build events for later inspection.</p>
<p>Add the <code>event</code> module to <code>pie/src/tracker/mod.rs</code>:</p>
<div class="diff2html" id="diff2html_5"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/tracker/mod.rs
+++ pie/src/tracker/mod.rs
@@ -5,6 +5,7 @@
 use crate::Task;
 
 pub mod writing;
+pub mod event;
 
 /// Trait for tracking build events. Can be used to implement logging, event tracing, progress tracking, metrics, etc.
 #[allow(unused_variables)]
`;
    let target = document.getElementById('diff2html_5');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Then create the <code>pie/src/tracker/event.rs</code> file and add:</p>
<pre><code class="language-rust ">use std::ops::RangeInclusive;
use std::path::{Path, PathBuf};

use crate::dependency::{FileDependency, TaskDependency};
use crate::stamp::{FileStamp, FileStamper, OutputStamp, OutputStamper};
use crate::Task;
use crate::tracker::Tracker;

/// [`Tracker`] that stores [events](Event) in a [`Vec`], useful in testing to assert that a context implementation is 
/// incremental and sound.
#[derive(Clone, Debug)]
pub struct EventTracker&lt;T, O&gt; {
  events: Vec&lt;Event&lt;T, O&gt;&gt;,
}

impl&lt;T: Task&gt; Default for EventTracker&lt;T, T::Output&gt; {
  fn default() -&gt; Self { Self { events: Vec::new() } }
}

/// Enumeration of important build events.
#[derive(Clone, Debug)]
pub enum Event&lt;T, O&gt; {
  RequireFileEnd(RequireFileEnd),

  RequireTaskStart(RequireTaskStart&lt;T&gt;),
  RequireTaskEnd(RequireTaskEnd&lt;T, O&gt;),

  ExecuteStart(ExecuteStart&lt;T&gt;),
  ExecuteEnd(ExecuteEnd&lt;T, O&gt;),
}

/// End: required file at `path` using `stamper` to create `stamp`.
#[derive(Clone, Debug)]
pub struct RequireFileEnd {
  pub path: PathBuf,
  pub stamper: FileStamper,
  pub stamp: FileStamp,
  pub index: usize,
}
/// Start: require `task` using `stamper`.
#[derive(Clone, Debug)]
pub struct RequireTaskStart&lt;T&gt; {
  pub task: T,
  pub stamper: OutputStamper,
  pub index: usize,
}
/// End: required `task` resulting in `output`, using `stamper` to create `stamp`, and the task `was_executed`.
#[derive(Clone, Debug)]
pub struct RequireTaskEnd&lt;T, O&gt; {
  pub task: T,
  pub output: O,
  pub stamper: OutputStamper,
  pub stamp: OutputStamp&lt;O&gt;,
  pub was_executed: bool,
  pub index: usize,
}
/// Start: execute `task`.
#[derive(Clone, Debug)]
pub struct ExecuteStart&lt;T&gt; {
  pub task: T,
  pub index: usize,
}
/// End: executed `task`, producing `output`.
#[derive(Clone, Debug)]
pub struct ExecuteEnd&lt;T, O&gt; {
  pub task: T,
  pub output: O,
  pub index: usize,
}</code></pre>
<p>The <code>EventTracker</code> stores build events in a <code>Vec</code>.
The <code>Event</code> enumeration mimics the relevant <code>Tracker</code> methods, but uses structs with all arguments in owned form (for example <code>task: T</code> instead of <code>task: &amp;T</code>) as we want to store these events.
We also store the index of every event, so we can easily check whether an event happened before or after another.</p>
<p>Add the tracker implementation to <code>pie/src/tracker/event.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;T: Task&gt; Tracker&lt;T&gt; for EventTracker&lt;T, T::Output&gt; {
  fn build_start(&amp;mut self) {
    self.events.clear();
  }

  fn require_file_end(&amp;mut self, dependency: &amp;FileDependency) {
    let data = RequireFileEnd {
      path: dependency.path().into(),
      stamper: *dependency.stamper(),
      stamp: *dependency.stamp(),
      index: self.events.len()
    };
    self.events.push(Event::RequireFileEnd(data));
  }
  fn require_task_start(&amp;mut self, task: &amp;T, stamper: &amp;OutputStamper) {
    let data = RequireTaskStart { task: task.clone(), stamper: stamper.clone(), index: self.events.len() };
    self.events.push(Event::RequireTaskStart(data));
  }
  fn require_task_end(&amp;mut self, dependency: &amp;TaskDependency&lt;T, T::Output&gt;, output: &amp;T::Output, was_executed: bool) {
    let data = RequireTaskEnd {
      task: dependency.task().clone(),
      stamper: *dependency.stamper(),
      stamp: dependency.stamp().clone(),
      output: output.clone(),
      was_executed,
      index: self.events.len()
    };
    self.events.push(Event::RequireTaskEnd(data));
  }

  fn execute_start(&amp;mut self, task: &amp;T) {
    let data = ExecuteStart { task: task.clone(), index: self.events.len() };
    self.events.push(Event::ExecuteStart(data));
  }
  fn execute_end(&amp;mut self, task: &amp;T, output: &amp;T::Output) {
    let data = ExecuteEnd { task: task.clone(), output: output.clone(), index: self.events.len() };
    self.events.push(Event::ExecuteEnd(data));
  }
}</code></pre>
<p>We implement the relevant methods from <code>Tracker</code> and store the build events as <code>Event</code> instances in <code>self.events</code>.
When a new build starts, we clear the events.</p>
<p>Now we will add code to inspect the build events.
This is quite a bit of code that we will be using in integration testing to test incrementality and soundness.
We'll add in just two steps to keep the tutorial going, and we will use this code in the next section, but feel free to take some time to inspect the code.</p>
<p>First we add some methods to <code>Event</code> to make finding the right event and getting its data easier for the rest of the code.
Add the following code to <code>pie/src/tracker/event.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;T: Task&gt; Event&lt;T, T::Output&gt; {
  /// Returns `Some(&amp;data)` if this is a [require file end event](Event::RequireFileEnd) for file at `path`, or `None` 
  /// otherwise.
  pub fn match_require_file_end(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Option&lt;&amp;RequireFileEnd&gt; {
    let path = path.as_ref();
    match self {
      Event::RequireFileEnd(data) if data.path == path =&gt; Some(data),
      _ =&gt; None,
    }
  }

  /// Returns `Some(&amp;data)` if this is a [require task start event](Event::RequireTaskStart) for `task`, or `None` 
  /// otherwise.
  pub fn match_require_task_start(&amp;self, task: &amp;T) -&gt; Option&lt;&amp;RequireTaskStart&lt;T&gt;&gt; {
    match self {
      Event::RequireTaskStart(data) if data.task == *task =&gt; Some(data),
      _ =&gt; None,
    }
  }
  /// Returns `Some(&amp;data)` if this is a [require task start event](Event::RequireTaskStart) for `task`, or `None` 
  /// otherwise.
  pub fn match_require_task_end(&amp;self, task: &amp;T) -&gt; Option&lt;&amp;RequireTaskEnd&lt;T, T::Output&gt;&gt; {
    match self {
      Event::RequireTaskEnd(data) if data.task == *task =&gt; Some(data),
      _ =&gt; None,
    }
  }

  /// Returns `true` if this is a task execute [start](Event::ExecuteStart) or [end](Event::ExecuteEnd) event.
  pub fn is_execute(&amp;self) -&gt; bool {
    match self {
      Event::ExecuteStart(_) | Event::ExecuteEnd(_) =&gt; true,
      _ =&gt; false,
    }
  }
  /// Returns `true` if this is an execute [start](Event::ExecuteStart) or [end](Event::ExecuteEnd) event for `task`.
  pub fn is_execute_of(&amp;self, task: &amp;T) -&gt; bool {
    match self {
      Event::ExecuteStart(ExecuteStart { task: t, .. }) |
      Event::ExecuteEnd(ExecuteEnd { task: t, .. }) if t == task =&gt; true,
      _ =&gt; false,
    }
  }
  /// Returns `Some(&amp;data)` if this is a [task execute start event](Event::ExecuteStart) for `task`, or `None` 
  /// otherwise.
  pub fn match_execute_start(&amp;self, task: &amp;T) -&gt; Option&lt;&amp;ExecuteStart&lt;T&gt;&gt; {
    match self {
      Event::ExecuteStart(data) if data.task == *task =&gt; Some(data),
      _ =&gt; None,
    }
  }
  /// Returns `Some(&amp;data)` if this is a [task execute end event](Event::ExecuteStart) for `task`, or `None` otherwise.
  pub fn match_execute_end(&amp;self, task: &amp;T) -&gt; Option&lt;&amp;ExecuteEnd&lt;T, T::Output&gt;&gt; {
    match self {
      Event::ExecuteEnd(data) if data.task == *task =&gt; Some(data),
      _ =&gt; None,
    }
  }
}</code></pre>
<p>These methods check if the current event is a specific kind of event, and return their specific data as <code>Some(data)</code>, or <code>None</code> if it is a different kind of event.</p>
<p>Finally, we add methods to <code>EventTracker</code> for inspecting events.
Add the following code to <code>pie/src/tracker/event.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;T: Task&gt; EventTracker&lt;T, T::Output&gt; {
  /// Returns a slice over all events.
  pub fn slice(&amp;self) -&gt; &amp;[Event&lt;T, T::Output&gt;] {
    &amp;self.events
  }
  /// Returns an iterator over all events.
  pub fn iter(&amp;self) -&gt; impl Iterator&lt;Item=&amp;Event&lt;T, T::Output&gt;&gt; {
    self.events.iter()
  }

  /// Returns `true` if `predicate` returns `true` for any event.
  pub fn any(&amp;self, predicate: impl FnMut(&amp;Event&lt;T, T::Output&gt;) -&gt; bool) -&gt; bool {
    self.iter().any(predicate)
  }
  /// Returns `true` if `predicate` returns `true` for exactly one event.
  pub fn one(&amp;self, predicate: impl FnMut(&amp;&amp;Event&lt;T, T::Output&gt;) -&gt; bool) -&gt; bool {
    self.iter().filter(predicate).count() == 1
  }

  /// Returns `Some(v)` for the first event `e` where `f(e)` returns `Some(v)`, or `None` otherwise.
  pub fn find_map&lt;R&gt;(&amp;self, f: impl FnMut(&amp;Event&lt;T, T::Output&gt;) -&gt; Option&lt;&amp;R&gt;) -&gt; Option&lt;&amp;R&gt; {
    self.iter().find_map(f)
  }


  /// Finds the first [require file end event](Event::RequireFileEnd) for `path` and returns `Some(&amp;data)`, or `None` 
  /// otherwise.
  pub fn first_require_file(&amp;self, path: &amp;PathBuf) -&gt; Option&lt;&amp;RequireFileEnd&gt; {
    self.find_map(|e| e.match_require_file_end(path))
  }
  /// Finds the first [require file end event](Event::RequireFileEnd) for `path` and returns `Some(&amp;index)`, or `None` 
  /// otherwise.
  pub fn first_require_file_index(&amp;self, path: &amp;PathBuf) -&gt; Option&lt;&amp;usize&gt; {
    self.first_require_file(path).map(|d| &amp;d.index)
  }

  /// Finds the first require [start](Event::RequireTaskStart) and [end](Event::RequireTaskEnd) event for `task` and 
  /// returns `Some((&amp;start_data, &amp;end_data))`, or `None` otherwise.
  pub fn first_require_task(&amp;self, task: &amp;T) -&gt; Option&lt;(&amp;RequireTaskStart&lt;T&gt;, &amp;RequireTaskEnd&lt;T, T::Output&gt;)&gt; {
    let start_data = self.find_map(|e| e.match_require_task_start(task));
    let end_data = self.find_map(|e| e.match_require_task_end(task));
    start_data.zip(end_data)
  }
  /// Finds the first require [start](Event::RequireTaskStart) and [end](Event::RequireTaskEnd) event for `task` and 
  /// returns `Some(start_data.index..=end_data.index)`, or `None` otherwise.
  pub fn first_require_task_range(&amp;self, task: &amp;T) -&gt; Option&lt;RangeInclusive&lt;usize&gt;&gt; {
    self.first_require_task(task).map(|(s, e)| s.index..=e.index)
  }

  /// Returns `true` if any task was executed.
  pub fn any_execute(&amp;self) -&gt; bool {
    self.any(|e| e.is_execute())
  }
  /// Returns `true` if `task` was executed.
  pub fn any_execute_of(&amp;self, task: &amp;T) -&gt; bool {
    self.any(|e| e.is_execute_of(task))
  }
  /// Returns `true` if `task` was executed exactly once.
  pub fn one_execute_of(&amp;self, task: &amp;T) -&gt; bool {
    self.one(|e| e.match_execute_start(task).is_some())
  }

  /// Finds the first execute [start](Event::ExecuteStart) and [end](Event::ExecuteEnd) event for `task` and returns 
  /// `Some((&amp;start_data, &amp;end_data))`, or `None` otherwise.
  pub fn first_execute(&amp;self, task: &amp;T) -&gt; Option&lt;(&amp;ExecuteStart&lt;T&gt;, &amp;ExecuteEnd&lt;T, T::Output&gt;)&gt; {
    let start_data = self.find_map(|e| e.match_execute_start(task));
    let end_data = self.find_map(|e| e.match_execute_end(task));
    start_data.zip(end_data)
  }
  /// Finds the first execute [start](Event::ExecuteStart) and [end](Event::ExecuteEnd) event for `task` and returns 
  /// `Some(start_data.index..=end_data.index)`, or `None` otherwise.
  pub fn first_execute_range(&amp;self, task: &amp;T) -&gt; Option&lt;RangeInclusive&lt;usize&gt;&gt; {
    self.first_execute(task).map(|(s, e)| s.index..=e.index)
  }
}</code></pre>
<p>We add several general inspection methods:</p>
<ul>
<li><code>slice</code> and <code>iter</code> provide raw access to all stored <code>Event</code>s,</li>
<li><code>any</code> and <code>one</code> are for checking predicates over all events,</li>
<li><code>find_map</code> for finding the first event given some function, returning the output of that function.</li>
</ul>
<p>Then we add methods for specific kinds of events, following the general methods.
For example, <code>first_require_task</code> finds the first require task start and end events for a task, and return their event data as a tuple.
<code>first_require_task_range</code> finds the same events, but returns their indices as a <code>RangeInclusive&lt;usize&gt;</code>.</p>
<p>Check that the code compiles with <code>cargo test</code>.</p>
<h2 id="implement-composite-tracker"><a class="header" href="#implement-composite-tracker">Implement composite tracker</a></h2>
<p>Currently, we cannot use both <code>EventTracker</code> and <code>WritingTracker</code> at the same time.
We want this so that we can check incrementality and soundness, but also look at standard output for debugging, at the same time.
Therefore, we will implement a <code>CompositeTracker</code> that forwards build events to 2 trackers.</p>
<p>Add the following code to <code>pie/src/tracker/mod.rs</code>:</p>
<pre><code class="language-rust ">/// [`Tracker`] that forwards build events to 2 trackers.
#[derive(Copy, Clone, Debug)]
pub struct CompositeTracker&lt;A1, A2&gt;(pub A1, pub A2);
impl&lt;T: Task, A1: Tracker&lt;T&gt;, A2: Tracker&lt;T&gt;&gt; Tracker&lt;T&gt; for CompositeTracker&lt;A1, A2&gt; {
  fn build_start(&amp;mut self) {
    self.0.build_start();
    self.1.build_start();
  }
  fn build_end(&amp;mut self) {
    self.0.build_end();
    self.1.build_end();
  }

  fn require_file_end(&amp;mut self, dependency: &amp;FileDependency) {
    self.0.require_file_end(dependency);
    self.1.require_file_end(dependency);
  }
  fn require_task_start(&amp;mut self, task: &amp;T, stamper: &amp;OutputStamper) {
    self.0.require_task_start(task, stamper);
    self.1.require_task_start(task, stamper);
  }
  fn require_task_end(&amp;mut self, dependency: &amp;TaskDependency&lt;T, T::Output&gt;, output: &amp;T::Output, was_executed: bool) {
    self.0.require_task_end(dependency, output, was_executed);
    self.1.require_task_end(dependency, output, was_executed);
  }

  fn check_dependency_start(&amp;mut self, dependency: &amp;Dependency&lt;T, T::Output&gt;) {
    self.0.check_dependency_start(dependency);
    self.1.check_dependency_start(dependency);
  }
  fn check_dependency_end(
    &amp;mut self,
    dependency: &amp;Dependency&lt;T, T::Output&gt;,
    inconsistency: Result&lt;Option&lt;&amp;Inconsistency&lt;T::Output&gt;&gt;, &amp;io::Error&gt;
  ) {
    self.0.check_dependency_end(dependency, inconsistency);
    self.1.check_dependency_end(dependency, inconsistency);
  }

  fn execute_start(&amp;mut self, task: &amp;T) {
    self.0.execute_start(task);
    self.1.execute_start(task);
  }
  fn execute_end(&amp;mut self, task: &amp;T, output: &amp;T::Output) {
    self.0.execute_end(task, output);
    self.1.execute_end(task, output);
  }
}</code></pre>
<p><code>CompositeTracker</code> is a tuple struct containing 2 trackers that implements all tracker methods and forwards them to the 2 contained trackers.
Its tuple fields are <code>pub</code> so it can be constructed with <code>CompositeTracker(t1, t2)</code> and the contained trackers can be accessed with <code>c.0</code> and <code>c.1</code>.</p>
<p>Check that the code compiles with <code>cargo test</code>.</p>
<p>Now that the build event tracking infrastructure is in place, we can start integration testing!</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="3_min_sound/2_tracker/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="3_min_sound/2_tracker/../../gen/3_min_sound/2_tracker/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h1>
<h2 id="testing-utilities"><a class="header" href="#testing-utilities">Testing utilities</a></h2>
<p>First we start by adding testing utilities (it never ends, does it?) that will make writing integration tests more convenient.
Unfortunately, we can't use <code>dev_shared</code> for this, as we would need to add a dependency to from <code>dev_shared</code> to <code>pie</code>, resulting in a dependency cycle because <code>pie</code> depends on <code>dev_shared</code>.</p>
<details id="admonition-development-dependency-cycle" class="admonition info">
<summary class="admonition-title">
<p>Development dependency cycle</p>
<p><a class="admonition-anchor-link" href="3_min_sound/3_test/index.html#admonition-development-dependency-cycle"></a></p>
</summary>
<div>
<p>If you would create this cycle, the code would still compile, but there would be 2 different instances of <code>pie</code> at the same time: one with unit testing enabled (<code>#[cfg(test)]</code>), and one without.
Even though these libraries are very similar, they are effectively 2 completely different libraries.
When <code>pie</code> uses code from <code>dev_shared</code> that depends again on <code>pie</code>, then there will be errors about types and traits not matching.</p>
<p>This is <a href="https://github.com/rust-lang/cargo/issues/6765">probably a bug in cargo</a>, or at least undesired behaviour. 
It should allow this cycle and make it work correctly, or disallow it.</p>
</div>
</details>
<p>We will put the utilities in a common file and use that as a module in integration tests.
Create the <code>pie/src/tests</code> directory, create the <code>pie/src/tests/common</code> directory, and create the <code>pie/src/tests/common/mod.rs</code> file.
Add the following code to <code>pie/src/tests/common/mod.rs</code>:</p>
<pre><code class="language-rust ">use std::io::{BufWriter, ErrorKind, Stdout};

use pie::{Context, Pie, Task};
use pie::tracker::CompositeTracker;
use pie::tracker::event::EventTracker;
use pie::tracker::writing::WritingTracker;

/// Testing tracker composed of an [`EventTracker`] for testing and stdout [`WritingTracker`] for debugging.
pub type TestTracker&lt;T&gt; = CompositeTracker&lt;EventTracker&lt;T, &lt;T as Task&gt;::Output&gt;, WritingTracker&lt;BufWriter&lt;Stdout&gt;&gt;&gt;;
pub fn test_tracker&lt;T: Task&gt;() -&gt; TestTracker&lt;T&gt; {
  CompositeTracker(EventTracker::default(), WritingTracker::with_stdout())
}

/// Testing [`Pie`] using [`TestTracker`].
pub type TestPie&lt;T&gt; = Pie&lt;T, &lt;T as Task&gt;::Output, TestTracker&lt;T&gt;&gt;;
pub fn test_pie&lt;T: Task&gt;() -&gt; TestPie&lt;T&gt; {
  TestPie::with_tracker(test_tracker())
}</code></pre>
<p>These are just types and functions to create <code>TestPie</code> instances, which are <code>Pie</code> instances using <code>CompositeTracker&lt;EventTracker, WritingTracker&gt;</code> as tracker, where the writing tracker will write to standard output.</p>
<p>Add the following to <code>pie/src/tests/common/mod.rs</code>:</p>
<pre><code class="language-rust ">/// Testing extensions for [`TestPie`].
pub trait TestPieExt&lt;T: Task&gt; {
  /// Require `task` in a new session, assert that there are no dependency check errors, then runs `test_assert_func`
  /// on the event tracker for test assertion purposes.
  fn require_then_assert(
    &amp;mut self,
    task: &amp;T,
    test_assert_func: impl FnOnce(&amp;EventTracker&lt;T, T::Output&gt;),
  ) -&gt; T::Output;

  /// Require `task` in a new session, asserts that there are no dependency check errors.
  fn require(&amp;mut self, task: &amp;T) -&gt; T::Output {
    self.require_then_assert(task, |_| {})
  }

  /// Require `task` in a new session, then assert that it is not executed.
  fn require_then_assert_no_execute(&amp;mut self, task: &amp;T) -&gt; T::Output {
    self.require_then_assert(task, |t|
      assert!(!t.any_execute_of(task), &quot;expected no execution of task {:?}, but it was executed&quot;, task),
    )
  }
  /// Require `task` in a new session, then assert that it is executed exactly once.
  fn require_then_assert_one_execute(&amp;mut self, task: &amp;T) -&gt; T::Output {
    self.require_then_assert(task, |t|
      assert!(t.one_execute_of(task), &quot;expected one execution of task {:?}, but it was not executed, or was executed more than once&quot;, task),
    )
  }
}
impl&lt;T: Task&gt; TestPieExt&lt;T&gt; for TestPie&lt;T&gt; {
  fn require_then_assert(&amp;mut self, task: &amp;T, test_assert_func: impl FnOnce(&amp;EventTracker&lt;T, T::Output&gt;)) -&gt; T::Output {
    let mut session = self.new_session();
    let output = session.require(task);
    assert!(session.dependency_check_errors().is_empty(), &quot;expected no dependency checking errors, but there are \
    dependency checking errors: {:?}&quot;, session.dependency_check_errors());
    test_assert_func(&amp;self.tracker().0);
    output
  }
}</code></pre>
<p>We define an extension trait <code>TestPieExt</code> with a <code>require_then_assert</code> method, which requires a task in a new session, asserts that there are no dependency check errors, and then gives us the opportunity to perform additional assertions via a function that gives access to <code>EventTracker</code>.
This is very convenient for integration testing, as most tests will follow the pattern of requiring a task and then asserting properties.</p>
<p>This trait also provides:</p>
<ul>
<li><code>require</code> which is <code>require_then_assert</code> without an assertion closure,</li>
<li><code>require_then_assert_no_execute</code> which after requiring asserts that the task has not been executed using <code>!t.any_execution_of(task)</code> from <code>EventTracker</code>,</li>
<li><code>require_then_assert_one_execute</code> which does the same but asserts that it has been executed exactly once.</li>
</ul>
<p>We implement <code>TestPieExt</code> for <code>TestPie</code> so that we can call <code>require_then_assert</code> on any <code>TestPie</code> instance.</p>
<details id="admonition-extension-trait" class="admonition info">
<summary class="admonition-title">
<p>Extension trait</p>
<p><a class="admonition-anchor-link" href="3_min_sound/3_test/index.html#admonition-extension-trait"></a></p>
</summary>
<div>
<p>Extension traits are a pattern in Rust where we can add methods to an existing type via an extension trait and an implementation of the extension trait for the existing type.</p>
</div>
</details>
<p>We still need to define a task for testing.
Add the following to <code>pie/src/tests/common/mod.rs</code>:</p>
<pre><code class="language-rust ">/// Testing tasks enumeration.
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub enum TestTask {
  Return(&amp;'static str),
}
impl Task for TestTask {
  type Output = Result&lt;TestOutput, ErrorKind&gt;;
  fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, _context: &amp;mut C) -&gt; Self::Output {
    match self {
      TestTask::Return(string) =&gt; Ok(string.to_string().into()),
    }
  }
}

/// [`TestTask`] output enumeration.
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub enum TestOutput {
  String(String),
}
impl From&lt;String&gt; for TestOutput {
  fn from(value: String) -&gt; Self { Self::String(value) }
}
impl TestOutput {
  pub fn as_str(&amp;self) -&gt; &amp;str {
    match self {
      Self::String(s) =&gt; &amp;s,
    }
  }
}</code></pre>
<p>We define a <code>TestTask</code> enumeration containing all testing tasks, which for now is just a <code>Return</code> task that just returns its string, and implement <code>Task</code> for it.
The <code>Output</code> for <code>TestTask</code> is <code>Result&lt;TestOutput, ErrorKind&gt;</code> so that we can propagate IO errors in the future.</p>
<p><code>TestOutput</code> enumerates all possible outputs for <code>TestTask</code>, which for now is just a <code>String</code>.
We implement <code>From&lt;String&gt;</code> for <code>TestOutput</code> so we can easily convert <code>String</code>s into <code>TestOutput</code>. 
<code>as_str</code> performs the opposite operation.</p>
<p>Check that the code compiles with <code>cargo test</code>.</p>
<h2 id="first-integration-test"><a class="header" href="#first-integration-test">First integration test</a></h2>
<p>Now we're ready to test incrementality and soundness of the top-down incremental context through integration tests.
Create the <code>pie/src/tests/top_down.rs</code> file and add to it:</p>
<pre><code class="language-rust ">use std::io;

use assert_matches::assert_matches;

use pie::tracker::event::*;

use crate::common::{test_pie, TestPieExt, TestTask::*};

mod common;

#[test]
fn test_execution() -&gt; Result&lt;(), io::Error&gt; {
  let mut pie = test_pie();
  let task = Return(&quot;Hello, World!&quot;);
  let output = pie.require_then_assert(&amp;task, |tracker| {
    let events = tracker.slice();
    assert_matches!(events.get(0), Some(Event::RequireTaskStart(RequireTaskStart { task: t, .. })) if t == &amp;task);
    assert_matches!(events.get(1), Some(Event::ExecuteStart(ExecuteStart { task: t, .. })) if t == &amp;task);
    assert_matches!(events.get(2), Some(Event::ExecuteEnd(ExecuteEnd { task: t, .. })) if t == &amp;task);
    assert_matches!(events.get(3), Some(Event::RequireTaskEnd(RequireTaskEnd { task: t, .. })) if t == &amp;task);
  })?;
  assert_eq!(output.as_str(), &quot;Hello, World!&quot;);
  Ok(())
}</code></pre>
<p>In this first <code>test_execution</code> test we are just making sure that new tasks are executed, assert that the order of operations is correct, and check the task output.
We use <code>require_then_assert</code> to require the task and then perform assertions through a closure.
We're using <code>tracker.slice()</code> to get a slice of all build events, and assert (using <a href="https://docs.rs/assert_matches/latest/assert_matches/macro.assert_matches.html"><code>assert_matches!</code></a> again) that the following operations happen in order:</p>
<ul>
<li>start requiring <code>task</code>,</li>
<li>start executing <code>task</code>,</li>
<li>done executing <code>task</code>,</li>
<li>done requiring <code>task</code>.</li>
</ul>
<p><code>require_then_assert</code> returns the output of the task, which is a <code>Result</code>, so we first propagate the error with <code>?</code>.
Finally, we assert that the output equals what we expect.</p>
<p>Check that this test succeeds with <code>cargo test</code>.
To see what test failures look like, temporarily change <code>events.get(2)</code> to <code>events.get(3)</code> for example.</p>
<details id="admonition-integration-testing-in-rust" class="admonition info">
<summary class="admonition-title">
<p>Integration testing in Rust</p>
<p><a class="admonition-anchor-link" href="3_min_sound/3_test/index.html#admonition-integration-testing-in-rust"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/rust-by-example/testing/integration_testing.html">Integration tests</a> in Rust are for testing whether the different parts of your library work together correctly.
Integration tests have access to the public API of your crate.</p>
<p>In this <code>top_down.rs</code> integration test file, we're importing <code>common/mod.rs</code> by creating a module for it via <code>mod common;</code>.
If we create another integration testing file, we would again create a module for it in that integration testing file.
This is because every file in the <code>tests</code> directory is compiled as a separate crate, and can basically be seen as a separate <code>lib.rs</code> or <code>main.rs</code> file.</p>
<p>Putting the testing utilities behind a <code>common</code> directory ensures that it will not be compiled as a separate integration testing crate.</p>
</div>
</details>
<h2 id="testing-incrementality-and-soundness"><a class="header" href="#testing-incrementality-and-soundness">Testing incrementality and soundness</a></h2>
<p>We will now test incrementality and soundness.</p>
<h3 id="no-dependencies"><a class="header" href="#no-dependencies">No dependencies</a></h3>
<p>Let's first test that requiring a task without dependencies twice, only executes it once.
Add the following test to <code>pie/src/tests/top_down.rs</code>:</p>
<pre><code class="language-rust ">#[test]
fn test_reuse() -&gt; Result&lt;(), io::Error&gt; {
  let mut pie = test_pie();
  let task = Return(&quot;Hello, World!&quot;);
  // New task: execute.
  let output = pie.require(&amp;task)?;
  assert_eq!(output.as_str(), &quot;Hello, World!&quot;);
  // Nothing changed: no execute
  pie.require_then_assert_no_execute(&amp;task)?;
  Ok(())
}</code></pre>
<p>We're using <code>require</code> and <code>require_then_assert_no_execute</code> from <code>TestPieExt</code> which require the same task twice, in two different sessions.
Since <code>Return</code> has no dependencies, it should only ever be executed once, after which its output is cached for all eternity.</p>
<p>Check that this test succeeds with <code>cargo test</code>.</p>
<div id="admonition-reading-standard-output-from-tests" class="admonition info">
<div class="admonition-title">
<p>Reading standard output from tests</p>
<p><a class="admonition-anchor-link" href="3_min_sound/3_test/index.html#admonition-reading-standard-output-from-tests"></a></p>
</div>
<div>
<p>Cargo runs tests in parallel by default, which is good to run all tests as fast as possible (and it's also safe due to Rust's memory-safety and thread-safety guarantees!)
However, this mixes the standard outputs of all tests, which makes reading the build log from our writing tracker impossible.
If you want to see the standard output, either:</p>
<ul>
<li>Run tests <a href="https://doc.rust-lang.org/book/ch11-02-running-tests.html#running-tests-in-parallel-or-consecutively">consecutively</a> with: <code>cargo test -- --test-threads=1</code></li>
<li>Run a <a href="https://doc.rust-lang.org/book/ch11-02-running-tests.html#running-single-tests">single test</a> in the <code>top_down</code> integration test file with: <code>cargo test --test top_down test_reuse</code></li>
</ul>
<p>The second command should result in something like:</p>
<pre><code>    Finished test [unoptimized + debuginfo] target(s) in 0.02s
     Running tests/top_down.rs (/pie/target/debug/deps/top_down-a75f7568035f2005)

running 1 test
→ Return(&quot;Hello, World!&quot;)
 ▶ Return(&quot;Hello, World!&quot;)
 ◀ Ok(String(&quot;Hello, World!&quot;))
← Ok(String(&quot;Hello, World!&quot;))
🏁
→ Return(&quot;Hello, World!&quot;)
← Ok(String(&quot;Hello, World!&quot;))
🏁
test test_reuse ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

</code></pre>
</div>
</div>
<h3 id="testing-file-dependencies"><a class="header" href="#testing-file-dependencies">Testing file dependencies</a></h3>
<p>Next we want to test that a task with dependencies is not executed if its dependencies are consistent, and is executed when any of its dependencies are inconsistent.
Therefore, we need to add a task that has dependencies.</p>
<p>Modify <code>pie/src/tests/common/mod.rs</code>:</p>
<div class="diff2html" id="diff2html_0"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/common/mod.rs
+++ pie/tests/common/mod.rs
@@ -1,6 +1,8 @@
-use std::io::{BufWriter, ErrorKind, Stdout};
+use std::io::{BufWriter, ErrorKind, Read, Stdout};
+use std::path::PathBuf;
 
 use pie::{Context, Pie, Task};
+use pie::stamp::FileStamper;
 use pie::tracker::CompositeTracker;
 use pie::tracker::event::EventTracker;
 use pie::tracker::writing::WritingTracker;
@@ -60,12 +62,20 @@
 #[derive(Clone, Eq, PartialEq, Hash, Debug)]
 pub enum TestTask {
   Return(&'static str),
+  ReadFile(PathBuf, FileStamper),
 }
 impl Task for TestTask {
   type Output = Result<TestOutput, ErrorKind>;
-  fn execute<C: Context<Self>>(&self, _context: &mut C) -> Self::Output {
+  fn execute<C: Context<Self>>(&self, context: &mut C) -> Self::Output {
     match self {
       TestTask::Return(string) => Ok(string.to_string().into()),
+      TestTask::ReadFile(path, stamper) => {
+        let mut string = String::new();
+        if let Some(mut file) = context.require_file_with_stamper(&path, *stamper).map_err(|e| e.kind())? {
+          file.read_to_string(&mut string).map_err(|e| e.kind())?;
+        }
+        Ok(string.into())
+      }
     }
   }
 }
`;
    let target = document.getElementById('diff2html_0');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We add a <code>ReadFile</code> task that requires a file and returns its content as a string, similar to the ones we have implemented in the past.</p>
<p>Modify <code>pie/src/tests/top_down.rs</code> to add a new test:</p>
<div class="diff2html" id="diff2html_1"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -1,7 +1,10 @@
+use std::fs::write;
 use std::io;
 
 use assert_matches::assert_matches;
 
+use dev_shared::{create_temp_dir, write_until_modified};
+use pie::stamp::FileStamper;
 use pie::tracker::event::*;
 
 use crate::common::{test_pie, TestPieExt, TestTask::*};
@@ -34,3 +37,43 @@
   pie.require_then_assert_no_execute(&task)?;
   Ok(())
 }
+
+#[test]
+fn test_require_file() -> Result<(), io::Error> {
+  let mut pie = test_pie();
+  let temp_dir = create_temp_dir()?;
+
+  let file = temp_dir.path().join("in.txt");
+  write(&file, "HELLO WORLD!")?;
+  let task = ReadFile(file.clone(), FileStamper::Modified);
+
+  // 1) Require task and assert that it is executed because it is new.
+  let output = pie.require_then_assert_one_execute(&task)?;
+  assert_eq!(output.as_str(), "HELLO WORLD!");
+  // 2) Require task again and assert that it is not executed because its file dependency consistent.
+  let output = pie.require_then_assert_no_execute(&task)?;
+  assert_eq!(output.as_str(), "HELLO WORLD!");
+  // 3) Change required file such that the file dependency of the task becomes inconsistent.
+  write_until_modified(&file, "!DLROW OLLEH")?;
+  // 4) Require task again and assert that it is re-executed because its file dependency is inconsistent.
+  let output = pie.require_then_assert_one_execute(&task)?;
+  assert_eq!(output.as_str(), "!DLROW OLLEH");
+
+  // Repeat the test with ${"`"}FileStamper::Exists${"`"}, which results in a different outcome.
+  write(&file, "HELLO WORLD!")?;
+  let task = ReadFile(file.clone(), FileStamper::Exists);
+
+  // 1) Require task and assert that it is executed because it is new.
+  let output = pie.require_then_assert_one_execute(&task)?;
+  assert_eq!(output.as_str(), "HELLO WORLD!");
+  // 2) Require task again and assert that it is not executed because its file dependency is consistent.
+  let output = pie.require_then_assert_no_execute(&task)?;
+  assert_eq!(output.as_str(), "HELLO WORLD!");
+  // 3) Change required file, but the file dependency of the task stays consistent.
+  write_until_modified(&file, "!DLROW OLLEH")?;
+  // 4) Require task again and assert that it is not executed because its file dependency is still consistent.
+  let output = pie.require_then_assert_no_execute(&task)?;
+  assert_eq!(output.as_str(), "HELLO WORLD!");
+
+  Ok(())
+}
`;
    let target = document.getElementById('diff2html_1');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>In <code>test_require_file</code>, we first create a temporary directory and <code>file</code>, and a <code>ReadFile</code> <code>task</code> that reads from <code>file</code>.
We require the <code>task</code> task several times, and assert whether it should be executed or not:</p>
<ol>
<li>The task is new, so it should be executed, which we assert with <code>require_then_assert_one_execute</code>.</li>
<li>The task is not new, but its single require file dependency is still consistent, so it should not be executed.</li>
<li>We change the file the task depends on with <code>write_until_modified</code>.</li>
<li>We require the task again. This time it should be executed because its file dependency became inconsistent.</li>
</ol>
<p>We repeat the test with the <code>FileStamper::Exists</code> stamper, which correctly results in the task only being executed once.
It is a new task because its stamper is different, and it is not re-executed when the file is changed due to <code>FileStamper::Exists</code> only checking if the file exists.</p>
<p>Note that in general, the <code>FileStamper::Exists</code> stamper is not a good stamper to use with <code>ReadFile</code>, because it will only be re-executed when the file is added or removed.
But for testing purposes, this is fine. </p>
<p>Check that this test succeeds with <code>cargo test</code>.</p>
<h3 id="testing-task-dependencies"><a class="header" href="#testing-task-dependencies">Testing task dependencies</a></h3>
<p>Now it's time to test the more complicated task dependencies.
For that, we'll implement a task that depends on another task.
Modify <code>pie/src/tests/common/mod.rs</code>:</p>
<div class="diff2html" id="diff2html_2"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/common/mod.rs
+++ pie/tests/common/mod.rs
@@ -63,6 +63,7 @@
 pub enum TestTask {
   Return(&'static str),
   ReadFile(PathBuf, FileStamper),
+  ToLower(Box<TestTask>),
 }
 impl Task for TestTask {
   type Output = Result<TestOutput, ErrorKind>;
@@ -76,6 +77,10 @@
         }
         Ok(string.into())
       }
+      TestTask::ToLower(string_provider_task) => {
+        let string = context.require_task(string_provider_task.as_ref())?.into_string();
+        Ok(string.to_lowercase().into())
+      }
     }
   }
 }
@@ -94,4 +99,9 @@
       Self::String(s) => &s,
     }
   }
+  pub fn into_string(self) -> String {
+    match self {
+      Self::String(s) => s,
+    }
+  }
 }
`;
    let target = document.getElementById('diff2html_2');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We add a <code>ToLower</code> task that requires another task (stored as <code>Box&lt;TestTask&gt;</code>) to get a <code>String</code>, which it then converts to lower case.
We also add the <code>into_string</code> method to <code>TestOutput</code> for conveniently getting an owned <code>String</code> from a <code>TestOutput</code>.</p>
<details id="admonition-boxing-to-prevent-cyclic-size-calculation" class="admonition info">
<summary class="admonition-title">
<p>Boxing to prevent cyclic size calculation</p>
<p><a class="admonition-anchor-link" href="3_min_sound/3_test/index.html#admonition-boxing-to-prevent-cyclic-size-calculation"></a></p>
</summary>
<div>
<p>We store the string providing task as <code>Box&lt;TestTask&gt;</code> in order to prevent cyclic size calculation, which would cause <code>TestTask</code> to have an undetermined size.
This is due to several reasons:</p>
<ul>
<li>In Rust, values are stored on the stack by default. To store something on the stack, Rust needs to know its size <em>at compile-time</em>.</li>
<li>The size of an <code>enum</code> is the size of the largest variant.</li>
<li>The size of a struct is the sum of the size of the fields.</li>
</ul>
<p>If we don't box the task, to calculate the size of the <code>ToLower</code> enum variant, we need to calculate the size of <code>TestTask</code>, which would require calculating the size of the <code>ToLower</code> variant, and so forth.
Therefore, we can't calulate the size of <code>ToLower</code> nor <code>TestTask</code>, which is an error.</p>
<p>Boxing solves this because <code>Box&lt;TestTask&gt;</code> allocates a <code>TestTask</code> on the heap, and then creates a pointer to it.
Therefore, the size of <code>Box&lt;TestTask&gt;</code> is the size of one pointer, breaking the cycle in the size calculations.</p>
<p>Note that this explanation <a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html">simplifies many aspects of Rust's size calculation</a>.</p>
</div>
</details>
<p>Now add a test to <code>pie/src/tests/top_down.rs</code>: </p>
<div class="diff2html" id="diff2html_3"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -77,3 +77,16 @@
 
   Ok(())
 }
+
+#[test]
+fn test_require_task() -> Result<(), io::Error> {
+  let mut pie = test_pie();
+  let temp_dir = create_temp_dir()?;
+
+  let file = temp_dir.path().join("in.txt");
+  write(&file, "HELLO WORLD!")?;
+  let read = ReadFile(file.clone(), FileStamper::Modified);
+  let lower = ToLower(Box::new(read.clone()));
+
+  Ok(())
+}
`;
    let target = document.getElementById('diff2html_3');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>In <code>test_require_task</code>, we create a <code>read</code> task that reads from <code>file</code>, and a <code>lower</code> task that requires <code>read</code>.
In this test, we want to test three properties:</p>
<ol>
<li>When we require <code>lower</code> for the first time, it will require <code>read</code>, which will require <code>file</code>, <code>read</code> will return the contents of <code>file</code> as a string, and <code>lower</code> will turn that string into lowercase and return it. </li>
<li>When we require <code>lower</code> when <code>file</code> has not been changed, no task is executed.</li>
<li>When we require <code>lower</code> when <code>file</code>'s contents <em>have changed</em>, then first <code>read</code> must be executed, and then <code>lower</code> must be executed with the output of <code>read</code>.</li>
</ol>
<h4 id="initial-require"><a class="header" href="#initial-require">Initial require</a></h4>
<p>Test the first property by adding the following code to <code>pie/src/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_4"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -1,5 +1,6 @@
 use std::fs::write;
 use std::io;
+use std::ops::RangeInclusive;
 
 use assert_matches::assert_matches;
 
@@ -88,5 +89,56 @@
   let read = ReadFile(file.clone(), FileStamper::Modified);
   let lower = ToLower(Box::new(read.clone()));
 
+  // 1) Require ${"`"}ToLower${"`"} and assert that both tasks are executed in dependency order, because both tasks are new:
+  // → ToLower
+  //   ▶ ToLower [reason: new]
+  //     → ReadFile
+  //       ▶ ReadFile [reason: new]
+  //         - ${"`"}file${"`"}
+  //       ◀ Ok(String("HELLO WORLD!"))
+  //     ← Ok(String("HELLO WORLD!"))
+  //   ◀ Ok(String("hello world!"))
+  // ← Ok(String("hello world!"))
+  // 🏁
+  let output = pie.require_then_assert(&lower, |tracker| {
+    // ${"`"}ToLower${"`"} is required and executed, and its require and execute are temporally sound.
+    let lower_require = assert_matches!(tracker.first_require_task_range(&lower), Some(r) => r);
+    let lower_execute = assert_matches!(tracker.first_execute_range(&lower), Some(r) => r);
+    assert_task_temporally_sound(&lower_require, &lower_execute);
+
+    // ${"`"}ReadFile${"`"} is required and executed, and its require and execute are temporally sound.
+    let read_require = assert_matches!(tracker.first_require_task_range(&read), Some(r) => r);
+    let read_execute = assert_matches!(tracker.first_execute_range(&read), Some(r) => r);
+    assert_task_temporally_sound(&read_require, &read_execute);
+
+    // Sanity check: ${"`"}file${"`"} is required.
+    let file_require = assert_matches!(tracker.first_require_file_index(&file), Some(i) => i);
+
+    // ${"`"}ReadFile${"`"} is required while ${"`"}ToLower${"`"} is being required.
+    assert!(read_require.start() > lower_require.start());
+    assert!(lower_require.end() > read_require.end());
+
+    // ${"`"}ReadFile${"`"} is executed while ${"`"}ToLower${"`"} is being executed.
+    assert!(read_execute.start() > lower_execute.start());
+    assert!(lower_execute.end() > read_execute.end());
+
+    // Sanity check: ${"`"}ReadFile${"`"} requires ${"`"}file${"`"} while executing.
+    assert!(file_require > read_execute.start());
+    assert!(read_execute.end() > file_require);
+  })?;
+  assert_eq!(output.as_str(), "hello world!");
+
   Ok(())
 }
+
+/// Assert that task requires and executes are temporally sound.
+fn assert_task_temporally_sound(require: &RangeInclusive<usize>, execute: &RangeInclusive<usize>) {
+  // Require and execute ends come after require and execute starts.
+  assert!(require.end() > require.start());
+  assert!(execute.end() > execute.start());
+  // A task is only executed if it is required.
+  // - Task execute starts should be later than their requires. 
+  assert!(execute.start() > require.start());
+  // - Task require ends should be later than their executes. 
+  assert!(require.end() > execute.end());
+}
`;
    let target = document.getElementById('diff2html_4');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We require <code>lower</code> for the first time and then assert properties using <code>require_then_assert</code>.
The comment shows the expected build log.</p>
<p>Inside <code>require_then_assert</code> we will make extensive use of the indexes and ranges from our <code>EventTracker</code>, and use <code>assert_matches!</code> to ensure these indexes and ranges exist (i.e., return <code>Some</code>).
Ranges (<code>RangeInclusive</code>) are just the start and end indices of events, accessed with <code>.start()</code> and <code>.end()</code>.
Indices are numbers (<code>usize</code>) that we can compare using the standard <code>&gt;</code> operator.
A higher index indicates that the event happened later.</p>
<p>We get the ranges for requiring and executing the <code>lower</code> and <code>read</code> tasks, asserting that they are both required and executed.
Then we perform some sanity checks in <code>assert_task_temporally_sound</code>:</p>
<ul>
<li>Require and execute end events should come after their start events.</li>
<li>A task only starts being executed after it starts being required. If a task is executed without being required (and thus without being checked), we are breaking incrementality.</li>
<li>A task must only finish being required after it is finished being executed. If requiring a task ends before executing it, we are breaking soundness, because we are returning an inconsistent value to the requiring task.</li>
</ul>
<p>We confirm that <code>file</code> is required and get the corresponding event index into <code>file_require</code>.
Then we assert several properties:</p>
<ul>
<li><code>read</code> is required/executed while <code>lower</code> is being required/executed.
<ul>
<li>If <code>read</code> would be executed <em>after</em> <code>lower</code> finished executing, we are breaking soundness because then we would have executed <code>lower</code> without first requiring/executing its dependencies.</li>
<li>If <code>read</code> would be executed <em>before</em> <code>lower</code> started executing, we are breaking incrementality due to executing a task that was not required. In this test, we would not really break incrementality if this happened, but in general we could.</li>
</ul>
</li>
<li><code>file</code> is required while <code>read</code> is being executed. A sanity check to ensure the file dependency is made by the right task.</li>
</ul>
<p>Finally, we assert that the final output of requiring <code>lower</code> is <code>&quot;hello world!&quot;</code>, which is the contents of the file in lowercase.
Check that this test succeeds with <code>cargo test</code>.
That concludes the first property that we wanted to test!</p>
<h4 id="no-changes"><a class="header" href="#no-changes">No changes</a></h4>
<p>The second one is easier: when <code>file</code> has not changed, no task is executed.
Add the following code to <code>pie/src/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_5"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -128,6 +128,18 @@
   })?;
   assert_eq!(output.as_str(), "hello world!");
 
+  // 2) Require ${"`"}ToLower${"`"} again and assert that no tasks are executed because all dependencies are consistent:
+  // → ToLower
+  //   ? ReadFile
+  //     → ReadFile
+  //       ✓ ${"`"}file${"`"}
+  //     ← Ok(String("HELLO WORLD!"))
+  //   ✓ ReadFile
+  // ← Ok(String("hello world!"))
+  // 🏁
+  let output = pie.require_then_assert_no_execute(&lower)?;
+  assert_eq!(output.as_str(), "hello world!");
+
   Ok(())
 }
 
`;
    let target = document.getElementById('diff2html_5');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Here we change nothing and use <code>require_then_assert_no_execute</code> to assert no task is executed.
Check that this test succeeds with <code>cargo test</code>.</p>
<h4 id="changed-file-affects-task"><a class="header" href="#changed-file-affects-task">Changed file affects task</a></h4>
<p>Now we test the third property, testing soundness and incrementality after a change.
Add the following code to <code>pie/src/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_6"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -140,6 +140,47 @@
   let output = pie.require_then_assert_no_execute(&lower)?;
   assert_eq!(output.as_str(), "hello world!");
 
+  // Change ${"`"}file${"`"} such that the file dependency of ${"`"}ReadFile${"`"} becomes inconsistent.
+  write_until_modified(&file, "!DLROW OLLEH")?;
+
+  // 3) Require ${"`"}ToLower${"`"} and assert that both tasks are re-executed in reverse dependency order:
+  // → ToLower
+  //   ? ReadFile
+  //     → ReadFile
+  //       ✗ ${"`"}file${"`"} [inconsistent: modified file stamp change]
+  //       ▶ ReadFile [reason: ${"`"}file${"`"} is inconsistent due to modified file stamp change]
+  //         - ${"`"}file${"`"}
+  //       ◀ Ok(String("!DLROW OLLEH")) [note: returns a different output!]
+  //     ← Ok(String("!DLROW OLLEH"))
+  //   ✗ ReadFile [inconsistent: equals output stamp change]
+  //   ▶ ToLower [reason: ReadFile is inconsistent due to equals output stamp change]
+  //     → ReadFile
+  //     ← Ok(String("!DLROW OLLEH")) [note: skipped checking ${"`"}read${"`"} because it is already consistent this session!]
+  //   ◀ Ok(String("!dlrow olleh"))
+  // ← Ok(String("!dlrow olleh"))
+  // 🏁
+  let output = pie.require_then_assert(&lower, |tracker| {
+    // Sanity checks: ${"`"}ToLower${"`"} and ${"`"}ReadFile${"`"} are required and executed, and ${"`"}file${"`"} is required.
+    let lower_require = assert_matches!(tracker.first_require_task_range(&lower), Some(r) => r);
+    let lower_execute = assert_matches!(tracker.first_execute_range(&lower), Some(r) => r);
+    assert_task_temporally_sound(&lower_require, &lower_execute);
+    let read_require = assert_matches!(tracker.first_require_task_range(&read), Some(r) => r);
+    let read_execute = assert_matches!(tracker.first_execute_range(&read), Some(r) => r);
+    assert_task_temporally_sound(&read_require, &read_execute);
+    let file_require = assert_matches!(tracker.first_require_file_index(&file), Some(i) => i);
+
+    // Sanity check: ${"`"}ReadFile${"`"} requires ${"`"}file${"`"} while executing.
+    assert!(file_require > read_execute.start());
+    assert!(read_execute.end() > file_require);
+
+    // ${"`"}ToLower${"`"} is executed after ${"`"}ReadFile${"`"} has been executed.
+    assert!(lower_execute.start() > read_execute.end());
+    // ${"`"}ReadFile${"`"} is executed while ${"`"}ToLower${"`"} is being required.
+    assert!(read_execute.start() > lower_require.start());
+    assert!(lower_require.end() > read_execute.end());
+  })?;
+  assert_eq!(output.as_str(), "!dlrow olleh");
+
   Ok(())
 }
 
`;
    let target = document.getElementById('diff2html_6');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We first change the <code>file</code> contents such that <code>read</code>'s <code>file</code> dependency becomes inconsistent, and then require <code>lower</code> again.
In the <code>require_then_assert</code> block we first assert that both tasks are required and executed, <code>file</code> is required, and perform sanity checks again.</p>
<p>Now let's go back to the build log in the comment, which is lot more complicated this time due to recursive consistency checking. The gist is:</p>
<ul>
<li>To check if <code>lower</code> should be executed, we check its dependencies: a task dependency to <code>read</code>.
<ul>
<li>To check if <code>read</code> should be executed, we check its dependencies: a <code>file</code> dependency, which is inconsistent, thus we execute <code>read</code>.</li>
<li><code>read</code> executes and now returns <code>&quot;!DLROW OLLEH&quot;</code> instead of <code>&quot;HELLO WORLD!&quot;</code>.</li>
</ul>
</li>
<li>Then we are back to checking <code>lower</code>'s task dependency to <code>read</code>, which is inconsistent because <code>read</code> returns a different value, which is inconsistent due to the equals output stamper. </li>
<li>Thus, we execute <code>lower</code> which requires <code>read</code>.</li>
<li>We can skip checking <code>read</code> because we already checked and executed it: it is deemed consistent this session. We immediately return its output <code>&quot;!DLROW OLLEH&quot;</code> to <code>lower</code>.</li>
<li><code>lower</code> turns the string lowercase and returns it.</li>
</ul>
<p>Note that we are executing <code>read</code> <em>before</em> executing <code>lower</code> this time (but still <em>while requiring</em> <code>lower</code>).
This is important for incrementality because if <code>read</code> had not returned a different output, we would not have to execute <code>lower</code> due to its equals output stamp still being consistent (we call this <em>early cutoff</em>).
We test this property with the last 3 assertions in the <code>require_then_assert</code> block.</p>
<p>Finally, we assert that the output is <code>&quot;!dlrow olleh&quot;</code> as expected.
Confirm that this test succeeds with <code>cargo test</code>.</p>
<p>Now that we're testing task dependencies anyway, let's also test a fourth property: the early cutoff behaviour.</p>
<h4 id="early-cutoff"><a class="header" href="#early-cutoff">Early cutoff</a></h4>
<p>Early cutoff can happen in this test when <code>read</code> is re-executed due to its file dependency being inconsistent (modified file stamp change), but returns the same output as last time.
In that case, we don't have to execute <code>lower</code> because its task dependency to <code>read</code> is still consistent (equals output stamp is the same).
We can trigger this case in this test by changing <code>file</code> such that its last modified date changes, but its contents stay the same.</p>
<p>Add the following code to <code>pie/src/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_7"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -181,6 +181,17 @@
   })?;
   assert_eq!(output.as_str(), "!dlrow olleh");
 
+  // Change ${"`"}file${"`"} such that the file dependency of ${"`"}ReadFile${"`"} becomes inconsistent, but still has the same content.
+  write_until_modified(&file, "!DLROW OLLEH")?;
+
+  let output = pie.require_then_assert(&lower, |tracker| {
+    // ${"`"}ReadFile${"`"} needs to be executed due to its ${"`"}file${"`"} dependency being inconsistent (modified stamp changed).
+    assert!(tracker.one_execute_of(&read));
+    // ${"`"}Lower${"`"} is not executed, because its task dependency to ${"`"}ReadFile${"`"} is consistent (equals stamp is the same).
+    assert!(!tracker.any_execute_of(&lower));
+  })?;
+  assert_eq!(output.as_str(), "!dlrow olleh");
+
   Ok(())
 }
 
`;
    let target = document.getElementById('diff2html_7');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We change <code>file</code> in the way we discussed, and then assert that <code>read</code> is executed, but <code>lower</code> is not.
Confirm that this test succeeds with <code>cargo test</code>.</p>
<p>Nice! These tests give quite some confidence that what we've been doing so far seems to be sound and incremental.
We can (and should) of course write more tests for better coverage of the implementation.
For example, we haven't tested tasks with multiple dependencies yet.
However, in this tutorial we will move on to a couple of specific tests first, because there are several issues still hiding in our implementation: (at least) one bug, and three soundness holes.
After we've uncovered those issues and fix them, feel free to write more tests yourself!</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="3_min_sound/3_test/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="3_min_sound/3_test/../../gen/3_min_sound/3_test/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fix-superfluous-task-dependency"><a class="header" href="#fix-superfluous-task-dependency">Fix Superfluous Task Dependency</a></h1>
<p>There is actually a massive bug in our implementation.
If you noticed the issue while following this tutorial, you're pretty observant!
If you didn't catch it, don't worry. 
I actually didn't catch it either up until this point!</p>
<p>I decided to keep the bug in to show how hard it is to test incrementality and soundness.</p>
<p>Let's start by adding another testing task which we need to uncover the bug, and then write a test that manifests the bug.</p>
<h2 id="add-toupper-task"><a class="header" href="#add-toupper-task">Add <code>ToUpper</code> task</a></h2>
<p>Modify <code>pie/src/tests/common/mod.rs</code> to add another task:</p>
<div class="diff2html" id="diff2html_0"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/common/mod.rs
+++ pie/tests/common/mod.rs
@@ -64,6 +64,7 @@
   Return(&'static str),
   ReadFile(PathBuf, FileStamper),
   ToLower(Box<TestTask>),
+  ToUpper(Box<TestTask>),
 }
 impl Task for TestTask {
   type Output = Result<TestOutput, ErrorKind>;
@@ -81,6 +82,10 @@
         let string = context.require_task(string_provider_task.as_ref())?.into_string();
         Ok(string.to_lowercase().into())
       }
+      TestTask::ToUpper(string_provider_task) => {
+        let string = context.require_task(string_provider_task.as_ref())?.into_string();
+        Ok(string.to_uppercase().into())
+      }
     }
   }
 }
`;
    let target = document.getElementById('diff2html_0');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>The <code>ToUpper</code> task does (as expected) the opposite of the <code>ToLower</code> task: it requires the string producing task and returns the string in uppercase.</p>
<h2 id="test-case-setup"><a class="header" href="#test-case-setup">Test case setup</a></h2>
<p>No we set up a test case uncover the bug.
Modify <code>pie/src/tests/top_down.rs</code> to add another test:</p>
<div class="diff2html" id="diff2html_1"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -206,3 +206,35 @@
   // - Task require ends should be later than their executes. 
   assert!(require.end() > execute.end());
 }
+
+#[test]
+fn test_no_superfluous_task_dependencies() -> Result<(), io::Error> {
+  let mut pie = test_pie();
+  let temp_dir = create_temp_dir()?;
+
+  let file = temp_dir.path().join("in.txt");
+  write(&file, "Hello, World!")?;
+  let read = ReadFile(file.clone(), FileStamper::Modified);
+  let lower = ToLower(Box::new(read.clone()));
+  let upper = ToUpper(Box::new(lower.clone()));
+
+  // Require ${"`"}ToLower${"`"} and assert that ${"`"}ReadFile${"`"} and ${"`"}Lower${"`"} are executed because they are new, but not ${"`"}ToUpper${"`"},
+  // because it not required by anything. ${"`"}ToLower${"`"} will return ${"`"}"hello, world!"${"`"}.
+  let output = pie.require_then_assert(&lower, |tracker| {
+    assert!(tracker.one_execute_of(&read));
+    assert!(tracker.one_execute_of(&lower));
+    assert!(!tracker.any_execute_of(&upper));
+  })?;
+  assert_eq!(output.as_str(), "hello, world!");
+
+  // Require ${"`"}ToUpper${"`"} and assert that it is executed because it is new, but not ${"`"}ReadFile${"`"} nor ${"`"}ToLower${"`"} because their
+  // dependencies are consistent.
+  let output = pie.require_then_assert(&upper, |tracker| {
+    assert!(!tracker.any_execute_of(&read));
+    assert!(!tracker.any_execute_of(&lower));
+    assert!(tracker.one_execute_of(&upper));
+  })?;
+  assert_eq!(output.as_str(), "HELLO, WORLD!");
+
+  Ok(())
+}
`;
    let target = document.getElementById('diff2html_1');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>This test is similar to the previous one, but we have added a <code>ToUpper</code> task which requires the <code>ToLower</code> task.
We first require <code>ToLower</code> and assert that only <code>ToLower</code> and <code>ReadFile</code> are executed.
<code>ToUpper</code> should not be executed because we have not required it, and neither <code>ToLower</code> nor <code>ReadFile</code> require it.</p>
<p>Then, we require <code>ToUpper</code> and assert that it is executed.
Neither <code>ToLower</code> nor <code>ReadFile</code> should be executed because their dependencies are still consistent.</p>
<p>Check that this test, so far, succeeds with <code>cargo test</code>.
You can inspect the build log with <code>cargo test --test top_down test_no_superfluous_task_dependencies</code> to see what is going on, but it should look pretty normal.
The important part of this setup is that <code>ToLower</code> returns <code>&quot;hello, world!&quot;</code>.</p>
<h2 id="manifest-the-bug"><a class="header" href="#manifest-the-bug">Manifest the bug</a></h2>
<p>Manifest the bug by modifying <code>pie/src/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_2"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -236,5 +236,19 @@
   })?;
   assert_eq!(output.as_str(), "HELLO, WORLD!");
 
+  // Change ${"`"}file${"`"} such that the file dependency of ${"`"}ReadFile${"`"} becomes inconsistent. However, we change its contents
+  // only slightly by turning 'l' characters into capital 'L' characters. Therefore, ${"`"}ToLower${"`"} will still return
+  // ${"`"}"hello, world!"${"`"}.
+  write_until_modified(&file, "HeLLo, WorLd!")?;
+
+  // Require ${"`"}ToUpper${"`"} but assert that it is _not executed_ because ${"`"}ToUpper${"`"}'s task dependency to ${"`"}ToLower${"`"} is still
+  // consistent, because ${"`"}ToLower${"`"} still returns ${"`"}"hello, world!"${"`"} which is the same as last time.
+  let output = pie.require_then_assert(&upper, |tracker| {
+    assert!(tracker.one_execute_of(&read));
+    assert!(tracker.one_execute_of(&lower));
+    assert!(!tracker.any_execute_of(&upper));
+  })?;
+  assert_eq!(output.as_str(), "HELLO, WORLD!");
+
   Ok(())
 }
`;
    let target = document.getElementById('diff2html_2');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We change <code>file</code> in a very specific way: we capitalize the <code>l</code> characters to <code>L</code> characters.
We do this to trigger early cutoff.
By changing <code>file</code> in this way, we expect <code>ReadFile</code> to execute and return <code>&quot;HeLLo, WorLd!&quot;</code>.
This in turn means that <code>ToLower</code>'s task dependency to <code>ReadFile</code> is inconsistent, because the output changed, so <code>ToLower</code> is executed.
However, <code>ToLower</code> changes those <code>L</code> characters back into <code>l</code> and returns <code>&quot;hello, world!&quot;</code>, which is the same as last time.
Therefore, <code>ToUpper</code>'s task dependency to <code>ToLower</code> is still consistent, and we can cut off the build early.
We assert this inside the <code>require_then_assert</code> block.</p>
<p>But, if you run the tests with <code>cargo test</code>, this test will fail!
How can that be?</p>
<div id="admonition-warning" class="admonition warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="3_min_sound/4_fix_task_dep/index.html#admonition-warning"></a></p>
</div>
<div>
<p>Test <code>test_no_superfluous_task_dependencies</code> will fail as expected, which we will fix in this section!</p>
</div>
</div>
<p>Inspect the build log with <code>cargo test --test top_down test_no_superfluous_task_dependencies</code>.
In the last build, you will see that <code>ToUpper</code> is required, and it will check its dependency to <code>ReadFile</code>.
But that shouldn't happen, because <code>ToUpper</code> only has a dependency to <code>ToLower</code>!
There seems to be a bug where <code>ToLower</code>'s task dependency to <code>ReadFile</code>, somehow ended up with <code>ToUpper</code>.</p>
<p>We need to go back to our consistency checking code to find the cause.</p>
<h2 id="finding-the-cause"><a class="header" href="#finding-the-cause">Finding the cause</a></h2>
<p>In the previous chapter, we implemented dynamic dependencies including an <code>is_inconsistent</code> method to check if a dependency is consistent.
This is the code we used for task dependencies:</p>
<pre><code class="language-rust ">  pub fn is_inconsistent&lt;C: Context&lt;T&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Option&lt;OutputStamp&lt;T::Output&gt;&gt; {
    let output = context.require_task(&amp;self.task);
    let new_stamp = self.stamper.stamp(output);
    if new_stamp == self.stamp {
      None
    } else {
      Some(new_stamp)
    }
  }</code></pre>
<p>To check if a task dependency is consistent, we call <code>require</code> on the context (which calls <code>require_task_with_stamper</code> with a default stamper).
Later on we implemented this <code>require_task_with_stamper</code> method for <code>TopDownContext</code>:</p>
<pre><code class="language-rust ">  fn require_task_with_stamper(&amp;mut self, task: &amp;T, stamper: OutputStamper) -&gt; T::Output {
    self.session.tracker.require_task_start(task, &amp;stamper);
    let node = self.session.store.get_or_create_task_node(task);

    // Get required task output by executing it if needed, or by getting the output from the store if not needed.
    let already_consistent = self.session.consistent.contains(&amp;node);
    let should_execute = !already_consistent &amp;&amp; self.should_execute_task(&amp;node);
    let output = if should_execute {
      self.session.tracker.execute_start(task);
      self.session.store.reset_task(&amp;node);
      let previous_executing_task = self.session.current_executing_task.replace(node);
      let output = task.execute(self);
      self.session.current_executing_task = previous_executing_task;
      self.session.store.set_task_output(&amp;node, output.clone());
      self.session.tracker.execute_end(task, &amp;output);
      output
    } else {
      // Correctness: when `should_execute_task` returns `true`, the above block is executed. Otherwise this block is
      // executed and `should_execute_task` ensures that the task has an output.
      self.session.store.get_task_output(&amp;node).clone()
    };

    let dependency = TaskDependency::new(task.clone(), stamper, output.clone());
    self.session.tracker.require_task_end(&amp;dependency, &amp;output, should_execute);

    // Create task require dependency if a task is currently executing (i.e., we are not requiring the initial task).
    if let Some(current_executing_task_node) = &amp;self.session.current_executing_task {
      if self.session.store.add_task_require_dependency(current_executing_task_node, &amp;node, dependency).is_err() {
        let current_executing_task = self.session.store.get_task(current_executing_task_node);
        panic!(&quot;Cyclic task dependency; current executing task '{:?}' is requiring task '{:?}' which was already required&quot;, current_executing_task, task);
      }
    }

    self.session.consistent.insert(node);
    output
  }</code></pre>
<p>In the <code>if let Some(current_executing_task_node)</code> block we are adding a task dependency from the current executing task (if any), to the task being required.
This is the cause of the bug.
Even if we are only <em>consistency checking</em> a task to see if it should be executed, we could end up adding a task dependency to the current executing task, which is not correct.
We only manifested the bug in the last test due to having a chain of 2 task dependencies, and by carefully controlling what is being executed and what is being checked.</p>
<p>Inspect the build log for the second <code>require_then_assert</code> call in the <code>test_no_superfluous_task_dependencies</code> test.
You will see that we are executing <code>ToUpper</code>, then require <code>ToLower</code>, then <em>consistency check</em> <code>ReadFile</code>, which in turn <em>requires</em> <code>ReadFile</code>.
At the end of that require, an incorrect dependency from <code>ToUpper</code> to <code>ReadFile</code> is made.
This incorrect dependency then later breaks incrementality.</p>
<p>To fix this bug, we need to make sure that we only add task dependencies when an executing task directly requires another task, not when consistency checking!</p>
<h2 id="fixing-the-bug"><a class="header" href="#fixing-the-bug">Fixing the bug</a></h2>
<p>To fix the bug, we will separate the process of <em>making a task consistent</em>, which does not add task dependencies, from <em>requiring a task</em>, which can add task dependencies.
We will split this part into a <code>make_task_consistent</code> method.
Modify the top-down context from <code>pie/src/context/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_3"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -39,9 +39,28 @@
 
   fn require_task_with_stamper(&mut self, task: &T, stamper: OutputStamper) -> T::Output {
     self.session.tracker.require_task_start(task, &stamper);
+
     let node = self.session.store.get_or_create_task_node(task);
+    let (output, was_executed) = self.make_task_consistent(task, node);
+
+    let dependency = TaskDependency::new(task.clone(), stamper, output.clone());
+    self.session.tracker.require_task_end(&dependency, &output, was_executed);
+
+    // Create task require dependency if a task is currently executing (i.e., we are not requiring the initial task).
+    if let Some(current_executing_task_node) = &self.session.current_executing_task {
+      if self.session.store.add_task_require_dependency(current_executing_task_node, &node, dependency).is_err() {
+        let current_executing_task = self.session.store.get_task(current_executing_task_node);
+        panic!("Cyclic task dependency; current executing task '{:?}' is requiring task '{:?}' which was already required", current_executing_task, task);
+      }
+    }
 
-    // Get required task output by executing it if needed, or by getting the output from the store if not needed.
+    output
+  }
+}
+
+impl<'p, 's, T: Task, A: Tracker<T>> TopDownContext<'p, 's, T, T::Output, A> {
+  // Get required task output by executing it if needed, or by getting the output from the store if not needed.
+  fn make_task_consistent(&mut self, task: &T, node: TaskNode) -> (T::Output, bool) {
     let already_consistent = self.session.consistent.contains(&node);
     let should_execute = !already_consistent && self.should_execute_task(&node);
     let output = if should_execute {
@@ -58,24 +77,11 @@
       // executed and ${"`"}should_execute_task${"`"} ensures that the task has an output.
       self.session.store.get_task_output(&node).clone()
     };
-
-    let dependency = TaskDependency::new(task.clone(), stamper, output.clone());
-    self.session.tracker.require_task_end(&dependency, &output, should_execute);
-
-    // Create task require dependency if a task is currently executing (i.e., we are not requiring the initial task).
-    if let Some(current_executing_task_node) = &self.session.current_executing_task {
-      if self.session.store.add_task_require_dependency(current_executing_task_node, &node, dependency).is_err() {
-        let current_executing_task = self.session.store.get_task(current_executing_task_node);
-        panic!("Cyclic task dependency; current executing task '{:?}' is requiring task '{:?}' which was already required", current_executing_task, task);
-      }
-    }
 
     self.session.consistent.insert(node);
-    output
+    (output, should_execute)
   }
-}
 
-impl<'p, 's, T: Task, A: Tracker<T>> TopDownContext<'p, 's, T, T::Output, A> {
   /// Checks whether given task should be executed, returning ${"`"}true${"`"} if it should be executed. A task should be executed
   /// if any of its dependencies are inconsistent, or when it has no output.
   fn should_execute_task(&mut self, node: &TaskNode) -> bool {
`;
    let target = document.getElementById('diff2html_3');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We extracted the core of the <code>require_task_with_stamper</code> method into a <code>make_task_consistent</code> method, and call <code>make_task_consistent</code> in <code>require_task_with_stamper</code>.
This is a refactoring, so the <code>require_task_with_stamper</code> method will behave the same as before.</p>
<p>To reiterate, <code>make_task_consistent</code> makes given task is consistent by checking the task, executing it if inconsistent, and returning its output.
If it is already consistent, we return the cached output.
In both cases we also use and update <code>self.session.consistent</code>: the set of already consistent tasks this session. </p>
<p>Now we need to change the <code>is_inconsistent</code> methods on dependencies to use <code>make_task_consistent</code> instead.
However, the <code>is_inconsistent</code> method is generic over <code>Context</code>, which doesn't expose the <code>make_task_consistent</code> method.
We also do not want to expose <code>make_task_consistent</code> to users of the library, as it would allow tasks authors to make tasks consistent without adding dependencies, which could break incrementality.
Therefore, we will define a <code>MakeConsistent</code> trait in the dependency module, and have <code>TopDownContext</code> implement that.</p>
<p>Modify <code>pie/src/dependency.rs</code>:</p>
<div class="diff2html" id="diff2html_4"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/dependency.rs
+++ pie/src/dependency.rs
@@ -3,7 +3,7 @@
 use std::io;
 use std::path::PathBuf;
 
-use crate::{Context, Task};
+use crate::Task;
 use crate::fs::open_if_file;
 use crate::stamp::{FileStamp, FileStamper, OutputStamp, OutputStamper};
 
@@ -89,8 +89,8 @@
   /// Checks whether this task dependency is inconsistent, returning:
   /// - ${"`"}Some(stamp)${"`"} if this dependency is inconsistent (with ${"`"}stamp${"`"} being the new stamp of the dependency),
   /// - ${"`"}None${"`"} if this dependency is consistent.
-  pub fn is_inconsistent<C: Context<T>>(&self, context: &mut C) -> Option<OutputStamp<T::Output>> {
-    let output = context.require_task(&self.task);
+  pub fn is_inconsistent<C: MakeConsistent<T>>(&self, context: &mut C) -> Option<OutputStamp<T::Output>> {
+    let output = context.make_task_consistent(&self.task);
     let new_stamp = self.stamper.stamp(output);
     if new_stamp == self.stamp {
       None
@@ -100,6 +100,11 @@
   }
 }
 
+/// Make a task consistent without adding dependencies.
+pub trait MakeConsistent<T: Task> {
+  fn make_task_consistent(&mut self, task: &T) -> T::Output;
+}
+
 
 #[derive(Clone, Eq, PartialEq, Debug)]
 pub enum Dependency<T, O> {
@@ -118,7 +123,7 @@
   /// - ${"`"}Ok(Some(stamp))${"`"} if the dependency is inconsistent (with ${"`"}stamp${"`"} being the new stamp of the dependency),
   /// - ${"`"}Ok(None)${"`"} if the dependency is consistent,
   /// - ${"`"}Err(e)${"`"} if there was an error checking the dependency for consistency.
-  pub fn is_inconsistent<C: Context<T>>(&self, context: &mut C) -> Result<Option<Inconsistency<T::Output>>, io::Error> {
+  pub fn is_inconsistent<C: MakeConsistent<T>>(&self, context: &mut C) -> Result<Option<Inconsistency<T::Output>>, io::Error> {
     let option = match self {
       Dependency::RequireFile(d) => d.is_inconsistent()?
         .map(|s| Inconsistency::File(s)),
@@ -137,6 +142,7 @@
 
   use dev_shared::{create_temp_file, write_until_modified};
 
+  use crate::Context;
   use crate::context::non_incremental::NonIncrementalContext;
 
   use super::*;
`;
    let target = document.getElementById('diff2html_4');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We add the <code>MakeConsistent</code> trait and use it in <code>is_inconsistent</code>. 
Now we go back to <code>TopDownContext</code> and implement that trait.</p>
<p>Modify <code>pie/src/context/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_5"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -3,7 +3,7 @@
 use std::path::Path;
 
 use crate::{Context, fs, Session, Task};
-use crate::dependency::{FileDependency, TaskDependency};
+use crate::dependency::{FileDependency, MakeConsistent, TaskDependency};
 use crate::stamp::{FileStamper, OutputStamper};
 use crate::store::TaskNode;
 use crate::tracker::Tracker;
@@ -58,6 +58,14 @@
   }
 }
 
+impl<'p, 's, T: Task, A: Tracker<T>> MakeConsistent<T> for TopDownContext<'p, 's, T, T::Output, A> {
+  fn make_task_consistent(&mut self, task: &T) -> T::Output {
+    let node = self.session.store.get_or_create_task_node(task);
+    let (output, _) = self.make_task_consistent(task, node);
+    output
+  }
+}
+
 impl<'p, 's, T: Task, A: Tracker<T>> TopDownContext<'p, 's, T, T::Output, A> {
   // Get required task output by executing it if needed, or by getting the output from the store if not needed.
   fn make_task_consistent(&mut self, task: &T, node: TaskNode) -> (T::Output, bool) {
`;
    let target = document.getElementById('diff2html_5');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We implement the <code>MakeConsistent</code> trait on <code>TopDownContext</code>, forwarding it to the <code>make_task_consistent</code> method.</p>
<p>We also need to implement this trait for the <code>NonIncrementalContext</code>.
Modify <code>pie/src/context/non_incremental.rs</code>:</p>
<div class="diff2html" id="diff2html_6"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/non_incremental.rs
+++ pie/src/context/non_incremental.rs
@@ -3,6 +3,7 @@
 use std::path::Path;
 
 use crate::{Context, Task};
+use crate::dependency::MakeConsistent;
 use crate::fs::open_if_file;
 use crate::stamp::{FileStamper, OutputStamper};
 
@@ -18,6 +19,12 @@
   }
 }
 
+impl<'p, 's, T: Task> MakeConsistent<T> for NonIncrementalContext {
+  fn make_task_consistent(&mut self, task: &T) -> T::Output {
+    task.execute(self)
+  }
+}
+
 #[cfg(test)]
 mod test {
   use super::*;
`;
    let target = document.getElementById('diff2html_6');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>If you run <code>cargo test</code> now, <code>test_no_superfluous_task_dependencies</code> should succeed, indicating that we fixed the bug!
However, <code>test_require_task</code> now fails 😅.</p>
<div id="admonition-warning-1" class="admonition warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="3_min_sound/4_fix_task_dep/index.html#admonition-warning-1"></a></p>
</div>
<div>
<p>Test <code>test_require_task</code> will fail, which we will now fix!</p>
</div>
</div>
<p>An <code>assert!(execute.start() &gt; require.start())</code> in this test now fails, which is a sanity check asserting that &quot;executes starts&quot; should be later than &quot;require starts&quot;
This is because our changes have correctly removed several superfluous task requires, which influences these assertions.</p>
<p>Inspect the build log for this test with <code>cargo test --test top_down test_require_task</code>.
In the second build, <code>ReadFile</code> is now no longer required, and instead is only checked.
This is correct, and does not make any assertions fail.</p>
<p>In the third build, <code>ReadFile</code> is also no longer required at the start, but later on in the build it <em>is</em> required when <code>ToLower</code> is executed.
This is correct, as it is only <em>checked</em> at the start, but <em>required</em> later while <code>ToLower</code> is executing.</p>
<p>The problem is that this assertion just does not hold anymore, as a task can be executed without first being required.
What does hold, is that a task is only executed after either being checked <em>or</em> required.
However, we don't track checking in the event tracker, so we will just remove this assertion to keep the tutorial going.
We will also update the build logs in the comments to reflect our changes.</p>
<p>Fix the tests by modifying <code>pie/src/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_7"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -131,9 +131,7 @@
   // 2) Require ${"`"}ToLower${"`"} again and assert that no tasks are executed because all dependencies are consistent:
   // → ToLower
   //   ? ReadFile
-  //     → ReadFile
-  //       ✓ ${"`"}file${"`"}
-  //     ← Ok(String("HELLO WORLD!"))
+  //     ✓ ${"`"}file${"`"}
   //   ✓ ReadFile
   // ← Ok(String("hello world!"))
   // 🏁
@@ -146,12 +144,10 @@
   // 3) Require ${"`"}ToLower${"`"} and assert that both tasks are re-executed in reverse dependency order:
   // → ToLower
   //   ? ReadFile
-  //     → ReadFile
-  //       ✗ ${"`"}file${"`"} [inconsistent: modified file stamp change]
-  //       ▶ ReadFile [reason: ${"`"}file${"`"} is inconsistent due to modified file stamp change]
-  //         - ${"`"}file${"`"}
-  //       ◀ Ok(String("!DLROW OLLEH")) [note: returns a different output!]
-  //     ← Ok(String("!DLROW OLLEH"))
+  //     ✗ ${"`"}file${"`"} [inconsistent: modified file stamp change]
+  //     ▶ ReadFile [reason: ${"`"}file${"`"} is inconsistent due to modified file stamp change]
+  //       - ${"`"}file${"`"}
+  //     ◀ Ok(String("!DLROW OLLEH")) [note: returns a different output!]
   //   ✗ ReadFile [inconsistent: equals output stamp change]
   //   ▶ ToLower [reason: ReadFile is inconsistent due to equals output stamp change]
   //     → ReadFile
@@ -200,10 +196,7 @@
   // Require and execute ends come after require and execute starts.
   assert!(require.end() > require.start());
   assert!(execute.end() > execute.start());
-  // A task is only executed if it is required.
-  // - Task execute starts should be later than their requires. 
-  assert!(execute.start() > require.start());
-  // - Task require ends should be later than their executes. 
+  // Task require ends should be later than their executes.
   assert!(require.end() > execute.end());
 }
 
`;
    let target = document.getElementById('diff2html_7');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Confirm this fixes the tests with <code>cargo test</code>.
All tests are green! 🎉🎉🎉</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/diff2html-ui-base.min.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
