<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Build your own Programmatic Incremental Build System</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/mdbook-admonish.css">
        <link rel="stylesheet" href="src/diff2html.min.css">
        <link rel="stylesheet" href="src/custom.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Introduction</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Programmability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="1_programmability/0_setup/index.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="1_programmability/1_api/index.html"><strong aria-hidden="true">2.2.</strong> Programmable Build System API</a></li><li class="chapter-item expanded "><a href="1_programmability/2_non_incremental/index.html"><strong aria-hidden="true">2.3.</strong> Non-Incremental Context</a></li></ol></li><li class="chapter-item expanded "><a href="2_incrementality/index.html"><strong aria-hidden="true">3.</strong> Incrementality</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2_incrementality/1_require_file/index.html"><strong aria-hidden="true">3.1.</strong> Requiring Files</a></li><li class="chapter-item expanded "><a href="2_incrementality/2_stamp/index.html"><strong aria-hidden="true">3.2.</strong> Stamps</a></li><li class="chapter-item expanded "><a href="2_incrementality/3_dependency/index.html"><strong aria-hidden="true">3.3.</strong> Dynamic Dependencies</a></li><li class="chapter-item expanded "><a href="2_incrementality/4_store/index.html"><strong aria-hidden="true">3.4.</strong> Dependency Graph Store</a></li><li class="chapter-item expanded "><a href="2_incrementality/5_context/index.html"><strong aria-hidden="true">3.5.</strong> Incremental Top-Down Context</a></li></ol></li><li class="chapter-item expanded "><a href="3_min_sound/index.html"><strong aria-hidden="true">4.</strong> Minimality and Soundness</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3_min_sound/1_session/index.html"><strong aria-hidden="true">4.1.</strong> Minimality with Sessions</a></li><li class="chapter-item expanded "><a href="3_min_sound/2_tracker/index.html"><strong aria-hidden="true">4.2.</strong> Tracking Build Events</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Prevent Overlapping File Writes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> Prevent Hidden Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> Prevent Cycles</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Improvements</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Serialization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> More Stampers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Configurable Hashing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Efficiency</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Incremental Bottom-Up Context</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Observability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Deferred Tasks</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Multiple Task Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> On Static Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> On Declarativity</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Related Work</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<div id="admonition-under-construction" class="admonition warning">
<div class="admonition-title">
<p>Under construction</p>
<p><a class="admonition-anchor-link" href="1_programmability/0_setup/index.html#admonition-under-construction"></a></p>
</div>
<div>
<p>This page was quickly created to make setup possible, but is unfinished.</p>
</div>
</div>
<p>Make sure <a href="https://www.rust-lang.org/tools/install">Rust is installed</a>.</p>
<p>We start by creating a new Rust crate.
Create the <code>pie</code> directory and create the <code>pie/Cargo.toml</code> file with the following contents:</p>
<pre><code class="language-toml ">[package]
name = &quot;pie&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
</code></pre>
<p>Then create the <code>pie/src</code> directory and create the <code>pie/src/lib.rs</code> file, which will be left empty for now.</p>
<p>Run <code>cargo build</code> to test if the project was set up correctly.
The output should look something like:</p>
<pre><code class="language-shell ">   Compiling pie v0.1.0 (/private/pie)
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
</code></pre>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="1_programmability/0_setup/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="1_programmability/0_setup/../../gen/1_programmability/0_setup/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programmable-build-system-api"><a class="header" href="#programmable-build-system-api">Programmable Build System API</a></h1>
<p>In this section, we will program the core API of the programmatic incremental build system.</p>
<p>The unit of computation in a programmatic build system is a <em>task</em>.
A task is kind of like a closure: a value that can be executed to produce their output.
However, in an <em>incremental</em> programmatic build system, we also need to keep track of <em>dynamic dependencies</em> that are made while tasks are executing.
Therefore, tasks are executed under a <em>build context</em> which enable them to create these dependencies.
Tasks <em>require</em> other tasks through the context, creating a dynamic dependency and returning their up-to-date output.</p>
<p>On the other hand, an incremental build context wants to <em>selectively execute tasks</em> — only those that are affected by a change.
To that end, a build context will selectively execute tasks, tasks require other tasks through the build context, the build context selectively executes those, and so forth.
Thus, tasks and build contexts are mutually recursive.</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="1_programmability/1_api/index.html#admonition-note"></a></p>
</div>
<div>
<p>In this tutorial, we will be using the words <em>context</em>, <em>build context</em>, and <em>build system</em> interchangeably, typically using just <em>context</em> as it is concise.</p>
</div>
</div>
<p>Let's make tasks and contexts more concrete by defining them in code.</p>
<h2 id="api-implementation"><a class="header" href="#api-implementation">API Implementation</a></h2>
<p>Since we want users of the build system to implement their own tasks, we will define <code>Task</code> as a trait.
Likewise, we will also be implementing multiple contexts in this tutorial, so we will also define <code>Context</code> as a trait.
Add the following code to your <code>pie/src/lib.rs</code> file:</p>
<pre><code class="language-rust ">use std::fmt::Debug;
use std::hash::Hash;

/// A unit of computation in a programmatic incremental build system.
pub trait Task: Clone + Eq + Hash + Debug {
  /// Type of output this task returns when executed.
  type Output: Clone + Eq + Debug;
  /// Execute the task, using `context` to specify dynamic dependencies, returning `Self::Output`.
  fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
}

/// Programmatic incremental build context, enabling tasks to create dynamic dependencies that context implementations 
/// use for incremental execution.
pub trait Context&lt;T: Task&gt; {
  /// Requires given `task`, recording a dependency and selectively executing it. Returns its up-to-date output.
  fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
}</code></pre>
<div id="admonition-note-1" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="1_programmability/1_api/index.html#admonition-note-1"></a></p>
</div>
<div>
<p>If this seems overwhelming to you, don't worry. We will go through the API and explain things. But more importantly, the API should become more clear once we implement it in the next section and subsequent chapters.
Furthermore, if you're new to Rust and/or need help understanding certain concepts, I will try to explain them in Rust Help blocks. They are collapsed by default to reduce distraction, clicking the header opens them. See the first Rust Help block at the end of this section.</p>
</div>
</div>
<p>The <code>Task</code> trait has several supertraits that we will need later in the tutorial to implement incrementality:</p>
<ul>
<li><code>Eq</code> and <code>Hash</code>: to check whether a task is equal to another one, and to create a hash of it, so we can use
a <code>HashMap</code> to get the output of a task if it is up-to-date.</li>
<li><code>Clone</code>: to create a clone of the task so that we can store it in the <code>HashMap</code> without having ownership of it.</li>
<li><code>Debug</code>: to format the task for debugging purposes.</li>
</ul>
<p>A <code>Task</code> has a single method <code>execute</code>, which takes a reference to itself (<code>&amp;self</code>), and a mutable reference to a context (<code>context: &amp;mut C</code>), and produces a value of type <code>Self::Output</code>.
Because <code>Context</code> is a trait, we use generics (<code>&lt;C: Context&lt;Self&gt;&gt;</code>) to have <code>execute</code> work for any <code>Context</code> implementation (ignoring the <code>Self</code> part for now).
The <code>execute</code> method takes self by reference such that a task can access its data, but not mutate it, as that could throw off incrementality by changing the hash/equality of the task.
Finally, the type of output of a task is defined by the <code>Output</code> associated type, and this type must implement <code>Clone</code>, <code>Eq</code>, and <code>Debug</code> for the same reason as <code>Task</code>.</p>
<p>The <code>Context</code> trait is generic over <code>Task</code>, allowing it to work with any task implementation.
It has a single method <code>require_task</code> for creating a dependency to a task and returning its up-to-date result.
It takes a mutable reference to itself, enabling dependency tracking and caching, which require mutation.
Because of this, the context reference passed to <code>Task::execute</code> is also mutable.</p>
<p>This <code>Task</code> and <code>Context</code> API mirrors the mutually recursive definition of task and context we discussed earlier, and forms the basis for the entire build system.</p>
<p>Build the project by running <code>cargo build</code>.
The output should look something like:</p>
<pre><code class="language-shell ">   Compiling pie v0.1.0 (/private/pie)
    Finished dev [unoptimized + debuginfo] target(s) in 0.11s
</code></pre>
<details id="admonition-rust-help" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="1_programmability/1_api/index.html#admonition-rust-help"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/book/ch00-00-introduction.html">The Rust Programming Language</a> is an introductory book about Rust. I will try to provide links to the book where possible.</p>
<p>Rust has a <a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">module system</a> for project organization. The <code>lib.rs</code> file is the &quot;main file&quot; of a library. Later on, we will be creating more modules in different files.</p>
<p>Things are imported into the current scope with <a href="https://doc.rust-lang.org/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><code>use</code></a> statements. We import the <code>Debug</code> and <code>Hash</code> traits from the standard library with two <code>use</code> statements. Use statements use <a href="https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">paths</a> to refer to nested things. We use <code>::</code> for nesting, similar to namespaces in C++.</p>
<p>Rust models the concept of <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">ownership</a> to enable memory safety without a garbage collector.
The <code>execute</code> method accepts a <em>reference</em> to the current type, indicated with <code>&amp;</code>: <code>&amp;self</code>. This reference is <em>immutable</em>, meaning that we can read data from it, but not mutate it. In Rust, things are immutable by default.
On the other hand, <code>execute</code> accepts a <em>mutable reference</em> to the context, indicated with <code>&amp;mut</code>: <code>context: &amp;mut C</code>, which does allow mutation.</p>
<p><a href="https://doc.rust-lang.org/book/ch10-02-traits.html">Traits</a> are the main mechanism for open extensibility in Rust. They are comparable to interfaces in class-oriented languages. We will implement a context and tasks in the next section.</p>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-supertraits-to-require-one-traits-functionality-within-another-trait">Supertraits</a> are a kind of inheritance. The <code>: Clone + Eq + Hash + Debug</code> part of the <code>Task</code> trait means that every <code>Task</code> implementation must also implement the <code>Clone</code>, <code>Eq</code>, <code>Hash</code>, and <code>Debug</code> traits. These traits are part of the standard library:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">Clone</a> for duplicating values.</li>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">Eq</a> for equality comparisons, along with <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">PartialEq</a>.</li>
<li><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html">Hash</a> for turning a value into a hash.</li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">Debug</a> for formatting values in a programmer-facing debugging context.</li>
</ul>
<p><code>Clone</code> and <code>Eq</code> are so common that they are part of the <a href="https://doc.rust-lang.org/std/prelude/index.html">Rust Prelude</a>, so we don't have to import those with <code>use</code> statements.</p>
<p><a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html">Methods</a> are functions that take a form of <code>self</code> as the first argument. This enables convenient object-like calling syntax: <code>context.require_task(&amp;task);</code>.</p>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types">Associated types</a> are a kind of placeholder type in a trait such that methods of traits can use that type. In <code>Task</code> this allows us to talk about the <code>Output</code> type of a task. In <code>Context</code> this allows us to refer to both the <code>Task</code> type <code>T</code> and its output type <code>T::Output</code>. The <code>::</code> syntax here is used to access associated types of traits.</p>
<p>The <code>Self</code> type in a trait is a built-in associated type that is a placeholder for the type that is implementing the trait.</p>
<p>The <code>Task</code> trait is defined with <code>pub</code> (public) <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html">visibility</a>, such that users of the library can implement it. Because <code>Task</code> uses <code>Context</code> in its public API, <code>Context</code> must also be public, even though we don't intend for users to implement their own <code>Context</code>.</p>
</div>
</details>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="1_programmability/1_api/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="1_programmability/1_api/../../gen/1_programmability/1_api/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-incremental-context"><a class="header" href="#non-incremental-context">Non-Incremental Context</a></h1>
<p>We set up the <code>Task</code> and <code>Context</code> API in such a way that we can implement incrementality.
However, incrementality is <em>hard</em>, so let's start with an extremely simple non-incremental <code>Context</code> implementation to get a feeling for the API.</p>
<h2 id="context-module"><a class="header" href="#context-module">Context module</a></h2>
<p>Since we will be implementing three different contexts in this tutorial, we will separate them in different modules.
Create the <code>context</code> module by adding a module to <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::fmt::Debug;
 use std::hash::Hash;

+pub mod context;
+
 /// A unit of computation in a programmatic incremental build system.
 pub trait Task: Clone + Eq + Hash + Debug {
   /// Type of output this task returns when executed.
   type Output: Clone + Eq + Debug;
   /// Execute the task, using `context` to specify dynamic dependencies, returning `Self::Output`.</code></pre>
<p>This is a diff over <code>pie/src/lib.rs</code> where lines with a green background are additions, lines with a red background are removals, and lines with a grey background are context on where to add/remove lines, similar to diffs on source code hubs like GitHub.</p>
<p>Create the <code>pie/src/context</code> directory, and in it, create the <code>pie/src/context/mod.rs</code> file with the following contents:</p>
<pre><code class="language-rust ">pub mod non_incremental;</code></pre>
<p>Both modules are public so that users of our library can access context implementations.</p>
<p>Create the <code>pie/src/context/non_incremental.rs</code> file, it will be empty for now.
Your project structure should now look like:</p>
<pre><code>pie
├── Cargo.toml
├── target
├── Cargo.lock
└── src
    ├── context
    │   ├── non_incremental.rs
    │   └── mod.rs
    └── lib.rs
</code></pre>
<p>Confirm your module structure is correct by building with <code>cargo build</code>.</p>
<details id="admonition-rust-help" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="1_programmability/2_non_incremental/index.html#admonition-rust-help"></a></p>
</summary>
<div>
<p>Modules are typically <a href="https://doc.rust-lang.org/book/ch07-05-separating-modules-into-different-files.html">separated into different files</a>.
Modules are declared with <code>mod context</code>. 
Then, the contents of a module are defined either by creating a sibling file with the same name: <code>context.rs</code>, or by creating a sibling directory with the same name, with a <code>mod.rs</code> file in it: <code>context/mod.rs</code>.
Use the latter if you intend to nest modules, otherwise use the former.</p>
<p>Like traits, modules also have <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html">visibility</a>.</p>
</div>
</details>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>Implement the non-incremental context in <code>pie/src/context/non_incremental.rs</code> by adding:</p>
<pre><code class="language-rust ">use crate::{Context, Task};

pub struct NonIncrementalContext;

impl&lt;T: Task&gt; Context&lt;T&gt; for NonIncrementalContext {
  fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output {
    task.execute(self)
  }
}</code></pre>
<p>This <code>NonIncrementalContext</code> is extremely simple: in <code>require_task</code> we unconditionally execute the task, and pass <code>self</code> along so the task we're calling can require additional tasks.
Let's write some tests to see if this does what we expect.</p>
<details id="admonition-rust-help-1" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="1_programmability/2_non_incremental/index.html#admonition-rust-help-1"></a></p>
</summary>
<div>
<p>In Rust, libraries are called <a href="https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html">crates</a>.
We import the <code>Context</code> and <code>Task</code> traits from the root of your crate (i.e., the <code>src/lib.rs</code> file) using <code>crate::</code> as a prefix.</p>
<p><a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html">Structs</a> are concrete types that can contain data through fields and implement traits, similar to classes in class-oriented languages.
Since we don't need any data in <code>NonIncrementalContext</code>, we define it as a <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#unit-like-structs-without-any-fields">unit-like struct</a>.</p>
<p><a href="https://doc.rust-lang.org/book/ch10-02-traits.html#implementing-a-trait-on-a-type">Traits are implemented for a type</a> with <code>impl Context for NonIncrementalContext { ... }</code>, where we then have to implement all methods and associated types of the trait.</p>
<p>The <code>Context</code> trait is generic over <code>Task</code>, so in the <code>impl</code> block we introduce a type parameter <code>T</code> with <code>impl&lt;T&gt;</code>, and use <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#using-trait-bounds-to-conditionally-implement-methods">trait bounds</a> as <code>impl&lt;T: Task&gt;</code> to declare that <code>T</code> must implement <code>Task</code>.</p>
<p>The last expression of a function – in this case <code>task.execute(self)</code> in <code>require_task</code> which is an expression because it does not end with <code>;</code> – is used as the return value.
We could also write that as <code>return task.execute(self);</code>, but that is more verbose.</p>
</div>
</details>
<h2 id="simple-test"><a class="header" href="#simple-test">Simple Test</a></h2>
<p>Add the following test to <code>pie/src/context/non_incremental.rs</code>:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use super::*;

  #[test]
  fn test_require_task_direct() {
    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
    struct ReturnHelloWorld;

    impl Task for ReturnHelloWorld {
      type Output = String;
      fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, _context: &amp;mut C) -&gt; Self::Output {
        &quot;Hello World!&quot;.to_string()
      }
    }

    let mut context = NonIncrementalContext;
    assert_eq!(&quot;Hello World!&quot;, context.require_task(&amp;ReturnHelloWorld));
  }
}</code></pre>
<p>In this test, we create a struct <code>ReturnHelloWorld</code> which is the &quot;hello world&quot; of the build system.
We implement <code>Task</code> for it, set its <code>Output</code> associated type to be <code>String</code>, and implement the <code>execute</code> method to just return <code>&quot;Hello World!&quot;</code>.
We derive the <code>Clone</code>, <code>Eq</code>, <code>Hash</code>, and <code>Debug</code> traits for <code>ReturnHelloWorld</code> as they are required for all <code>Task</code>
implementations.</p>
<p>We require the task with our context by creating a <code>NonIncrementalContext</code>, calling its <code>require_task</code> method, passing
in a reference to the task.
It returns the output of the task, which we test with <code>assert_eq!</code>.</p>
<p>Run the test by running <code>cargo test</code>.
The output should look something like:</p>
<pre><code class="language-shell ">   Compiling pie v0.1.0 (/private/pie)
    Finished test [unoptimized + debuginfo] target(s) in 0.31s
     Running unittests src/lib.rs (/private/pie/target/debug/deps/pie-a50f0f2aa4868d6a)

running 1 test
test context::non_incremental::test::test_require_task_direct ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests pie

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Which indicates that the test indeed succeeds!
You can experiment by returning a different string from <code>ReturnHelloWorld::execute</code> to see what a failed test looks like.</p>
<details id="admonition-rust-help-2" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="1_programmability/2_non_incremental/index.html#admonition-rust-help-2"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#the-tests-module-and-cfgtest">Unit tests</a> for a module 
are typically defined by creating a nested module named <code>test</code> with the <code>#[cfg(test)]</code> attribute applied to it. In that
<code>test</code> module, you apply <code>#[test]</code> to testing functions, which then get executed when you run <code>cargo test</code>.</p>
<p>The <code>#[cfg(...)]</code> attribute provides <a href="https://doc.rust-lang.org/reference/conditional-compilation.html">conditional compilation</a> for the item it is applied to. In this case, <code>#[cfg(test)]</code> ensures that the module is only compiled when we run <code>cargo test</code>.</p>
<p>We import all definitions from the parent module (i.e., the <code>non_incremental</code> module) into the <code>test</code> module with <code>use super::*;</code>.</p>
<p>In Rust, <a href="https://doc.rust-lang.org/reference/items.html">items</a> — that is, functions, structs, implementations, etc. — 
can be nested inside functions. We use that in <code>test_require_task_direct</code> to scope <code>ReturnHelloWorld</code> and its implementation
to the test function, so it can't clash with other test functions.</p>
<p>In <code>execute</code>, we use <code>_context</code> as the parameter name for the context, as the parameter is unused.
Unused parameters give a warning in Rust, unless it is prefixed by a <code>_</code>.</p>
<p><a href="https://doc.rust-lang.org/std/macro.assert_eq.html">assert_eq!</a> is a <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">macro</a> that checks if its two expressions are equal. 
If not, it <a href="https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html">panics</a>.
This macro is typically <a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html">used in tests</a> for assertions, as a panic marks a test as failed.</p>
</div>
</details>
<h2 id="test-with-multiple-tasks"><a class="header" href="#test-with-multiple-tasks">Test with Multiple Tasks</a></h2>
<p>Our first test only tests a single task that does not use the context, so let's write a test with two tasks where one requires the other to increase our test coverage.
Add the following test:</p>
<pre><code class="language-rust customdiff">     }

     let mut context = NonIncrementalContext;
     assert_eq!(&quot;Hello World!&quot;, context.require_task(&amp;ReturnHelloWorld));
   }
+
+  #[test]
+  fn test_require_task_problematic() {
+    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
+    struct ReturnHelloWorld;
+    impl Task for ReturnHelloWorld {
+      type Output = String;
+      fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, _context: &amp;mut C) -&gt; Self::Output {
+        &quot;Hello World!&quot;.to_string()
+      }
+    }
+
+    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
+    struct ToLowerCase;
+    impl Task for ToLowerCase {
+      type Output = String;
+      fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
+        context.require_task(&amp;ReturnHelloWorld).to_lowercase()
+      }
+    }
+
+    let mut context = NonIncrementalContext;
+    assert_eq!(&quot;hello world!&quot;, context.require_task(&amp;ToLowerCase));
+  }
 }</code></pre>
<p>We use the same <code>ReturnHelloWorld</code> task as before, but now also have a <code>ToLowerCase</code> task which requires <code>ReturnHelloWorld</code> and then turn its string lowercase.
However, due to the way we've set up the types between <code>Task</code> and <code>Context</code>, we will run into a problem.
Running <code>cargo test</code>, you should get these errors:</p>
<pre><code class="language-shell ">   Compiling pie v0.1.0 (/private/pie)
error[E0308]: mismatched types
  --&gt; src/context/non_incremental.rs:46:30
   |
46 |         context.require_task(&amp;ReturnHelloWorld).to_lowercase()
   |                 ------------ ^^^^^^^^^^^^^^^^^ expected `&amp;ToLowerCase`, found `&amp;ReturnHelloWorld`
   |                 |
   |                 arguments to this method are incorrect
   |
   = note: expected reference `&amp;ToLowerCase`
              found reference `&amp;non_incremental::test::test_require_task_problematic::ReturnHelloWorld`
note: method defined here
  --&gt; src/lib.rs:18:6
   |
18 |   fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
   |      ^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `pie` (lib test) due to previous error
</code></pre>
<p>The problem is that <code>execute</code> of <code>ToLowerCase</code> takes a <code>Context&lt;Self&gt;</code>, so in <code>impl Task for ToLowerCase</code> it takes a <code>Context&lt;ToLowerCase&gt;</code>, while we're trying to require <code>&amp;ReturnHelloWorld</code> through the context.
This doesn't work as <code>Context&lt;ToLowerCase&gt;::require_task</code> only takes a <code>&amp;ToLowerCase</code> as input.</p>
<p>We could change <code>execute</code> of <code>ToLowerCase</code> to take <code>Context&lt;ReturnHelloWorld&gt;</code>:</p>
<pre><code class="language-rust customdiff">
     #[derive(Clone, PartialEq, Eq, Hash, Debug)]
     struct ToLowerCase;
     impl Task for ToLowerCase {
       type Output = String;
-      fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
+      fn execute&lt;C: Context&lt;ReturnHelloWorld&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
         context.require_task(&amp;ReturnHelloWorld).to_lowercase()
       }
     }

     let mut context = NonIncrementalContext;</code></pre>
<p>But that is not allowed:</p>
<pre><code class="language-shell ">   Compiling pie v0.1.0 (/private/pie)
error[E0276]: impl has stricter requirements than trait
  --&gt; src/context/non_incremental.rs:45:21
   |
45 |       fn execute&lt;C: Context&lt;ReturnHelloWorld&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `C: Context&lt;non_incremental::test::test_require_task_problematic::ReturnHelloWorld&gt;`
   |
  ::: src/lib.rs:11:3
   |
11 |   fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
   |   --------------------------------------------------------------------- definition of `execute` from trait

For more information about this error, try `rustc --explain E0276`.
error: could not compile `pie` (lib test) due to previous error
</code></pre>
<p>This is because the <code>Task</code> trait defines <code>execute</code> to take a <code>Context&lt;Self&gt;</code>, thus every implementation of <code>Task</code> must adhere to this, so we can't solve it this way.</p>
<p>Effectively, due to the way we defined <code>Task</code> and <code>Context</code>, we can only use <em>a single task implementation</em>.
However, there is a good reason for this which will become more apparent once we implement incrementality.</p>
<details id="admonition-why-only-a-single-task-type" class="admonition info">
<summary class="admonition-title">
<p>Why only a single Task type?</p>
<p><a class="admonition-anchor-link" href="1_programmability/2_non_incremental/index.html#admonition-why-only-a-single-task-type"></a></p>
</summary>
<div>
<p>The gist of it is that an incremental context wants to build a <em>single dependency graph</em> and cache task outputs, so that we can figure out from the graph whether a task is affected by a change, and just return its output if it is not affected.
Therefore, a context implementation will maintain a <code>Store&lt;T&gt;</code>.</p>
<p>A <code>Context&lt;ReturnHelloWorld&gt;</code> and <code>Context&lt;ToLowerCase&gt;</code> would then have a <code>Store&lt;ReturnHelloWorld&gt;</code> and <code>Store&lt;ToLowerCase&gt;</code> respectively.
These two stores would then maintain two different dependency graphs, one where the nodes in the graph are <code>ReturnHelloWorld</code> and one where the nodes are <code>ToLowerCase</code>.
But that won't work, as we need a single dependency graph over all tasks to figure out what is affected.</p>
<p>There are several solutions to this problem.
For example, we could use <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">trait objects</a>.
However, this introduces a whole slew of problems because many traits that we use are not trait-object safe. 
<code>Clone</code> is not object safe because it requires <code>Sized</code>. 
<code>Eq</code> is not object safe because it uses <code>Self</code>. 
Serializing trait-objects is problematic.
There are workarounds for all these things, but it is not pretty and very complicated.</p>
<p>Another solution would be to encapsulate different tasks into a single type, using (procedural) macros to automatically generate this single task type.
This solution is more feasible, but still introduces a lot of complexity which is not worth it in this tutorial.</p>
<p>Therefore, in this tutorial we will keep it simple.</p>
</div>
</details>
<p>For now, we will solve this by just using a single task type which is an enumeration of the different possible tasks.
Replace the test with the following:</p>
<pre><code class="language-rust customdiff">     let mut context = NonIncrementalContext;
     assert_eq!(&quot;Hello World!&quot;, context.require_task(&amp;ReturnHelloWorld));
   }

-  #[test]
-  fn test_require_task_problematic() {
-    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
-    struct ReturnHelloWorld;
-    impl Task for ReturnHelloWorld {
-      type Output = String;
-      fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, _context: &amp;mut C) -&gt; Self::Output {
-        &quot;Hello World!&quot;.to_string()
-      }
-    }
-
-    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
-    struct ToLowerCase;
-    impl Task for ToLowerCase {
-      type Output = String;
-      fn execute&lt;C: Context&lt;ReturnHelloWorld&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
-        context.require_task(&amp;ReturnHelloWorld).to_lowercase()
-      }
-    }
-
-    let mut context = NonIncrementalContext;
-    assert_eq!(&quot;hello world!&quot;, context.require_task(&amp;ToLowerCase));
-  }
+  #[test]
+  fn test_require_task() {
+    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
+    enum Test {
+      ReturnHelloWorld,
+      ToLowerCase,
+    }
+
+    impl Task for Test {
+      type Output = String;
+      fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
+        match self {
+          Self::ReturnHelloWorld =&gt; &quot;Hello World!&quot;.to_string(),
+          Self::ToLowerCase =&gt; context.require_task(&amp;Self::ReturnHelloWorld).to_lowercase(),
+        }
+      }
+    }
+
+    let mut context = NonIncrementalContext;
+    assert_eq!(&quot;Hello World!&quot;, context.require_task(&amp;Test::ReturnHelloWorld));
+    assert_eq!(&quot;hello world!&quot;, context.require_task(&amp;Test::ToLowerCase));
+  }
 }</code></pre>
<p>Here, we instead define a single task <code>Test</code> which is an <code>enum</code> with two variants.
In its <code>Task</code> implementation, we match ourselves and return <code>&quot;Hello World!&quot;</code> when the variant is <code>ReturnHelloWorld</code>.
When the variant is <code>ReturnHelloWorld</code>, we require <code>&amp;Self::ReturnHelloWorld</code> through the context, which is now valid because it is an instance of <code>Test</code>, and turn its string lowercase and return that.
This now works due to only having a single task type.
Run the test with <code>cargo test</code> to confirm it is working.</p>
<details id="admonition-rust-help-3" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="1_programmability/2_non_incremental/index.html#admonition-rust-help-3"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html">Enums</a> define a type by a set of variants, similar to enums in other languages, sometimes called tagged unions in other languages.
The <code>match</code> expression matches the variant and dispatches based on that, similar to switch statements in other languages.</p>
</div>
</details>
<p>We have defined the API for the build system and implemented a non-incremental version of it.
We're now ready to start implementing an incremental context in the next chapter.</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="1_programmability/2_non_incremental/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="1_programmability/2_non_incremental/../../gen/1_programmability/2_non_incremental/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>In this chapter, we will implement an <em>incremental</em> build context.
An incremental context selectively executes tasks — only those that are affected by a change.
In other words, an incremental context executes the <em>minimum number of tasks</em> required to make all tasks up-to-date.</p>
<p>However, due to dynamic dependencies, this is not trivial.
We cannot first gather all tasks into a dependency tree and then topologically sort that, as dependencies are added and removed <em>while tasks are executing</em>.
To do incremental builds in the presence of dynamic dependencies, we need to check and execute affected tasks <em>one at a time, updating the dependency graph, while tasks are executing</em>.
To achieve this, we will employ a technique called <em>top-down incremental building</em>, where we start checking if a top (root) task needs to be executed, and recursively check whether dependent tasks should be executed until we reach the bottom (leaf) task(s), akin to a depth-first search.</p>
<p>Furthermore, build systems almost always interact with the file system in some way. 
For example, tasks read configuration and source files, or write intermediate and binary files.
Thus, a change in a file can affect a task that reads it, and executing a task can result in writing to new or existing files.
Therefore, we will also keep track of <em>file dependencies</em>.
Like task dependencies, file dependencies are also tracked dynamically while tasks are executing.</p>
<p>There are several ways to check if a file dependency is consistent (i.e., has not changed), such as checking the last modification date, or comparing a hash.
To make this configurable on a per-dependency basis, we will implement <em>stamps</em>.
A file stamp is just a value that is produced from a file, such as the modification date or hash, that is stored with the file dependency.
To check if a file dependency is consistent, we just stamp the file again and compare it with the stored stamp.</p>
<p>Similarly, we can employ stamps for task dependencies as well by stamping the output of a task.</p>
<p>To achieve incrementality, we will continue with these steps in the following sections:</p>
<ol>
<li>Extend <code>Context</code> with a method to <em>require a file</em>, enabling tasks to specify dynamic dependencies to files.</li>
<li>Implement <em>file stamps</em> and <em>task output stamps</em>, and extend <code>Context</code> with methods to select <em>stampers</em>, enabling tasks to specify when a dependency is consistent.</li>
<li>Implement <em>dynamic dependencies</em> and their <em>consistency checking</em>.</li>
<li>Implement a <em>dependency graph store</em> with methods to query and mutate the dependency graph. </li>
<li>Implement the <em>top-down incremental context</em> that incrementally executes tasks.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="requiring-files"><a class="header" href="#requiring-files">Requiring Files</a></h1>
<p>Since build systems frequently interact with files, and changes to files can affect tasks, we need to keep track of file dependencies.
Therefore, we will extend the <code>Context</code> API with methods to <em>require files</em>, enabling tasks to specify dynamic dependencies to files.</p>
<p>Add a method to the <code>Context</code> trait in <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::fmt::Debug;
+use std::fs::File;
 use std::hash::Hash;
+use std::io;
+use std::path::Path;

 pub mod context;

 /// A unit of computation in a programmatic incremental build system.
 pub trait Task: Clone + Eq + Hash + Debug {
   /// Type of output this task returns when executed.
   type Output: Clone + Eq + Debug;
   /// Execute the task, using `context` to specify dynamic dependencies, returning `Self::Output`.
   fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
 }

 /// Programmatic incremental build context, enabling tasks to create dynamic dependencies that context implementations 
 /// use for incremental execution.
 pub trait Context&lt;T: Task&gt; {
+  /// Requires file at given `path`, recording a dependency to it. Call this method *just before reading from the file*, 
+  /// so that the dependency corresponds to the data that you are reading. Returns:
+  /// - `Ok(Some(file))` if a file exists at given `path`, 
+  /// - `Ok(None)` if no file exists at given `path` (but a directory could exist at given `path`),
+  /// - `Err(e)` if there was an error getting the metadata for given `path`, or if there was an error opening the file. 
+  fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt;;
+
   /// Requires given `task`, recording a dependency and selectively executing it. Returns its up-to-date output.
   fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
 }</code></pre>
<p><code>require_file</code> is similar to requiring a task, but instead takes a <code>path</code> to a file or directory on the filesystem as input.
We use <code>AsRef&lt;Path&gt;</code> as the type for the path, so that we can pass anything in that can dereference to a path.
For example, <code>str</code> has an <code>AsRef&lt;Path&gt;</code> implementation, so we can just use <code>&quot;test.txt&quot;</code> as a path.</p>
<p>As an output, we return <code>Result&lt;Option&lt;File&gt;, io::Error&gt;</code>, with <code>File</code> being a handle to an open file.
The reason for this complicated type is:</p>
<ul>
<li>An incremental context will want to read the metadata (such as the last modified date) of the file, or create a hash over the file, to be able to detect changes. Because getting metadata or reading the file can fail, and we want to propagate this error, we return a <code>Result</code> with <code>io::Error</code> as the error type.</li>
<li>Tasks can create a dependency to a file that does not exist, and the existence of that file affects the task. For example, a task that prints true or false based on if a file exists. If the file does not exist (or it is a directory), we cannot open it, so we cannot return a <code>File</code>, hence we use <code>Option&lt;File&gt;</code> to return <code>None</code>.</li>
<li>Otherwise, we return <code>Ok(Some(file))</code> so that the task can read the opened file.</li>
</ul>
<details id="admonition-rust-help" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="2_incrementality/1_require_file/index.html#admonition-rust-help"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html">Recoverable error handling</a> in Rust is done with the <code>Result&lt;T, E&gt;</code> type, which can either be <code>Ok(t)</code> or <code>Err(e)</code>.
In contrast to many languages which use exceptions, throwing, and exception handling; Rust treats recoverable errors just as regular values.</p>
<p>Similarly, <a href="https://doc.rust-lang.org/std/option/">optional values</a> in Rust are defined using the <code>Option&lt;T&gt;</code> type, which can either be <code>Some(t)</code> or <code>None</code>.</p>
<p>Rust has many traits for converting values or references into others, which provides a lot of convenience in what would otherwise require a lot of explicit conversions.
<a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef&lt;T&gt;</code></a> is such a conversion trait, that can convert itself into <code>&amp;T</code>. 
Here, we use <code>AsRef&lt;Path&gt;</code> as a generic with a trait bound to support many different kinds of values to the <code>path</code> argument in <code>require_file</code>.
For example, we can call <code>context.require_file(&quot;test.txt&quot;)</code> because <code>str</code>, which is the type of string constants, <a href="https://doc.rust-lang.org/src/std/path.rs.html#3136-3141">implements <code>AsRef&lt;Path&gt;</code></a>.
You can also see this as a kind of method overloading, without having to provide concrete overloads for all supported types.</p>
</div>
</details>
<p>Now we need to implement this method for <code>NonIncrementalContext</code>.
However, because we will be performing similar file system operations in the incremental context as well, we will create some utility functions for this first.</p>
<p>Add the <code>fs</code> module to <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::hash::Hash;
 use std::io;
 use std::path::Path;

 pub mod context;
+mod fs;

 /// A unit of computation in a programmatic incremental build system.
 pub trait Task: Clone + Eq + Hash + Debug {
   /// Type of output this task returns when executed.
   type Output: Clone + Eq + Debug;
@@ -21,9 +22,8 @@
   /// so that the dependency corresponds to the data that you are reading. Returns:
   /// - `Ok(Some(file))` if a file exists at given `path`, 
   /// - `Ok(None)` if no file exists at given `path` (but a directory could exist at given `path`),
   /// - `Err(e)` if there was an error getting the metadata for given `path`, or if there was an error opening the file. 
   fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt;;
-
   /// Requires given `task`, recording a dependency and selectively executing it. Returns its up-to-date output.
   fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
 }</code></pre>
<p>Create file <code>pie/src/fs.rs</code> with:</p>
<pre><code class="language-rust ">use std::{fs, io};
use std::fs::{File, Metadata};
use std::path::Path;

/// Gets the metadata for given `path`, returning:
/// - `Ok(Some(metadata))` if a file or directory exists at given path,
/// - `Ok(None)` if no file or directory exists at given path,
/// - `Err(e)` if there was an error getting the metadata for given path.
pub fn metadata(path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Option&lt;Metadata&gt;, io::Error&gt; {
  match fs::metadata(path) {
    Err(e) if e.kind() == io::ErrorKind::NotFound =&gt; Ok(None),
    Err(e) =&gt; Err(e),
    Ok(m) =&gt; Ok(Some(m))
  }
}

/// Attempt to open file at given `path`, returning:
/// - `Ok(Some(file))` if the file exists at given path, 
/// - `Ok(None)` if no file exists at given path (but a directory could exist at given path),
/// - `Err(e)` if there was an error getting the metadata for given path, or if there was an error opening the file.
///
/// This function is necessary due to Windows returning an error when attempting to open a directory.
pub fn open_if_file(path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
  let file = match metadata(&amp;path)? {
    Some(metadata) if metadata.is_file() =&gt; Some(File::open(&amp;path)?),
    _ =&gt; None,
  };
  Ok(file)
}
</code></pre>
<p>The <code>metadata</code> function gets the filesystem metadata given a path, and <code>open_if_file</code> opens the file for given path.
The reason for these functions is that the standard library function <code>std::fs::metadata</code> treats non-existent files as an error, whereas we don't want to treat it as an error and just return <code>None</code>.
Furthermore, <code>open_if_file</code> works around an issue where opening a directory on Windows (and possibly other operating systems) is an error, where we want to treat it as <code>None</code> again.
The documentation comments explain the exact behaviour.</p>
<details id="admonition-rust-help-1" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="2_incrementality/1_require_file/index.html#admonition-rust-help-1"></a></p>
</summary>
<div>
<p>The <code>?</code> operator makes it easy to <a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">propgate errors</a>.
Because errors are just values in Rust, to propgate an error, you'd normally have to match each result and manually propagate the error.
The <code>r?</code> operator applied to a <code>Result</code> <code>r</code> does this for you, it basically desugars to something like <code>match r { Err(e) =&gt; return Err(e), _ =&gt; {} }</code>.</p>
<p>Comments with three forward slashes <code>///</code> are <a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments">documentation comments</a> that document the function/struct/enum/trait/etc. they are applied to.</p>
</div>
</details>
<p>We will write some tests to confirm the behaviour, but for that we need utilities to create temporary files and directories.
Furthermore, we will be writing more unit tests, integration tests, and even benchmarks in this tutorial, so we will set up these utilities in such a way that they are reachable by all these use cases.
The only way to do that in Rust right now, is to create a separate crate and have the <code>pie</code> crate depend on it.</p>
<p>And yes, we went from adding file dependencies, to creating file system utilities, to testing those file system utilities, to creating testing utilities, and now to making a crate for those testing utilities.
Sorry about that 😅, we will start unwinding this stack soon!</p>
<p>Next to the <code>pie</code> directory, create a directory named <code>dev_shared</code>.
Create the <code>dev_shared/Cargo.toml</code> file with the following contents:</p>
<pre><code class="language-toml ">[package]
name = &quot;dev_shared&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
tempfile = &quot;3&quot;
</code></pre>
<p>We've added the <code>tempfile</code> dependency here already, which is a crate that creates and automatically cleans up temporary files and directories.</p>
<details id="admonition-rust-help-2" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="2_incrementality/1_require_file/index.html#admonition-rust-help-2"></a></p>
</summary>
<div>
<p>We use other libraries (crates) by <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">specifying dependencies</a>.
Because basically every Rust library adheres to <a href="https://semver.org/">semantic versioning</a>, we can use <code>&quot;3&quot;</code> as a version requirement which indicates that we will use the most up-to-date <code>3.x.x</code> version.</p>
</div>
</details>
<p>Create the main library file <code>dev_shared/src/lib.rs</code>, with functions for creating temporary files and directories:</p>
<pre><code class="language-rust ">use std::io;

use tempfile::{NamedTempFile, TempDir};

/// Creates a new temporary file that gets cleaned up when dropped.
pub fn create_temp_file() -&gt; Result&lt;NamedTempFile, io::Error&gt; { NamedTempFile::new() }

/// Creates a new temporary directory that gets cleaned up when dropped.
pub fn create_temp_dir() -&gt; Result&lt;TempDir, io::Error&gt; { TempDir::new() }</code></pre>
<p>Your directory structure should now look like this:</p>
<pre><code>├── pie
│   ├── Cargo.toml
│   ├── target
│   ├── Cargo.lock
│   └── src
│       ├── context
│       │   ├── non_incremental.rs
│       │   └── mod.rs
│       ├── lib.rs
│       └── fs.rs
└── dev_shared
    ├── Cargo.toml
    └── src
        └── lib.rs
</code></pre>
<p>To access these utility functions in the <code>pie</code> crate, add a dependency to <code>dev_shared</code> in <code>pie/Cargo.toml</code> along with another create that will help testing:</p>
<pre><code class="language-toml customdiff "> [package]
 name = &quot;pie&quot;
 version = &quot;0.1.0&quot;
 edition = &quot;2021&quot;
+
+[dev-dependencies]
+dev_shared = { path = &quot;../dev_shared&quot; }
+assert_matches = &quot;1&quot;
</code></pre>
<p>We've also added the <a href="https://crates.io/crates/assert_matches">assert_matches</a> crate, which is a handy library for asserting that a value matches a pattern.
Note that these dependencies are added under <code>dev-dependencies</code>, indicating that these dependencies are only available when running tests, benchmarks, and examples.
Therefore, users of our library will not depend on these crates, which is good, because temporary file management and assertions are not necessary to users of the library.</p>
<p>Back to testing our filesystem utilities.
Add the following tests to <code>pie/src/fs.rs</code>:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use std::fs::remove_file;
  use std::io;

  use assert_matches::assert_matches;

  use dev_shared::{create_temp_dir, create_temp_file};

  use super::*;

  #[test]
  fn test_metadata_ok() -&gt; Result&lt;(), io::Error&gt; {
    let temp_file = create_temp_file()?;
    let metadata = metadata(temp_file)?;
    assert_matches!(metadata, Some(metadata) =&gt; {
      assert!(metadata.is_file());  
    });
    Ok(())
  }

  #[test]
  fn test_metadata_none() -&gt; Result&lt;(), io::Error&gt; {
    let temp_file = create_temp_file()?;
    remove_file(&amp;temp_file)?;
    let metadata = metadata(&amp;temp_file)?;
    assert!(metadata.is_none());
    Ok(())
  }

  #[test]
  fn test_open_if_file() -&gt; Result&lt;(), io::Error&gt; {
    let temp_file = create_temp_file()?;
    let file = open_if_file(&amp;temp_file)?;
    assert!(file.is_some());
    Ok(())
  }

  #[test]
  fn test_open_if_file_non_existent() -&gt; Result&lt;(), io::Error&gt; {
    let temp_file = create_temp_file()?;
    remove_file(&amp;temp_file)?;
    let file = open_if_file(&amp;temp_file)?;
    assert!(file.is_none());
    Ok(())
  }

  #[test]
  fn test_open_if_file_on_directory() -&gt; Result&lt;(), io::Error&gt; {
    let temp_dir = create_temp_dir()?;
    let file = open_if_file(temp_dir)?;
    assert!(file.is_none());
    Ok(())
  }
}</code></pre>
<p>We test whether the functions conform to the specified behaviour.
Unfortunately, we can't easily test when <code>metadata</code> and <code>open_if_file</code> should return an error, because we cannot disable read permissions on files via the Rust standard library.</p>
<p>We use our <code>create_temp_file</code> and <code>create_temp_dir</code> utility functions to create temporary files and directories.
The <code>tempfile</code> library takes care of deleting temporary files when they go out of scope (at the end of the test).</p>
<p>We use <code>assert_matches!</code> to assert that <code>metadata</code> is <code>Some(metadata)</code>, binding <code>metadata</code> in the <code> =&gt; { ... }</code> block in which we assert that the metadata describes a file.
We will use this macro more in future integration tests.</p>
<details id="admonition-rust-help-3" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="2_incrementality/1_require_file/index.html#admonition-rust-help-3"></a></p>
</summary>
<div>
<p>Tests can <a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html#using-resultt-e-in-tests">return <code>Result</code></a>.
When a test returns an <code>Err</code>, the test fails.
This allows us to write more concise tests using error propagation.</p>
</div>
</details>
<p>Now we are done unwinding our stack and have filesystem and testing utilities.
Make the non-incremental context compatible by changing <code>pie/src/context/non_incremental.rs</code>:</p>
<pre><code class="language-rust customdiff">+use std::fs::File;
+use std::io;
+use std::path::Path;
+
 use crate::{Context, Task};
+use crate::fs::open_if_file;

 pub struct NonIncrementalContext;

 impl&lt;T: Task&gt; Context&lt;T&gt; for NonIncrementalContext {
+  fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
+    open_if_file(&amp;path)
+  }
+
   fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output {
     task.execute(self)
   }
 }</code></pre>
<p>Since the non-incremental context does not track anything, we only try to open the file and return it, matching the contract in the documentation comment of the <code>Context::require_file</code> trait method.</p>
<p>Confirm everything works with <code>cargo test</code>.</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="2_incrementality/1_require_file/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="2_incrementality/1_require_file/../../gen/2_incrementality/1_require_file/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stamps"><a class="header" href="#stamps">Stamps</a></h1>
<p>To check whether we need to execute a task, we need to check the dependencies of that task to see if any of them are inconsistent.
To make this consistency checking configurable, we will use stamps.
A dependency is inconsistent if after stamping, the new stamp is different from the old stamp.
Therefore, we will implement a <code>FileStamper</code> that stamps files and produces a <code>FileStamp</code>, and an <code>OutputStamper</code> that stamps task outputs and produces an <code>OutputStamp</code>.</p>
<p>Add the <code>stamp</code> module to <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::fs::File;
 use std::hash::Hash;
 use std::io;
 use std::path::Path;

+pub mod stamp;
 pub mod context;
 mod fs;

 /// A unit of computation in a programmatic incremental build system.
 pub trait Task: Clone + Eq + Hash + Debug {
@@ -22,8 +23,9 @@
   /// so that the dependency corresponds to the data that you are reading. Returns:
   /// - `Ok(Some(file))` if a file exists at given `path`, 
   /// - `Ok(None)` if no file exists at given `path` (but a directory could exist at given `path`),
   /// - `Err(e)` if there was an error getting the metadata for given `path`, or if there was an error opening the file. 
   fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt;;
+
   /// Requires given `task`, recording a dependency and selectively executing it. Returns its up-to-date output.
   fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
 }</code></pre>
<p>This module is public as users of the library will construct stampers.</p>
<h2 id="file-stamps"><a class="header" href="#file-stamps">File stamps</a></h2>
<p>Create the <code>pie/src/stamp.rs</code> file and add:</p>
<pre><code class="language-rust ">use std::fmt::Debug;
use std::io;
use std::path::Path;
use std::time::SystemTime;

use crate::fs::metadata;

#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]
pub enum FileStamper {
  Exists,
  Modified,
}

impl FileStamper {
  pub fn stamp(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;FileStamp, io::Error&gt; {
    match self {
      FileStamper::Exists =&gt; {
        Ok(FileStamp::Exists(path.as_ref().try_exists()?))
      }
      FileStamper::Modified =&gt; {
        let Some(metadata) = metadata(path)? else {
          return Ok(FileStamp::Modified(None));
        };
        Ok(FileStamp::Modified(Some(metadata.modified()?)))
      }
    }
  }
}

#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]
pub enum FileStamp {
  Exists(bool),
  Modified(Option&lt;SystemTime&gt;),
}
</code></pre>
<p>We're implementing <code>FileStamper</code> as an enum for simplicity.</p>
<p>A <code>FileStamper</code> has a single method <code>stamp</code> which takes something that can be dereferenced to a path, and produces a <code>FileStamp</code> or an error if creating the stamp failed.
For now, we implement only two kinds of file stampers: <code>Exists</code> and <code>Modified</code>.
The <code>Exists</code> stamper just returns a boolean indicating whether a file exists.
It can be used to create a file dependency where a task behaves differently based on whether a file exists or not.
The <code>Modified</code> stamper returns the last modification date if the file exists, or <code>None</code> if the file does not exist.</p>
<p>We derive <code>Eq</code> for stamps so that we can compare them.
Equal (same) stamps indicate a consistent dependency, unequal (different) indicates inconsistent.
We also derive <code>Eq</code> for stampers, because the stamper of a dependency could change, making the dependency inconsistent.</p>
<h2 id="task-output-stamps"><a class="header" href="#task-output-stamps">Task output stamps</a></h2>
<p>We implement task output stampers in a similar way.
Add to <code>pie/src/stamp.rs</code>:</p>
<pre><code class="language-rust ">#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]
pub enum OutputStamper {
  Inconsequential,
  Equals,
}

impl OutputStamper {
  pub fn stamp&lt;O&gt;(&amp;self, output: O) -&gt; OutputStamp&lt;O&gt; {
    match self {
      OutputStamper::Inconsequential =&gt; OutputStamp::Inconsequential,
      OutputStamper::Equals =&gt; OutputStamp::Equals(output),
    }
  }
}

#[derive(Clone, Eq, PartialEq, Debug)]
pub enum OutputStamp&lt;O&gt; {
  Inconsequential,
  Equals(O),
}

impl&lt;O&gt; OutputStamp&lt;O&gt; {
  pub fn as_ref(&amp;self) -&gt; OutputStamp&lt;&amp;O&gt; {
    match self {
      OutputStamp::Inconsequential =&gt; OutputStamp::Inconsequential,
      OutputStamp::Equals(o) =&gt; OutputStamp::Equals(o),
    }
  }
}
</code></pre>
<p>The <code>Inconsequential</code> stamper simply ignores the output and always returns the same stamp (thus is always equal).
It can be used to create a task dependency where we are interested in some side effect of a task, but don't care about its output.
The <code>Equals</code> stamper simply wraps the output of a task, so the stamp is equal when the output is equal.</p>
<p>Output stamps are generic over the task output type <code>O</code>.</p>
<details id="admonition-trait-bounds-and-derive-macros" class="admonition info">
<summary class="admonition-title">
<p>Trait bounds and derive macros</p>
<p><a class="admonition-anchor-link" href="2_incrementality/2_stamp/index.html#admonition-trait-bounds-and-derive-macros"></a></p>
</summary>
<div>
<p>Because <code>O</code> is used in the enum, the <code>derive</code> attributes on <code>OutputStamp</code> create bounds over <code>O</code>.
Thus, <code>OutputStamp</code> is only <code>Clone</code> when <code>O</code> is <code>Clone</code>, <code>OutputStamp</code> is only <code>Eq</code> when <code>O</code> is <code>Eq</code>, and so forth.
Because we declared <code>Task::Output</code> with bound <code>Clone + Eq + Debug</code>, we can be sure that <code>OutputStamp</code> is always <code>Clone</code>, <code>Eq</code>, and <code>Debug</code>.</p>
</div>
</details>
<details id="admonition-user-defined-stamps" class="admonition info">
<summary class="admonition-title">
<p>User-defined stamps</p>
<p><a class="admonition-anchor-link" href="2_incrementality/2_stamp/index.html#admonition-user-defined-stamps"></a></p>
</summary>
<div>
<p><code>FileStamper</code> and <code>OutputStamper</code> could also be a trait which would allow users of the library to implement their own stampers.
For simplicity, we do not explore that option in this tutorial.
If you feel adventurous, you could try to implement this after you've finished the tutorial.
Do note that this introduces a lot of extra generics and trait bounds everywhere, which can be a bit cumbersome.</p>
</div>
</details>
<h2 id="tests"><a class="header" href="#tests">Tests</a></h2>
<p>Finally, we write some tests.
Add to <code>pie/src/stamp.rs</code>:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use std::fs::{remove_file, write};
  use std::io;

  use dev_shared::create_temp_file;

  use super::*;

  #[test]
  fn test_exists_file_stamper() -&gt; Result&lt;(), io::Error&gt; {
    let stamper = FileStamper::Exists;
    let temp_file = create_temp_file()?;
    let stamp = stamper.stamp(&amp;temp_file)?;
    assert_eq!(stamp, stamper.stamp(&amp;temp_file)?);

    remove_file(&amp;temp_file)?;
    assert_ne!(stamp, stamper.stamp(&amp;temp_file)?);

    Ok(())
  }

  #[test]
  fn test_modified_file_stamper() -&gt; Result&lt;(), io::Error&gt; {
    let stamper = FileStamper::Modified;
    let temp_file = create_temp_file()?;
    let stamp = stamper.stamp(&amp;temp_file)?;
    assert_eq!(stamp, stamper.stamp(&amp;temp_file)?);

    write(&amp;temp_file, format!(&quot;{:?}&quot;, stamp))?;
    let new_stamp = stamper.stamp(&amp;temp_file)?;
    assert_ne!(stamp, new_stamp);
    let stamp = new_stamp;

    remove_file(&amp;temp_file)?;
    assert_ne!(stamp, stamper.stamp(&amp;temp_file)?);

    Ok(())
  }

  #[test]
  fn test_inconsequential_output_stamper() {
    let stamper = OutputStamper::Inconsequential;
    let stamp = stamper.stamp(&amp;1);
    assert_eq!(stamp, stamper.stamp(&amp;1));
    assert_eq!(stamp, stamper.stamp(&amp;2));
  }

  #[test]
  fn test_equals_output_stamper() {
    let stamper = OutputStamper::Equals;
    let stamp = stamper.stamp(&amp;1);
    assert_eq!(stamp, stamper.stamp(&amp;1));
    assert_ne!(stamp, stamper.stamp(&amp;2));
  }
}</code></pre>
<p>We test file stamps by creating a stamp, changing the file, creating a new stamp, and then compare the stamps.
We test task output stamps by just passing a different output value to the <code>stamp</code> function, and then compare the stamps.</p>
<p>Run <code>cargo test</code> to confirm the stamp implementation.
If test <code>test_modified_file_stamper</code> fails, do continue to the next section, because we're going to fix it!</p>
<h2 id="testing-with-file-modified-time-correctly"><a class="header" href="#testing-with-file-modified-time-correctly">Testing with file modified time, correctly</a></h2>
<p>Unfortunately, these tests may fail on some operating systems (Linux and Windows in my testing), due to an imprecise file last modified timer.
What can happen is that we write to a file, making the OS update its modified time to <code>1000</code> (as an example, not a real timestamp), then very quickly write to the file again, making the OS update its modified time to <code>1000</code> again.
Then, our test will fail because the stamp didn't change even though we expect it to change.</p>
<p>This can happen with an imprecise timer that only increases once every millisecond (again, an example, not a real number) when we perform writes in between that millisecond.
Even worse, our test can be flaky, sometimes succeeding if we write in between those milliseconds, sometimes failing if we write within a millisecond.</p>
<p>To solve this, add a function to the filesystem testing utility crate.
Change <code>dev_shared/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff ">+use std::fs::{metadata, write};
 use std::io;
+use std::path::Path;
+use std::time::SystemTime;

 use tempfile::{NamedTempFile, TempDir};

 /// Creates a new temporary file that gets cleaned up when dropped.
 pub fn create_temp_file() -&gt; Result&lt;NamedTempFile, io::Error&gt; { NamedTempFile::new() }

 /// Creates a new temporary directory that gets cleaned up when dropped.
 pub fn create_temp_dir() -&gt; Result&lt;TempDir, io::Error&gt; { TempDir::new() }
+
+/// Keeps writing `contents` to file at `path` until its last modified time changes, then returns the modified time.
+/// This is required because some OSs have imprecise modified timers, where the file modified time does not change when 
+/// writing in quick succession.
+///
+/// # Errors
+///
+/// Returns an error when any file operation fails.
+pub fn write_until_modified(path: impl AsRef&lt;Path&gt;, contents: impl AsRef&lt;[u8]&gt;) -&gt; Result&lt;SystemTime, io::Error&gt; {
+  let path = path.as_ref();
+  let contents = contents.as_ref();
+  fn get_modified(path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;SystemTime, io::Error&gt; {
+    let modified = match metadata(path) {
+      Err(e) if e.kind() == io::ErrorKind::NotFound =&gt; SystemTime::UNIX_EPOCH,
+      Err(e) =&gt; Err(e)?,
+      Ok(m) =&gt; m.modified()?
+    };
+    Ok(modified)
+  }
+  let modified = get_modified(path)?;
+  loop {
+    write(path, contents)?;
+    if modified != get_modified(path)? { break; }
+  }
+  Ok(modified)
+}</code></pre>
<p>The <code>write_until_modified</code> function writes to the file, but ensures its modified time will change.
Now change the tests in <code>pie/src/stamp.rs</code> to use this function:</p>
<pre><code class="language-rust customdiff "> #[cfg(test)]
 mod test {
-  use std::fs::{remove_file, write};
+  use std::fs::remove_file;
   use std::io;

-  use dev_shared::create_temp_file;
+  use dev_shared::{create_temp_file, write_until_modified};

   use super::*;

   #[test]
   fn test_exists_file_stamper() -&gt; Result&lt;(), io::Error&gt; {
     let stamper = FileStamper::Exists;
     let temp_file = create_temp_file()?;
     let stamp = stamper.stamp(&amp;temp_file)?;
     assert_eq!(stamp, stamper.stamp(&amp;temp_file)?);

     remove_file(&amp;temp_file)?;
     assert_ne!(stamp, stamper.stamp(&amp;temp_file)?);

     Ok(())
   }

   #[test]
   fn test_modified_file_stamper() -&gt; Result&lt;(), io::Error&gt; {
     let stamper = FileStamper::Modified;
     let temp_file = create_temp_file()?;
     let stamp = stamper.stamp(&amp;temp_file)?;
     assert_eq!(stamp, stamper.stamp(&amp;temp_file)?);

-    write(&amp;temp_file, format!(&quot;{:?}&quot;, stamp))?;
+    // Write until file modified time changes. Required on some OSs due to imprecise modified timer causing the modified 
+    // stamp to be the same after fast consecutive writes.
+    write_until_modified(&amp;temp_file, format!(&quot;{:?}&quot;, stamp))?;
     let new_stamp = stamper.stamp(&amp;temp_file)?;
     assert_ne!(stamp, new_stamp);
     let stamp = new_stamp;

     remove_file(&amp;temp_file)?;
     assert_ne!(stamp, stamper.stamp(&amp;temp_file)?);

     Ok(())
   }

   #[test]
   fn test_inconsequential_output_stamper() {
     let stamper = OutputStamper::Inconsequential;
     let stamp = stamper.stamp(&amp;1);
     assert_eq!(stamp, stamper.stamp(&amp;1));
     assert_eq!(stamp, stamper.stamp(&amp;2));
   }

   #[test]
   fn test_equals_output_stamper() {</code></pre>
<p>Now we use <code>write_until_modified</code> to write to the file, ensuring its modified time will change, ensuring the stamp will change when it should.
Run <code>cargo test</code> to confirm the stamp implementation, which should succeed now.</p>
<h2 id="stamps-in-context"><a class="header" href="#stamps-in-context">Stamps in Context</a></h2>
<p>We now have a module dedicated to stamps.
However, stampers are constructed by users of the library that author tasks, and they need to pass in these stampers when creating dependencies.
Therefore, we need to update the <code>Context</code> trait to allow passing in these stampers.</p>
<p>Change <code>Context</code> in <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::fmt::Debug;
 use std::fs::File;
 use std::hash::Hash;
 use std::io;
 use std::path::Path;

+use stamp::{FileStamper, OutputStamper};
+
 pub mod stamp;
 pub mod context;
 mod fs;

 /// A unit of computation in a programmatic incremental build system.
 pub trait Task: Clone + Eq + Hash + Debug {
   /// Type of output this task returns when executed.
   type Output: Clone + Eq + Debug;
   /// Execute the task, using `context` to specify dynamic dependencies, returning `Self::Output`.
   fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
 }

 /// Programmatic incremental build context, enabling tasks to create dynamic dependencies that context implementations 
 /// use for incremental execution.
 pub trait Context&lt;T: Task&gt; {
-  /// Requires file at given `path`, recording a dependency to it. Call this method *just before reading from the file*, 
-  /// so that the dependency corresponds to the data that you are reading. Returns:
+  /// Requires file at given `path`, recording a dependency to it (using the default require file stamper). Call this 
+  /// method *just before reading from the file*, so that the dependency corresponds to the data that you are reading. 
+  /// Returns:
   /// - `Ok(Some(file))` if a file exists at given `path`, 
   /// - `Ok(None)` if no file exists at given `path` (but a directory could exist at given `path`),
-  /// - `Err(e)` if there was an error getting the metadata for given `path`, or if there was an error opening the file. 
-  fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt;;
+  /// - `Err(e)` if there was an error getting the metadata for given `path`, if there was an error opening the file, or 
+  ///   if there was an error stamping the file.
+  fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
+    self.require_file_with_stamper(path, self.default_require_file_stamper())
+  }
+  /// Requires file at given `path`, recording a dependency to it (using given `stamper`). Call this method 
+  /// *just before reading from the file*, so that the dependency corresponds to the data that you are reading. Returns:
+  /// - `Ok(Some(file))` if a file exists at given `path`, 
+  /// - `Ok(None)` if no file exists at given `path` (but a directory could exist at given `path`),
+  /// - `Err(e)` if there was an error getting the metadata for given `path`, if there was an error opening the file, or 
+  ///   if there was an error stamping the file.
+  fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt;;
+  /// Returns the default require file stamper.
+  fn default_require_file_stamper(&amp;self) -&gt; FileStamper { FileStamper::Modified }

   /// Requires given `task`, recording a dependency and selectively executing it. Returns its up-to-date output.
   fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
 }</code></pre>
<p>We add the <code>require_file_with_stamper</code> method which allow passing in a stamper.
We add a default implementation for <code>require_file</code> that passes in a default stamper.
The default is provided by <code>default_require_file_stamper</code> which can be overridden by context implementations.</p>
<p>Now apply the same to tasks, changing <code>Context</code> again in <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff">   ///   if there was an error stamping the file.
   fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt;;
   /// Returns the default require file stamper.
   fn default_require_file_stamper(&amp;self) -&gt; FileStamper { FileStamper::Modified }

-  /// Requires given `task`, recording a dependency and selectively executing it. Returns its up-to-date output.
-  fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
+  /// Requires given `task`, recording a dependency (using the default output stamper) and selectively executing it. 
+  /// Returns its up-to-date output.
+  fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output {
+    self.require_task_with_stamper(task, self.default_output_stamper())
+  }
+  /// Requires given `task`, recording a dependency (using given `stamper`) and selectively executing it. Returns its
+  /// up-to-date output.
+  fn require_task_with_stamper(&amp;mut self, task: &amp;T, stamper: OutputStamper) -&gt; T::Output;
+  /// Returns the default output stamper.
+  fn default_output_stamper(&amp;self) -&gt; OutputStamper { OutputStamper::Equals }
 }</code></pre>
<p>Update <code>NonIncrementalContext</code> in <code>src/context/non_incremental.rs</code> to implement the new methods:</p>
<pre><code class="language-rust customdiff"> use std::io;
 use std::path::Path;

 use crate::{Context, Task};
 use crate::fs::open_if_file;
+use crate::stamp::{FileStamper, OutputStamper};

 pub struct NonIncrementalContext;

 impl&lt;T: Task&gt; Context&lt;T&gt; for NonIncrementalContext {
-  fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
-    open_if_file(&amp;path)
+  fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, _stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
+    let file = open_if_file(&amp;path)?;
+    Ok(file)
   }

-  fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output {
+  fn require_task_with_stamper(&amp;mut self, task: &amp;T, _stamper: OutputStamper) -&gt; T::Output {
     task.execute(self)
   }
 }</code></pre>
<p>We just ignore the stampers in <code>NonIncrementalContext</code>, as they are only needed for incrementality.</p>
<p>Run <code>cargo test</code> to confirm everything still works.</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="2_incrementality/2_stamp/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="2_incrementality/2_stamp/../../gen/2_incrementality/2_stamp/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-dependencies"><a class="header" href="#dynamic-dependencies">Dynamic Dependencies</a></h1>
<p>Now that we've implemented stamps, we can implement dynamic dependencies and their consistency checking.
A dependency is inconsistent if after stamping, the new stamp is different from the old stamp.
Therefore, dependencies need to keep track of their stamper and their previous stamp.
To that end, we will implement the <code>FileDependency</code> and <code>TaskDependency</code> types with methods for consistency checking.
We will also implement a <code>Dependency</code> type that abstracts over <code>FileDependency</code> and <code>TaskDependency</code>, which we will need for the dependency graph implementation in the next chapter.</p>
<p>Add the <code>dependency</code> module to <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use stamp::{FileStamper, OutputStamper};

 pub mod stamp;
 pub mod context;
 mod fs;
+mod dependency;

 /// A unit of computation in a programmatic incremental build system.
 pub trait Task: Clone + Eq + Hash + Debug {
   /// Type of output this task returns when executed.
   type Output: Clone + Eq + Debug;</code></pre>
<p>This module is private, as users of the library should not construct dependencies.
They should only create dependencies (and choose stampers) via <code>Context</code> methods.</p>
<h2 id="file-dependencies"><a class="header" href="#file-dependencies">File dependencies</a></h2>
<p>Create the <code>pie/src/dependency.rs</code> file and add:</p>
<pre><code class="language-rust ">use std::fmt::Debug;
use std::fs::File;
use std::io;
use std::path::PathBuf;

use crate::{Context, Task};
use crate::fs::open_if_file;
use crate::stamp::{FileStamp, FileStamper, OutputStamp, OutputStamper};

#[derive(Clone, Eq, PartialEq, Debug)]
pub struct FileDependency {
  path: PathBuf,
  stamper: FileStamper,
  stamp: FileStamp,
}

impl FileDependency {
  /// Creates a new file dependency with `path` and `stamper`, returning:
  /// - `Ok(file_dependency)` normally,
  /// - `Err(e)` if stamping failed.
  #[allow(dead_code)]
  pub fn new(path: impl Into&lt;PathBuf&gt;, stamper: FileStamper) -&gt; Result&lt;Self, io::Error&gt; {
    let path = path.into();
    let stamp = stamper.stamp(&amp;path)?;
    let dependency = FileDependency { path, stamper, stamp };
    Ok(dependency)
  }
  /// Creates a new file dependency with `path` and `stamper`, returning:
  /// - `Ok((file_dependency, Some(file)))` if a file exists at given path,
  /// - `Ok((file_dependency, None))` if no file exists at given path (but a directory could exist at given path),
  /// - `Err(e)` if stamping or opening the file failed.
  pub fn new_with_file(path: impl Into&lt;PathBuf&gt;, stamper: FileStamper) -&gt; Result&lt;(Self, Option&lt;File&gt;), io::Error&gt; {
    let path = path.into();
    let stamp = stamper.stamp(&amp;path)?;
    let file = open_if_file(&amp;path)?;
    let dependency = FileDependency { path, stamper, stamp };
    Ok((dependency, file))
  }

  /// Returns the path of this dependency.
  #[allow(dead_code)]
  pub fn path(&amp;self) -&gt; &amp;PathBuf { &amp;self.path }
  /// Returns the stamper of this dependency.
  #[allow(dead_code)]
  pub fn stamper(&amp;self) -&gt; &amp;FileStamper { &amp;self.stamper }
  /// Returns the stamp of this dependency.
  #[allow(dead_code)]
  pub fn stamp(&amp;self) -&gt; &amp;FileStamp { &amp;self.stamp }

  /// Checks whether this file dependency is inconsistent, returning:
  /// - `Ok(Some(stamp))` if this dependency is inconsistent (with `stamp` being the new stamp of the dependency),
  /// - `Ok(None)` if this dependency is consistent,
  /// - `Err(e)` if there was an error checking this dependency for consistency.
  pub fn is_inconsistent(&amp;self) -&gt; Result&lt;Option&lt;FileStamp&gt;, io::Error&gt; {
    let new_stamp = self.stamper.stamp(&amp;self.path)?;
    if new_stamp == self.stamp {
      Ok(None)
    } else {
      Ok(Some(new_stamp))
    }
  }
}
</code></pre>
<p>A <code>FileDependency</code> stores the <code>path</code> the dependency is about, the <code>stamper</code> used to create a stamp for this dependency, and the <code>stamp</code> that was created at the time the file dependency was made.
The <code>FileDependency::new_with_file</code> function also returns the opened file if it exists, so that users of this function can read from the file without having to open it again.
We add getter methods to get parts of the file dependency without allowing mutation.
Since we will use those getter methods later, we annotate them with <code>#[allow(dead_code)]</code> to disable unused warnings.</p>
<p>A file dependency is inconsistent when the stored stamp is not equal to a stamp that we create at the time of checking, implemented in <code>FileDependency::is_inconsistent</code>.
For example, if we created a file dependency (with modified stamper) for a file that was modified yesterday, then modify the file, and then call <code>is_inconsistent</code> on the file dependency, it would return <code>Some(new_stamp)</code> indicating that the dependency is inconsistent.</p>
<p>We implement an <code>is_inconsistent</code> method here instead of an <code>is_consistent</code> method, so that we can return the changed stamp when the dependency is inconsistent, which we will use for debug logging purposes later.</p>
<p>Creating and checking a file dependency can fail due to file operations failing (for example, cannot access the file), so we propagate those errors.</p>
<h2 id="task-dependencies"><a class="header" href="#task-dependencies">Task dependencies</a></h2>
<p>Task dependencies are implemented in a similar way.
Add to <code>pie/src/dependency.rs</code>:</p>
<pre><code class="language-rust ">#[derive(Clone, Eq, PartialEq, Debug)]
pub struct TaskDependency&lt;T, O&gt; {
  task: T,
  stamper: OutputStamper,
  stamp: OutputStamp&lt;O&gt;,
}

impl&lt;T: Task&gt; TaskDependency&lt;T, T::Output&gt; {
  /// Creates a new `task` dependency with `stamper` and `output`.
  pub fn new(task: T, stamper: OutputStamper, output: T::Output) -&gt; Self {
    let stamp = stamper.stamp(output);
    Self { task, stamper, stamp }
  }

  /// Returns the task of this dependency.
  #[allow(dead_code)]
  pub fn task(&amp;self) -&gt; &amp;T { &amp;self.task }
  /// Returns the stamper of this dependency.
  #[allow(dead_code)]
  pub fn stamper(&amp;self) -&gt; &amp;OutputStamper { &amp;self.stamper }
  /// Returns the stamp of this dependency.
  #[allow(dead_code)]
  pub fn stamp(&amp;self) -&gt; &amp;OutputStamp&lt;T::Output&gt; { &amp;self.stamp }
  
  /// Checks whether this task dependency is inconsistent, returning:
  /// - `Some(stamp)` if this dependency is inconsistent (with `stamp` being the new stamp of the dependency),
  /// - `None` if this dependency is consistent.
  pub fn is_inconsistent&lt;C: Context&lt;T&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Option&lt;OutputStamp&lt;T::Output&gt;&gt; {
    let output = context.require_task(&amp;self.task);
    let new_stamp = self.stamper.stamp(output);
    if new_stamp == self.stamp {
      None
    } else {
      Some(new_stamp)
    }
  }
}
</code></pre>
<p>A <code>TaskDependency</code> stores the <code>task</code> the dependency is about, along with its <code>stamper</code> and <code>stamp</code> that is created when the dependency is created.
Task dependencies are generic over the type of tasks <code>T</code>, and their type of outputs <code>O</code>.
We also add immutable getters here.</p>
<details id="admonition-trait-bounds-on-structs" class="admonition info">
<summary class="admonition-title">
<p>Trait bounds on structs</p>
<p><a class="admonition-anchor-link" href="2_incrementality/3_dependency/index.html#admonition-trait-bounds-on-structs"></a></p>
</summary>
<div>
<p>We chose not to put a <code>Task</code> trait bound on <code>TaskDependency</code>, and instead put the bound on the impl.
There are several up and downsides that should be considered when making such a decision.</p>
<p>The main upside for putting the <code>Task</code> bound on the <code>TaskDependency</code> struct, is that we can leave out <code>O</code> and use <code>OutputStamp&lt;T::Output&gt;</code> as the type of the <code>stamp</code> field.
This cuts down a generic parameter, which reduces boilerplate.
The downside is that we need to then put the <code>Task</code> bound on every struct that uses <code>TaskDependency</code>, which increases boilerplate.</p>
<p>In this case, we chose not to put the trait bound on the struct to prevent that trait bound from bubbling up into other structs that use <code>TaskDependency</code>, as it would need to appear in almost every struct in the library.</p>
</div>
</details>
<p>A task dependency is inconsistent if, after recursively checking it, its stamp has changed, implemented in <code>TaskDependency::is_inconsistent</code>.
Usually, this will be using the <code>Equals</code> task output stamper, so a task dependency is usually inconsistent when the output of the task changes.
Because we need to recursively check the task, <code>TaskDependency::is_inconsistent</code> requires a context to be passed in.
Again, there is more mutual recursion here.</p>
<p>This recursive consistency checking is one of the core ideas that make programmatic incremental build systems possible.
But why is this so important? Why do we need recursive checking?
Well, we want our build system to be <em>sound</em>, meaning that we must execute <em>all</em> tasks that are affected by a change.
When we <em>do not execute</em> a task that <em>is affected by a change</em>, we are <em>unsound</em>, and introduce an <em>incrementality bug</em>! </p>
<p>Because of dynamic dependencies, a change in a leaf in the dependency tree may affect a task at the root.
For example, a compilation task depends on a task that reads a configuration file, which depends on the configuration file.
A change to a configuration file (leaf) affects a task that reads the configuration file, which in turn affects the compilation task (root).
Therefore, we need to recursively check the dependency tree in order to execute all tasks affected by changes.</p>
<p>A different way to think about this, is to think about the invariant of the dependency consistency checking.
The invariant is that a dependency is consistent if and only if the subtree of that dependency is consistent, and the dependency itself is consistent.
The easiest way to adhere to this invariant, is recursive checking.</p>
<p>A final note about recursive checking is that tasks can be executed during it, and executing task can lead to new dynamic dependencies.
However, recursive checking handles this without problems because these dependencies are created through the <code>Context</code>, which in turn will call <code>is_inconsistent</code> when needed.</p>
<h2 id="dependency-enum"><a class="header" href="#dependency-enum">Dependency enum</a></h2>
<p>Finally, we create a <code>Dependency</code> enum that abstracts over these two kinds of dependencies.
Add to <code>pie/src/dependency.rs</code>:</p>
<pre><code class="language-rust ">#[derive(Clone, Eq, PartialEq, Debug)]
pub enum Dependency&lt;T, O&gt; {
  RequireFile(FileDependency),
  RequireTask(TaskDependency&lt;T, O&gt;),
}

#[derive(Clone, Eq, PartialEq, Debug)]
pub enum InconsistentDependency&lt;O&gt; {
  File(FileStamp),
  Task(OutputStamp&lt;O&gt;),
}

impl&lt;T: Task&gt; Dependency&lt;T, T::Output&gt; {
  /// Checks whether this dependency is inconsistent, returning:
  /// - `Ok(Some(stamp))` if the dependency is inconsistent (with `stamp` being the new stamp of the dependency),
  /// - `Ok(None)` if the dependency is consistent,
  /// - `Err(e)` if there was an error checking the dependency for consistency.
  pub fn is_inconsistent&lt;C: Context&lt;T&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Result&lt;Option&lt;InconsistentDependency&lt;T::Output&gt;&gt;, io::Error&gt; {
    let option = match self {
      Dependency::RequireFile(d) =&gt; d.is_inconsistent()?
        .map(|s| InconsistentDependency::File(s)),
      Dependency::RequireTask(d) =&gt; d.is_inconsistent(context)
        .map(|s| InconsistentDependency::Task(s)),
    };
    Ok(option)
  }
}
</code></pre>
<p><code>Dependency</code> just merges the two kinds of dependencies and provides an <code>is_inconsistent</code> method that calls the corresponding method.
We return the changed stamp here as well for debug logging later.
We wrap the changed stamp in an <code>InconsistentDependency</code> enum, and map to the correct variant if there is an inconsistency.</p>
<p>Because <code>Dependency</code> can store a <code>TaskDependency</code>, we need to propagate the <code>T</code> and <code>O</code> generics.
Likewise, <code>InconsistentDependency</code> propagates the <code>O</code> generic for <code>OutputStamp</code>.</p>
<details id="admonition-user-defined-dependencies" class="admonition info">
<summary class="admonition-title">
<p>User-defined dependencies</p>
<p><a class="admonition-anchor-link" href="2_incrementality/3_dependency/index.html#admonition-user-defined-dependencies"></a></p>
</summary>
<div>
<p>Like with stampers, <code>Dependency</code> could also be a trait to allow users of the library to define their own dependencies.
However, as we will see later, these dynamic dependencies also require validation, and I am unsure how such a <code>Dependency</code> trait should look.
Therefore, we don't have an appendix on how to implement this.
But, if you have an idea on how to this nicely (after you've completed this tutorial), please get in touch!</p>
</div>
</details>
<h2 id="tests-1"><a class="header" href="#tests-1">Tests</a></h2>
<p>As usual, we write some tests to confirm the behaviour.
Add tests to <code>pie/src/dependency.rs</code>:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use std::fs::write;
  use std::io::{self, Read};

  use dev_shared::{create_temp_file, write_until_modified};

  use crate::context::non_incremental::NonIncrementalContext;

  use super::*;

  /// Task that reads file at given path and returns it contents as a string.
  #[derive(Clone, PartialEq, Eq, Hash, Debug)]
  struct ReadStringFromFile(PathBuf);

  impl Task for ReadStringFromFile {
    type Output = String;
    fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
      let mut string = String::new();
      let file = context.require_file(&amp;self.0).expect(&quot;failed to require file&quot;);
      if let Some(mut file) = file {
        file.read_to_string(&amp;mut string).expect(&quot;failed to read from file&quot;);
      };
      string
    }
  }

  #[test]
  fn test_file_dependency_consistency() -&gt; Result&lt;(), io::Error&gt; {
    let mut context = NonIncrementalContext;

    let temp_file = create_temp_file()?;
    write(&amp;temp_file, &quot;test1&quot;)?;

    let file_dependency = FileDependency::new(temp_file.path(), FileStamper::Modified)?;
    let dependency: Dependency&lt;ReadStringFromFile, String&gt; = Dependency::RequireFile(file_dependency.clone());
    assert!(file_dependency.is_inconsistent()?.is_none());
    assert!(dependency.is_inconsistent(&amp;mut context)?.is_none());

    // Change the file, changing the stamp the stamper will create next time, making the file dependency inconsistent.
    write_until_modified(&amp;temp_file, &quot;test2&quot;)?;
    assert!(file_dependency.is_inconsistent()?.is_some());
    assert!(dependency.is_inconsistent(&amp;mut context)?.is_some());

    Ok(())
  }

  #[test]
  fn test_task_dependency_consistency() -&gt; Result&lt;(), io::Error&gt; {
    let mut context = NonIncrementalContext;

    let temp_file = create_temp_file()?;
    write(&amp;temp_file, &quot;test1&quot;)?;
    let task = ReadStringFromFile(temp_file.path().to_path_buf());
    let output = context.require_task(&amp;task);

    let task_dependency = TaskDependency::new(task.clone(), OutputStamper::Equals, output);
    let dependency = Dependency::RequireTask(task_dependency.clone());
    assert!(task_dependency.is_inconsistent(&amp;mut context).is_none());
    assert!(dependency.is_inconsistent(&amp;mut context)?.is_none());

    // Change the file, causing the task to return a different output, changing the stamp the stamper will create next 
    // time, making the task dependency inconsistent.
    write_until_modified(&amp;temp_file, &quot;test2&quot;)?;
    assert!(task_dependency.is_inconsistent(&amp;mut context).is_some());
    assert!(dependency.is_inconsistent(&amp;mut context)?.is_some());

    Ok(())
  }
}</code></pre>
<p>We test a file dependency by asserting that <code>is_inconsistent</code> returns <code>Some</code> after changing the file.</p>
<p>Testing task dependencies requires a bit more work.
We create task <code>ReadStringFromFile</code> that reads a string from a file, and then returns that string as output.
We require the task to get its output (<code>&quot;test1&quot;</code>), and create a task dependency with it.
Then, we change the file and check consistency of the task dependency.
That recursively requires the task, the context will execute the task, and the task now returns (<code>&quot;test2&quot;</code>).
Since we use the <code>Equals</code> output stamper, and <code>&quot;test1&quot;</code> does not equal <code>&quot;test2&quot;</code>, the dependency is inconsistent and returns a stamp containing <code>&quot;test2&quot;</code>.</p>
<p>Note that we are both testing the specific dependencies (<code>FileDependency</code> and <code>TaskDependency</code>), and the general <code>Dependency</code>.</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="2_incrementality/3_dependency/index.html#admonition-note"></a></p>
</div>
<div>
<p>Normally, a task such as <code>ReadStringFromFile</code> shound return a <code>Result&lt;String, io::Error&gt;</code>, but for testing purposes we are just using panics with <code>expect</code>.</p>
<p>In the file dependency case, using <code>Dependency</code> requires an explicit type annotation because there is no task to infer the type from.
We just use <code>Dependency&lt;ReadStringFromFile, String&gt;</code> as the type, and this is fine even though we don't use <code>ReadStringFromFile</code> in that test, because the <code>Dependency::RequireFile</code> variant does not use those types.</p>
</div>
</div>
<p>Run <code>cargo test</code> to confirm everything still works.
You will get some warnings about unused things, but that is ok as we will use them in the next section.</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="2_incrementality/3_dependency/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="2_incrementality/3_dependency/../../gen/2_incrementality/3_dependency/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependency-graph-store"><a class="header" href="#dependency-graph-store">Dependency Graph Store</a></h1>
<p>To do incremental building, we need to keep track of all files, tasks, their dependencies, and task outputs, in a dependency graph.
This will be the responsibility of the <code>Store</code> data structure.
Context implementations will use methods on <code>Store</code> to query and mutate the dependency graph.
In other words, <code>Store</code> encapsulates the dependency graph.</p>
<p>However, writing a dependency graph data structure is outside of the scope of this tutorial, so we will be using the <code>pie_graph</code> library which we prepared exactly for this use case.
The graph from this library is a directed acyclic graph (DAG), meaning that edges are directed and there may be no cycles in edges, as that would prohibit topological orderings.</p>
<details id="admonition-graph-library" class="admonition info">
<summary class="admonition-title">
<p>Graph library</p>
<p><a class="admonition-anchor-link" href="2_incrementality/4_store/index.html#admonition-graph-library"></a></p>
</summary>
<div>
<p>The <code>pie_graph</code> library is a modified version of the great <a href="https://github.com/declanvk/incremental-topo/"><code>incremental-topo</code></a> library which implements incremental topological ordering: it keeps the topological ordering up-to-date incrementally while nodes and edges are added and removed.
That is exactly what we need, as dynamic dependencies prevents us from calculating the topological ordering in one go, and calculating the topological ordering after every task execution is prohibitively expensive.
The implementation in the <code>incremental-topo</code> library is based on a <a href="http://www.doc.ic.ac.uk/~phjk/Publications/DynamicTopoSortAlg-JEA-07.pdf">paper by D. J. Pearce and P. H. J. Kelly</a> that describes several dynamic topological sort algorithms for directed acyclic graphs.</p>
</div>
</details>
<p>Add the <code>pie_graph</code> dependency to <code>pie/Cargo.toml</code>:</p>
<pre><code class="language-rust customdiff"> [package]
 name = &quot;pie&quot;
 version = &quot;0.1.0&quot;
 edition = &quot;2021&quot;

+[dependencies]
+pie_graph = &quot;0.0.1&quot;
+
 [dev-dependencies]
 dev_shared = { path = &quot;../dev_shared&quot; }
 assert_matches = &quot;1&quot;</code></pre>
<h2 id="store-basics"><a class="header" href="#store-basics">Store basics</a></h2>
<p>Add the <code>store</code> module to <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff">
 pub mod stamp;
 pub mod context;
 mod fs;
 mod dependency;
+mod store;

 /// A unit of computation in a programmatic incremental build system.
 pub trait Task: Clone + Eq + Hash + Debug {
   /// Type of output this task returns when executed.
   type Output: Clone + Eq + Debug;</code></pre>
<p>This module is private, as users of the library should not interact with the store.
Only <code>Context</code> implementations will use the store.</p>
<p>Create the <code>pie/src/store.rs</code> file and add the following to get started:</p>
<pre><code class="language-rust ">use std::path::{Path, PathBuf};

use pie_graph::{DAG, Node};

use crate::dependency::{Dependency, FileDependency, TaskDependency};
use crate::Task;

/// Stores files and tasks, and their dependencies, in a DAG (directed acyclic graph). Provides operations to mutate
/// and query this graph.
pub struct Store&lt;T, O&gt; {
  graph: DAG&lt;NodeData&lt;T, O&gt;, Dependency&lt;T, O&gt;&gt;,
}

#[derive(Debug)]
enum NodeData&lt;T, O&gt; {
  File(PathBuf),
  Task {
    task: T,
    output: Option&lt;O&gt;,
  },
}

impl&lt;T: Task&gt; Default for Store&lt;T, T::Output&gt; {
  fn default() -&gt; Self {
    Self {
      graph: DAG::default(),
    }
  }
}
</code></pre>
<p>The <code>Store</code> is generic over tasks <code>T</code> and their outputs <code>O</code>, like we have done before with <code>Dependency</code>.</p>
<p>The <code>DAG</code> type from <code>pie_graph</code> represents a DAG with nodes and edges, and data attached to those nodes and edges.
The nodes in our graph are either files or tasks, and the edges are dependencies.</p>
<p>The first generic argument to <code>DAG</code> is the type of data to attach to nodes, which is <code>NodeData&lt;T, O&gt;</code> in our case.
Because nodes can be files or tasks, <code>NodeData&lt;T, O&gt;</code> enumerates these, storing the path for files, and the task along with its output for tasks.
We store file paths as <code>PathBuf</code>, which is the owned version of <code>Path</code> (similar to <code>String</code> being the owned version of <code>str</code>).
The task output is stored as <code>Option&lt;O&gt;</code> because we can add a task to the graph without having executed it, so we don't have its output yet.</p>
<p>The second argument is the type of data to attach to edges, which is <code>Dependency&lt;T, O&gt;</code>, using the <code>Dependency</code> enum we defined earlier.</p>
<p>We implement <code>Default</code> for the store to initialize it.</p>
<details id="admonition-deriving-default" class="admonition info">
<summary class="admonition-title">
<p>Deriving default</p>
<p><a class="admonition-anchor-link" href="2_incrementality/4_store/index.html#admonition-deriving-default"></a></p>
</summary>
<div>
<p>We cannot derive this <code>Default</code> implementation even though it seems we should be able to, because the derived implementation will require <code>T</code> and <code>O</code> to be <code>Default</code>, and this is not always the case.
This is because the <code>Default</code> derive macro is conservative and adds a <code>: Default</code> bound to <em>every</em> generic argument in the <code>Default</code> trait implementation, and there is no way to disable this behaviour.
Therefore, we implement <code>Default</code> ourselves.</p>
<p>There are several crates that have more configurable derive macros for these things, but adding an extra dependency to generate a few lines of code is not worth the extra compilation time, so we just implement it manually here.</p>
</div>
</details>
<h2 id="graph-nodes"><a class="header" href="#graph-nodes">Graph nodes</a></h2>
<p>A node in <code>DAG</code> is represented by a <code>Node</code>, which is a transparent identifier (sometimes called a <a href="https://en.wikipedia.org/wiki/Handle_(computing)">handle</a>) that points to the node and its data.
We can create nodes in the graph, and then query attached data (<code>NodeData</code>) given a node.
So <code>DAG</code> allows us to go from <code>Node</code> to a <code>PathBuf</code> and task <code>T</code> through attached <code>NodeData</code>.</p>
<p>However, we want each unique file and task to be represented by a single unique node in the graph.
We need this for incrementality so that if the build system encounters the same task twice, we can find the corresponding task node in the graph the second time, check if it is consistent, and return its output if it is.</p>
<p>To ensure unique nodes, we need to maintain the reverse mapping from <code>PathBuf</code> and <code>T</code> to <code>Node</code> ourselves, which we will do with <code>HashMap</code>s.
This is also the reason for the <code>Eq</code> and <code>Hash</code> trait bounds on the <code>Task</code> trait, so we can use them as keys in <code>HashMap</code>s.</p>
<p>Change <code>pie/src/store.rs</code> to add hash maps to map between these things:</p>
<pre><code class="language-rust customdiff">+use std::collections::HashMap;
 use std::path::{Path, PathBuf};

 use pie_graph::{DAG, Node};

 use crate::dependency::{Dependency, FileDependency, TaskDependency};
 use crate::Task;

 /// Stores files and tasks, and their dependencies, in a DAG (directed acyclic graph). Provides operations to mutate
 /// and query this graph.
 pub struct Store&lt;T, O&gt; {
   graph: DAG&lt;NodeData&lt;T, O&gt;, Dependency&lt;T, O&gt;&gt;,
+  file_to_node: HashMap&lt;PathBuf, Node&gt;,
+  task_to_node: HashMap&lt;T, Node&gt;,
 }

 #[derive(Debug)]
 enum NodeData&lt;T, O&gt; {
   File(PathBuf),
   Task {
     task: T,
     output: Option&lt;O&gt;,
   },
 }

 impl&lt;T: Task&gt; Default for Store&lt;T, T::Output&gt; {
   fn default() -&gt; Self {
     Self {
       graph: DAG::default(),
+      file_to_node: HashMap::default(),
+      task_to_node: HashMap::default(),
     }
   }
 }
</code></pre>
<p>To prevent accidentally using a file node as a task node, and vice versa, change <code>pie/src/store.rs</code> to add specific types of nodes:</p>
<pre><code class="language-rust customdiff">+use std::borrow::Borrow;
 use std::collections::HashMap;
 use std::path::{Path, PathBuf};

 use pie_graph::{DAG, Node};

 use crate::dependency::{Dependency, FileDependency, TaskDependency};
 use crate::Task;

 /// Stores files and tasks, and their dependencies, in a DAG (directed acyclic graph). Provides operations to mutate
 /// and query this graph.
 pub struct Store&lt;T, O&gt; {
   graph: DAG&lt;NodeData&lt;T, O&gt;, Dependency&lt;T, O&gt;&gt;,
-  file_to_node: HashMap&lt;PathBuf, Node&gt;,
-  task_to_node: HashMap&lt;T, Node&gt;,
+  file_to_node: HashMap&lt;PathBuf, FileNode&gt;,
+  task_to_node: HashMap&lt;T, TaskNode&gt;,
 }

 #[derive(Debug)]
 enum NodeData&lt;T, O&gt; {
   File(PathBuf),
   Task {
     task: T,
     output: Option&lt;O&gt;,
   },
 }

+/// Newtype for file `Node`s.
+#[repr(transparent)]
+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
+pub struct FileNode(Node);
+
+impl Borrow&lt;Node&gt; for &amp;FileNode {
+  fn borrow(&amp;self) -&gt; &amp;Node { &amp;self.0 }
+}
+
+/// Newtype for task `Node`s.
+#[repr(transparent)]
+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
+pub struct TaskNode(Node);
+
+impl Borrow&lt;Node&gt; for &amp;TaskNode {
+  fn borrow(&amp;self) -&gt; &amp;Node { &amp;self.0 }
+}
+
 impl&lt;T: Task&gt; Default for Store&lt;T, T::Output&gt; {
   fn default() -&gt; Self {
     Self {
       graph: DAG::default(),
       file_to_node: HashMap::default(),
       task_to_node: HashMap::default(),
     }
   }
 }
</code></pre>
<p>The <code>FileNode</code> and <code>TaskNode</code> types are <a href="https://rust-unofficial.github.io/patterns/patterns/behavioural/newtype.html">newtypes</a> that wrap a <code>Node</code> into a specific type of node.
The <code>Borrow</code> implementations will make subsequent code a bit more concise by automatically converting <code>&amp;FileNode</code> and <code>&amp;TaskNode</code>s to <code>&amp;Node</code>s.</p>
<details id="admonition-newtypes" class="admonition info">
<summary class="admonition-title">
<p>Newtypes</p>
<p><a class="admonition-anchor-link" href="2_incrementality/4_store/index.html#admonition-newtypes"></a></p>
</summary>
<div>
<p>Because the <code>Node</code>s inside the newtypes are not public, it is not possible to construct a <code>FileNode</code> or <code>TaskNode</code> outside of this module.
Therefore, if we only accept and create <code>FileNode</code> and <code>TaskNode</code> in the <code>Store</code> API, it is not possible to use the wrong kind of node.</p>
<p>The <code>Borrow</code> implementation does leak outside of this module, but not outside of this crate (library).
This is because the visibility of a trait implementation is the intersection of the visibilities of the trait and type it is implemented on.
<code>Borrow</code> is public, but <code>FileNode</code> and <code>TaskNode</code> are only public within this crate.
Thefore, modules of this crate can extract the <code>Node</code> out of <code>FileNode</code> and <code>TaskNode</code>.
However, that <code>Node</code> cannot be used to construct a <code>FileNode</code> or <code>TaskNode</code>, so it is not a problem.</p>
</div>
</details>
<p>Now we will add methods create nodes and to query their attached data.
Add the following code to <code>pie/src/store.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;T: Task&gt; Store&lt;T, T::Output&gt; {
  /// Gets the file node for `path`, or creates a file node by adding it to the dependency graph.
  pub fn get_or_create_file_node(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; FileNode {
    let path = path.as_ref();
    if let Some(file_node) = self.file_to_node.get(path) {
      *file_node
    } else {
      let node = self.graph.add_node(NodeData::File(path.to_path_buf()));
      let node = FileNode(node);
      self.file_to_node.insert(path.to_path_buf(), node);
      node
    }
  }
  /// Gets the path for `node`. 
  ///
  /// # Panics
  ///
  /// Panics if `node` was not found in the dependency graph.
  #[allow(dead_code)]
  pub fn get_file_path(&amp;self, node: &amp;FileNode) -&gt; &amp;PathBuf {
    let Some(NodeData::File(path)) = self.graph.get_node_data(node) else {
      panic!(&quot;BUG: node {:?} was not found in the dependency graph&quot;, node);
    };
    path
  }
  
  /// Gets the task node for `task`, or creates a task node by adding it to the dependency graph.
  pub fn get_or_create_task_node(&amp;mut self, task: &amp;T) -&gt; TaskNode {
    if let Some(node) = self.task_to_node.get(task) {
      *node
    } else {
      let node = self.graph.add_node(NodeData::Task {
        task: task.clone(),
        output: None,
      });
      let node = TaskNode(node);
      self.task_to_node.insert(task.clone(), node);
      node
    }
  }
  /// Gets the task for `node`. 
  ///
  /// # Panics
  ///
  /// Panics if `node` was not found in the dependency graph.
  pub fn get_task(&amp;self, node: &amp;TaskNode) -&gt; &amp;T {
    let Some(NodeData::Task { task, .. }) = self.graph.get_node_data(node) else {
      panic!(&quot;BUG: node {:?} was not found in the dependency graph&quot;, node);
    };
    task
  }
}
</code></pre>
<p>The <code>get_or_create_file_node</code> method creates file nodes.
When we want to go from a file path (using <code>impl AsRef&lt;Path&gt;</code>) to a <code>FileNode</code>, either we have already added this file path to the graph and want to get the <code>FileNode</code> for it, or we have not yet added it to the graph yet and should add it.
The former is handled by the if branch in <code>get_or_create_file_node</code>, where we just retrieve the <code>FileNode</code> from the <code>file_to_node</code> hash map.
The latter is handled by the else branch where we add the node to the graph with <code>graph.add_node</code> which attaches the <code>NodeData::File</code> data to the node, and then returns a <code>FileNode</code> which we insert into the <code>file_to_node</code> map.</p>
<p>The <code>get_file_path</code> method does the inverse.
We get the attached data given a node, and extract the file path from it.</p>
<p>Note that we are using <code>panic!</code> here to indicate that invalid usage of this method is an <em>unrecoverable programming error</em> that should not occur.
Returning an <code>Option&lt;&amp;PathBuf&gt;</code> makes no sense here, as the caller of this method has no way to recover from this.
Because this is not an end-user-facing API (<code>store</code> module is private), we control all the calls to this method, and thus we are responsible for using these methods in a valid way. 
Therefore, when we call these methods, we should document why it is valid (if this is not immediately obvious), and we need to test whether we really use it in a valid way.</p>
<p>We're also documenting the panics in a <code># Panics</code> section in the documentation comment, as is common practice in Rust.</p>
<details id="admonition-triggering-these-panics" class="admonition info">
<summary class="admonition-title">
<p>Triggering these panics</p>
<p><a class="admonition-anchor-link" href="2_incrementality/4_store/index.html#admonition-triggering-these-panics"></a></p>
</summary>
<div>
<p>Because only <code>Store</code> can create <code>FileNode</code>s and <code>TaskNode</code>s, and all methods only take these values as inputs, these panics will not happen under normal usage.
The only way to trigger these panics (in safe Rust) would be to create two stores, and use the nodes from one store in another.
However, since this is a private module, we just need to make sure that we don't do that.</p>
<p>There are some tricks to prevent even this kind of invalid usage.
For example, the <a href="https://docs.rs/generativity/latest/generativity/">generativity</a> crate generates unique identifiers based on lifetimes.
However, that is a bit overkill, especially for an internal API, so we won't be using that.</p>
</div>
</details>
<p>We implement similar methods for task nodes in <code>get_or_create_task_node</code> and <code>get_task</code>.</p>
<h2 id="task-outputs"><a class="header" href="#task-outputs">Task outputs</a></h2>
<p>When we do not need to execute a task because it is consistent, we still need to return its output.
Therefore, we store the task output in <code>NodeData::Task</code> and add methods to query and manipulate task outputs.
Add the following code to <code>pie/src/store.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;T: Task&gt; Store&lt;T, T::Output&gt; {
  /// Checks whether task `node` has an output. Returns `false` if `node` does not have an output. 
  ///
  /// # Panics
  ///
  /// Panics if `node` was not found in the dependency graph.
  pub fn task_has_output(&amp;self, node: &amp;TaskNode) -&gt; bool {
    let Some(NodeData::Task { output, .. }) = self.graph.get_node_data(node) else {
      panic!(&quot;BUG: node {:?} was not found in the dependency graph&quot;, node);
    };
    output.is_some()
  }
  /// Gets the output for task `node`. 
  ///
  /// # Panics
  ///
  /// Panics if `node` was not found in the dependency graph, or if the task has no output.
  pub fn get_task_output(&amp;self, node: &amp;TaskNode) -&gt; &amp;T::Output {
    let Some(NodeData::Task { output: Some(output), .. }) = self.graph.get_node_data(node) else {
      panic!(&quot;BUG: node {:?} was not found in the dependency graph, or does not have an output&quot;, node);
    };
    output
  }
  /// Sets the output for task `node` to `new_output`.
  ///
  /// # Panics
  ///
  /// Panics if task `node` was not found in the dependency graph.
  pub fn set_task_output(&amp;mut self, node: &amp;TaskNode, new_output: T::Output) {
    let Some(NodeData::Task { output, .. }) = self.graph.get_node_data_mut(node) else {
      panic!(&quot;BUG: node {:?} was not found in the dependency graph&quot;, node);
    };
    output.replace(new_output);
  }
}
</code></pre>
<p>The <code>task_has_output</code>, <code>get_task_output</code>, and <code>set_task_output</code> methods manipulate task outputs in <code>NodeData::Task</code>.</p>
<p>Again, we are using panics here to indicate unrecoverable programming errors.</p>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>Now we need methods to query and manipulate dependencies.
The edges in the graph are dependencies between tasks and files.
Tasks can depend on other tasks and files, but there are no dependencies between files.
An edge does not have its own dedicated representation, and is simply represented by two nodes: the source node and the destination node of the edge.</p>
<p>Add the following code to <code>pie/src/store.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;T: Task&gt; Store&lt;T, T::Output&gt; {
  /// Get all dependencies of task `src`. 
  ///
  /// # Panics
  ///
  /// Panics in development builds if `src` was not found in the dependency graph.
  pub fn get_dependencies_of_task&lt;'a&gt;(&amp;'a self, src: &amp;'a TaskNode) -&gt; impl Iterator&lt;Item=&amp;'a Dependency&lt;T, T::Output&gt;&gt; + 'a {
    debug_assert!(self.graph.contains_node(src), &quot;BUG: node {:?} was not found in the dependency graph&quot;, src);
    self.graph.get_outgoing_edge_data(src)
  }
  /// Add a file require `dependency` from task `src` to file `dst`.
  ///
  /// # Panics
  ///
  /// Panics if `src` or `dst` were not found in the dependency graph, or if a cycle is created by adding this dependency.
  pub fn add_file_require_dependency(&amp;mut self, src: &amp;TaskNode, dst: &amp;FileNode, dependency: FileDependency) {
    match self.graph.add_edge(src, dst, Dependency::RequireFile(dependency)) {
      Err(pie_graph::Error::NodeMissing) =&gt; panic!(&quot;BUG: source node {:?} or destination node {:?} was not found in the dependency graph&quot;, src, dst),
      Err(pie_graph::Error::CycleDetected) =&gt; panic!(&quot;BUG: cycle detected when adding file dependency from {:?} to {:?}&quot;, src, dst),
      _ =&gt; {},
    }
  }
  /// Adds a task require `dependency` from task `src` to task `dst`.
  ///
  /// # Errors
  ///
  /// Returns `Err(())` if adding this dependency to the graph creates a cycle.
  ///
  /// # Panics
  ///
  /// Panics if `src` or `dst` were not found in the dependency graph.
  pub fn add_task_require_dependency(&amp;mut self, src: &amp;TaskNode, dst: &amp;TaskNode, dependency: TaskDependency&lt;T, T::Output&gt;) -&gt; Result&lt;(), ()&gt; {
    match self.graph.add_edge(src, dst, Dependency::RequireTask(dependency)) {
      Err(pie_graph::Error::NodeMissing) =&gt; panic!(&quot;BUG: source node {:?} or destination node {:?} was not found in the dependency graph&quot;, src, dst),
      Err(pie_graph::Error::CycleDetected) =&gt; Err(()),
      _ =&gt; Ok(()),
    }
  }
}
</code></pre>
<p>The <code>get_dependencies_of_task</code> method gets the dependencies (edge data of outgoing edges) of a task, and returns it as an iterator (which is empty if task has no dependencies).
This method needs explicit lifetime annotations due to the signature of <code>get_outgoing_edge_data</code> and the way we return an iterator using <code>impl Iterator&lt;...</code>.
We're using <code>debug_assert!</code> here to trigger a panic indicating an unrecoverable programming error only in development mode, because this check is too expensive to run in release (optimized) mode.</p>
<p>The <code>add_file_require_dependency</code> method adds a file dependency.
Adding an edge to the graph can result in cycles, which are not allowed in a directed <em>acyclic</em> graph (DAG).
Therefore, <code>graph.add_edge</code> can return an <code>Err</code> indicating that there is a cycle.
In case of files, this cannot happen because files do not have outgoing dependencies, and the API enforces this by never taking a <code>FileNode</code> as a source (<code>src</code>) of an edge.</p>
<p>Tasks can depend on other tasks, so they can create cycles.
In <code>add_task_require_dependency</code>, we propagate the cycle detected error (by returning <code>Err(())</code>) to the caller because the caller has more information to create an error message for the user that made a cyclic task dependency.</p>
<h2 id="resetting-tasks"><a class="header" href="#resetting-tasks">Resetting tasks</a></h2>
<p>Finally, when we determine that a task is inconsistent and needs to be executed, we first need to remove its output and remove its outgoing dependencies, as those will interfere with incrementality when not removed.
We do NOT want to remove incoming dependencies, as that would remove dependencies from other tasks to this task, which breaks incrementality, so we can't just remove and re-add the task to the graph.
Add the <code>reset_task</code> method that does this to <code>pie/src/store.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;T: Task&gt; Store&lt;T, T::Output&gt; {
  /// Reset task `src`, removing its output and removing all its outgoing dependencies.
  ///
  /// # Panics
  ///
  /// Panics if task `src` was not found in the dependency graph.
  pub fn reset_task(&amp;mut self, src: &amp;TaskNode) {
    if let Some(NodeData::Task { output, .. }) = self.graph.get_node_data_mut(src) {
      *output = None;
    } else {
      panic!(&quot;BUG: node {:?} was not found in the dependency graph&quot;, src);
    }
    self.graph.remove_outgoing_edges_of_node(src);
  }
}
</code></pre>
<p>This will reset the task output back to <code>None</code>, and remove all outgoing edges (dependencies).</p>
<h2 id="tests-2"><a class="header" href="#tests-2">Tests</a></h2>
<p>Now we've implemented everything we need for implementing the top-down context, but first we will write some tests.</p>
<h3 id="testing-file-mapping"><a class="header" href="#testing-file-mapping">Testing file mapping</a></h3>
<p>Add the following code to <code>pie/src/store.rs</code> for testing the file mapping:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use crate::Context;
  use crate::stamp::{FileStamper, OutputStamper};

  use super::*;

  /// Task that returns its owned string. Never executed, just used for testing the store.
  #[derive(Clone, PartialEq, Eq, Hash, Debug)]
  struct StringConstant(String);

  impl StringConstant {
    pub fn new(string: impl Into&lt;String&gt;) -&gt; Self { Self(string.into()) }
  }

  impl Task for StringConstant {
    type Output = String;
    fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, _context: &amp;mut C) -&gt; Self::Output {
      self.0.clone()
    }
  }

  #[test]
  fn test_file_mapping() {
    let mut store: Store&lt;StringConstant, String&gt; = Store::default();

    let path_a = PathBuf::from(&quot;hello.txt&quot;);
    let node_a = store.get_or_create_file_node(&amp;path_a);
    assert_eq!(node_a, store.get_or_create_file_node(&amp;path_a)); // Same node
    assert_eq!(&amp;path_a, store.get_file_path(&amp;node_a)); // Same file path

    let path_b = PathBuf::from(&quot;world.txt&quot;);
    let node_b = store.get_or_create_file_node(&amp;path_b);
    assert_eq!(node_b, store.get_or_create_file_node(&amp;path_b));
    assert_eq!(&amp;path_b, store.get_file_path(&amp;node_b));

    assert_ne!(node_a, node_b); // Different nodes
  }

  #[test]
  #[should_panic]
  fn test_file_mapping_panics() {
    let mut fake_store: Store&lt;StringConstant, String&gt; = Store::default();
    let fake_node = fake_store.get_or_create_file_node(&quot;hello.txt&quot;);
    let store: Store&lt;StringConstant, String&gt; = Store::default();
    store.get_file_path(&amp;fake_node);
  }
}
</code></pre>
<p>We create a simple task <code>StringConstant</code> because we need a <code>Task</code> implementation to test <code>Store</code>, as <code>Store</code> is generic over a <code>Task</code> type.
We will never execute it because <code>Store</code> does not execute tasks.</p>
<p>Test <code>test_file_mapping</code> checks whether the file node mapping works as expected:</p>
<ul>
<li><code>get_or_create_file_node</code> calls with the same path should produce the same <code>FileNode</code>.</li>
<li><code>get_or_create_file_node</code> calls with different paths should produce different <code>FileNode</code>s.</li>
</ul>
<p>This works because <code>&quot;hello.txt&quot;</code> and <code>&quot;world.txt&quot;</code> are different paths, thus their <code>Eq</code> and <code>Hash</code> implementations ensure they get separate spots in the <code>file_to_node</code> hash map.</p>
<p>Test <code>test_file_mapping_panics</code> triggers the panic in <code>get_file_path</code> by creating a <code>FileNode</code> with a &quot;fake store&quot;, and then using that rogue file node in another store.
While it is unlikely that we will make this mistake when using <code>Store</code>, it is good to confirm that this panics.</p>
<details id="admonition-rust-help" class="admonition info">
<summary class="admonition-title">
<p>Rust help</p>
<p><a class="admonition-anchor-link" href="2_incrementality/4_store/index.html#admonition-rust-help"></a></p>
</summary>
<div>
<p>The <code>#[should_panic]</code> attribute makes the test succeed if it panics, and fail if it does not panic.</p>
</div>
</details>
<h3 id="testing-task-mapping"><a class="header" href="#testing-task-mapping">Testing task mapping</a></h3>
<p>Test the task mapping by inserting the following code into the <code>test</code> module (before the last <code>}</code>):</p>
<pre><code class="language-rust ">  #[test]
  fn test_task_mapping() {
    let mut store = Store::default();

    let task_a = StringConstant::new(&quot;Hello&quot;);
    let node_a = store.get_or_create_task_node(&amp;task_a);
    assert_eq!(node_a, store.get_or_create_task_node(&amp;task_a)); // Same node
    assert_eq!(&amp;task_a, store.get_task(&amp;node_a)); // Same task

    let task_b = StringConstant::new(&quot;World&quot;);
    let node_b = store.get_or_create_task_node(&amp;task_b);
    assert_eq!(node_b, store.get_or_create_task_node(&amp;task_b));
    assert_eq!(&amp;task_b, store.get_task(&amp;node_b));

    assert_ne!(node_a, node_b); // Different nodes
  }

  #[test]
  #[should_panic]
  fn test_task_mapping_panics() {
    let mut fake_store = Store::default();
    let fake_node = fake_store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    let store: Store&lt;StringConstant, String&gt; = Store::default();
    store.get_task(&amp;fake_node);
  }
</code></pre>
<p>We test this in the same way as the file mapping.
Again, this works because <code>StringConstant(&quot;Hello&quot;)</code> and <code>StringConstant(&quot;World&quot;)</code> are different due to their derived <code>Eq</code> and <code>Hash</code> implementations, which make them different due to the strings being different. 
Likewise, <code>StringConstant::new(&quot;Hello&quot;)</code> and <code>StringConstant::new(&quot;Hello&quot;)</code> are equal even if they are created with 2 separate invocations of <code>new</code>.</p>
<p>These (in)equalities might seem quite obvious, but it is important to keep in mind because incrementality can only work if we can identify equal tasks at a later time, so that we can check their dependencies and return their cached output when those dependencies are consistent.
Later on we will also see that this is important for soundness of the incremental build system.</p>
<h3 id="testing-task-outputs"><a class="header" href="#testing-task-outputs">Testing task outputs</a></h3>
<p>Test task outputs by inserting the following code into the <code>test</code> module:</p>
<pre><code class="language-rust ">  #[test]
  fn test_task_outputs() {
    let mut store = Store::default();
    let output_a = &quot;Hello&quot;.to_string();
    let task_a = StringConstant::new(&amp;output_a);
    let node_a = store.get_or_create_task_node(&amp;task_a);

    let output_b = &quot;World&quot;.to_string();
    let task_b = StringConstant::new(&amp;output_b);
    let node_b = store.get_or_create_task_node(&amp;task_b);

    // Assert that tasks have no output by default.
    assert!(!store.task_has_output(&amp;node_a));
    assert!(!store.task_has_output(&amp;node_b));

    // Set output for task A, assert that A has that output but B is unchanged.
    store.set_task_output(&amp;node_a, output_a.clone());
    assert!(store.task_has_output(&amp;node_a));
    assert_eq!(store.get_task_output(&amp;node_a), &amp;output_a);
    assert!(!store.task_has_output(&amp;node_b));

    // Set output for task B, assert that B has that output but A is unchanged.
    store.set_task_output(&amp;node_b, output_b.clone());
    assert!(store.task_has_output(&amp;node_a));
    assert_eq!(store.get_task_output(&amp;node_a), &amp;output_a);
    assert!(store.task_has_output(&amp;node_b));
    assert_eq!(store.get_task_output(&amp;node_b), &amp;output_b);
  }

  #[test]
  #[should_panic]
  fn test_task_has_output_panics() {
    let mut fake_store = Store::default();
    let fake_node = fake_store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    let store: Store&lt;StringConstant, String&gt; = Store::default();
    store.task_has_output(&amp;fake_node);
  }

  #[test]
  #[should_panic]
  fn test_get_task_output_panics() {
    let mut store = Store::default();
    let node = store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    store.get_task_output(&amp;node);
  }

  #[test]
  #[should_panic]
  fn test_set_task_output_panics() {
    let mut fake_store = Store::default();
    let fake_node = fake_store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    let mut store: Store&lt;StringConstant, String&gt; = Store::default();
    store.set_task_output(&amp;fake_node, &quot;Hello&quot;.to_string());
  }
</code></pre>
<p>Test <code>test_task_outputs</code> ensures that:</p>
<ul>
<li><code>task_has_output</code> only returns true if given task has an output, </li>
<li>and that <code>get_task_output</code> returns the output set by <code>set_task_output</code> for given task.</li>
</ul>
<p>Test <code>test_get_task_output_panics</code> triggers a panic when we call <code>get_task_output</code> for a task that has no output, which is an invalid usage of <code>Store</code> that is more likely to happen than the other panics. </p>
<h3 id="testing-dependencies"><a class="header" href="#testing-dependencies">Testing dependencies</a></h3>
<p>Test dependencies by inserting the following code into the <code>test</code> module:</p>
<pre><code class="language-rust ">  #[test]
  fn test_dependencies() {
    let mut store = Store::default();
    let output_a = &quot;Hello&quot;.to_string();
    let task_a = StringConstant::new(output_a.clone());
    let node_a = store.get_or_create_task_node(&amp;task_a);
    let output_b = &quot;World&quot;.to_string();
    let task_b = StringConstant::new(output_b.clone());
    let node_b = store.get_or_create_task_node(&amp;task_b);
    let path_c = PathBuf::from(&quot;hello.txt&quot;);
    let node_c = store.get_or_create_file_node(&amp;path_c);

    assert_eq!(store.get_dependencies_of_task(&amp;node_a).next(), None);
    assert_eq!(store.get_dependencies_of_task(&amp;node_b).next(), None);

    // Add file dependency from task A to file C.
    let file_dependency_a2c = FileDependency::new(&amp;path_c, FileStamper::Exists).unwrap();
    store.add_file_require_dependency(&amp;node_a, &amp;node_c, file_dependency_a2c.clone());
    let deps_of_a: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;node_a).cloned().collect();
    assert_eq!(deps_of_a.get(0), Some(&amp;Dependency::RequireFile(file_dependency_a2c.clone())));
    assert_eq!(deps_of_a.get(1), None);
    assert_eq!(store.get_dependencies_of_task(&amp;node_b).next(), None);

    // Add task dependency from task B to task A.
    let task_dependency_b2a = TaskDependency::new(task_a.clone(), OutputStamper::Equals, output_a.clone());
    let result = store.add_task_require_dependency(&amp;node_b, &amp;node_a, task_dependency_b2a.clone());
    assert_eq!(result, Ok(()));
    let deps_of_a: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;node_a).cloned().collect();
    assert_eq!(deps_of_a.get(0), Some(&amp;Dependency::RequireFile(file_dependency_a2c.clone())));
    assert_eq!(deps_of_a.get(1), None);
    let deps_of_b: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;node_b).cloned().collect();
    assert_eq!(deps_of_b.get(0), Some(&amp;Dependency::RequireTask(task_dependency_b2a.clone())));
    assert_eq!(deps_of_b.get(1), None);

    // Add file dependency from task B to file C.
    let file_dependency_b2c = FileDependency::new(&amp;path_c, FileStamper::Exists).unwrap();
    store.add_file_require_dependency(&amp;node_b, &amp;node_c, file_dependency_b2c.clone());
    let deps_of_a: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;node_a).cloned().collect();
    assert_eq!(deps_of_a.get(0), Some(&amp;Dependency::RequireFile(file_dependency_a2c.clone())));
    assert_eq!(deps_of_a.get(1), None);
    let deps_of_b: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;node_b).cloned().collect();
    assert_eq!(deps_of_b.get(0), Some(&amp;Dependency::RequireTask(task_dependency_b2a.clone())));
    assert_eq!(deps_of_b.get(1), Some(&amp;Dependency::RequireFile(file_dependency_b2c.clone())));
    assert_eq!(deps_of_b.get(2), None);

    // Add task dependency from task A to task B, creating a cycle.
    let task_dependency_a2b = TaskDependency::new(task_a.clone(), OutputStamper::Equals, output_a.clone());
    let result = store.add_task_require_dependency(&amp;node_a, &amp;node_b, task_dependency_a2b);
    assert_eq!(result, Err(())); // Creates a cycle: error
  }

  #[test]
  #[should_panic]
  fn test_get_dependencies_of_task_panics() {
    let mut fake_store = Store::default();
    let fake_node = fake_store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    let store: Store&lt;StringConstant, String&gt; = Store::default();
    let _ = store.get_dependencies_of_task(&amp;fake_node);
  }

  #[test]
  #[should_panic]
  fn test_add_file_require_dependency_panics() {
    let mut fake_store = Store::default();
    let fake_file_node = fake_store.get_or_create_file_node(&quot;hello.txt&quot;);
    let fake_task_node = fake_store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    let mut store: Store&lt;StringConstant, String&gt; = Store::default();
    let dependency = FileDependency::new(&quot;hello.txt&quot;, FileStamper::Exists).unwrap();
    store.add_file_require_dependency(&amp;fake_task_node, &amp;fake_file_node, dependency);
  }

  #[test]
  #[should_panic]
  fn test_add_task_require_dependency_panics() {
    let mut fake_store = Store::default();
    let output = &quot;Hello&quot;.to_string();
    let task = StringConstant::new(&amp;output);
    let fake_task_node = fake_store.get_or_create_task_node(&amp;task);
    let mut store: Store&lt;StringConstant, String&gt; = Store::default();
    let dependency = TaskDependency::new(task, OutputStamper::Equals, output);
    let _ = store.add_task_require_dependency(&amp;fake_task_node, &amp;fake_task_node, dependency);
  }
</code></pre>
<p>The <code>test_dependencies</code> test is a bit more involved because it ensures that:</p>
<ul>
<li><code>get_dependencies_of_task</code> returns the dependencies of given task. If the task has no dependencies, the iterator is empty. We test if an iterator is empty by getting the first element of the iterator with <code>.next()</code> and assert that it is <code>None</code>.</li>
<li><code>get_dependencies_of_task</code> returns the dependencies of given task in the order in which they were added, which will be important for soundness later. The graph library returns dependencies in insertion order.</li>
<li><code>add_task_require_dependency</code> adds a dependency to the correct task.</li>
<li>creating a cycle with <code>add_task_require_dependency</code> results in it returning <code>Err(())</code>.</li>
</ul>
<p>Note that the <code>StringConstant</code> task does not actually create file or task dependencies, but since <code>Store</code> never executes a task, we can pretend that it does in tests. </p>
<h3 id="testing-task-reset"><a class="header" href="#testing-task-reset">Testing task reset</a></h3>
<p>Finally, test task reset by inserting the following code into the <code>test</code> module:</p>
<pre><code class="language-rust ">  #[test]
  fn test_reset() {
    let mut store = Store::default();
    let output_a = &quot;Hello&quot;.to_string();
    let task_a = StringConstant::new(output_a.clone());
    let task_a_node = store.get_or_create_task_node(&amp;task_a);
    let output_b = &quot;World&quot;.to_string();
    let task_b = StringConstant::new(output_b.clone());
    let task_b_node = store.get_or_create_task_node(&amp;task_b);
    let path = PathBuf::from(&quot;hello.txt&quot;);
    let file_node = store.get_or_create_file_node(&amp;path);

    // Set outputs for task A and B.
    store.set_task_output(&amp;task_a_node, output_a.clone());
    assert!(store.task_has_output(&amp;task_a_node));
    assert_eq!(store.get_task_output(&amp;task_a_node), &amp;output_a);
    store.set_task_output(&amp;task_b_node, output_b.clone());
    assert!(store.task_has_output(&amp;task_b_node));
    assert_eq!(store.get_task_output(&amp;task_b_node), &amp;output_b);

    // Add file dependency for task A and B.
    let file_dependency = FileDependency::new(&amp;path, FileStamper::Exists).unwrap();
    store.add_file_require_dependency(&amp;task_a_node, &amp;file_node, file_dependency.clone());
    let deps_of_a: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;task_a_node).cloned().collect();
    assert_eq!(deps_of_a.get(0), Some(&amp;Dependency::RequireFile(file_dependency.clone())));
    assert_eq!(deps_of_a.get(1), None);
    store.add_file_require_dependency(&amp;task_b_node, &amp;file_node, file_dependency.clone());
    let deps_of_b: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;task_b_node).cloned().collect();
    assert_eq!(deps_of_b.get(0), Some(&amp;Dependency::RequireFile(file_dependency.clone())));
    assert_eq!(deps_of_b.get(1), None);

    // Reset only task A.
    store.reset_task(&amp;task_a_node);
    // Assert that task A is reset.
    assert!(!store.task_has_output(&amp;task_a_node));
    assert_eq!(store.get_dependencies_of_task(&amp;task_a_node).next(), None);
    // Assert that task B is unchanged.
    assert!(store.task_has_output(&amp;task_b_node));
    assert_eq!(store.get_task_output(&amp;task_b_node), &amp;output_b);
    let deps_of_b: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;task_b_node).cloned().collect();
    assert_eq!(deps_of_b.get(0), Some(&amp;Dependency::RequireFile(file_dependency.clone())));
    assert_eq!(deps_of_b.get(1), None);
  }

  #[test]
  #[should_panic]
  fn test_reset_task_panics() {
    let mut fake_store = Store::default();
    let fake_node = fake_store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    let mut store: Store&lt;StringConstant, String&gt; = Store::default();
    store.reset_task(&amp;fake_node);
  }
</code></pre>
<p>Here, we ensure that a task with an output and dependencies, does not have an output and dependencies after a reset, while leaving another task untouched.</p>
<p>Confirm that the store implementation works with <code>cargo test</code>.</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="2_incrementality/4_store/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="2_incrementality/4_store/../../gen/2_incrementality/4_store/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="top-down-context"><a class="header" href="#top-down-context">Top-down Context</a></h1>
<p>We've implemented all the prerequisites for incremental top-down building.
Now we will create the <code>TopDownContext</code> type which implements the <code>Context</code> trait in an incremental way. </p>
<h2 id="top-down-context-basics"><a class="header" href="#top-down-context-basics">Top-down context basics</a></h2>
<p>Add the <code>top_down</code> module to <code>pie/src/context/mod.rs</code>:</p>
<pre><code class="language-rust customdiff"> pub mod non_incremental;
+pub mod top_down;</code></pre>
<p>Create the <code>pie/src/context/top_down.rs</code> file and add the following to get started:</p>
<pre><code class="language-rust ">use std::fs::File;
use std::io;
use std::path::Path;

use crate::{Context, fs, Task};
use crate::dependency::{FileDependency, TaskDependency};
use crate::stamp::{FileStamper, OutputStamper};
use crate::store::{Store, TaskNode};

pub struct TopDownContext&lt;T, O&gt; {
  store: Store&lt;T, O&gt;,
}

impl&lt;T: Task&gt; TopDownContext&lt;T, T::Output&gt; {
  pub fn new() -&gt; Self {
    Self {
      store: Store::default(),
    }
  }
}

impl&lt;T: Task&gt; Context&lt;T&gt; for TopDownContext&lt;T, T::Output&gt; {
  fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
    todo!()
  }

  fn require_task_with_stamper(&amp;mut self, task: &amp;T, stamper: OutputStamper) -&gt; T::Output {
    todo!()
  }
}</code></pre>
<p>The <code>TopDownContext</code> type is generic over tasks <code>T</code> and their outputs <code>O</code>, owns a <code>Store</code>, and can be created using <code>new</code>.</p>
<p><code>TopDownContext</code> implements <code>Context</code>, and the main challenge will be implementing the <code>require_file_with_stamper</code> and <code>require_task_with_stamper</code> methods <em>incrementally</em> and <em>correctly</em>.</p>
<h2 id="requiring-files-1"><a class="header" href="#requiring-files-1">Requiring files</a></h2>
<p>Tasks such as <code>ReadStringFromFile</code> which we've used in tests before call <code>context.require_file</code> to declare that they depend on a file in the filesystem.
For incrementality, we need to add this dependency to the dependency graph.
This dependency will go from the <em>current executing task</em> to the file.
Therefore, we will need to keep track of the current executing task.</p>
<p>Change <code>pie/src/context/mod.rs</code> to add a field for tracking the current executing task, and use it in <code>require_file_with_stamper</code>:</p>
<pre><code class="language-rust customdiff">
 use crate::{Context, fs, Task};
 use crate::dependency::{FileDependency, TaskDependency};
 use crate::stamp::{FileStamper, OutputStamper};
 use crate::store::{Store, TaskNode};

 pub struct TopDownContext&lt;T, O&gt; {
   store: Store&lt;T, O&gt;,
+  current_executing_task: Option&lt;TaskNode&gt;,
 }

 impl&lt;T: Task&gt; TopDownContext&lt;T, T::Output&gt; {
   pub fn new() -&gt; Self {
     Self {
       store: Store::default(),
+      current_executing_task: None,
     }
   }
 }

 impl&lt;T: Task&gt; Context&lt;T&gt; for TopDownContext&lt;T, T::Output&gt; {
   fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
+    let Some(current_executing_task_node) = &amp;self.current_executing_task else {
+      return fs::open_if_file(path); // No current executing task, so no dependency needs to be made.
+    };
     todo!()
   }

   fn require_task_with_stamper(&amp;mut self, task: &amp;T, stamper: OutputStamper) -&gt; T::Output {
     todo!()
   }
 }</code></pre>
<p>We're not setting <code>current_executing_task</code> yet, as that is the responsibility of <code>require_task_with_stamper</code> which we will implement later.
In <code>require_file_with_stamper</code> we're now getting the current executing task.
If there is no current executing task, which only happens if a user directly calls <code>require_file</code> on a context, we don't make a dependency and just open the file.</p>
<p>Now we need to add the file dependency, change <code>pie/src/context/mod.rs</code> to do this: </p>
<pre><code class="language-rust customdiff"> impl&lt;T: Task&gt; Context&lt;T&gt; for TopDownContext&lt;T, T::Output&gt; {
   fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
     let Some(current_executing_task_node) = &amp;self.current_executing_task else {
       return fs::open_if_file(path); // No current executing task, so no dependency needs to be made.
     };
-    todo!()
+    let path = path.as_ref();
+    let node = self.store.get_or_create_file_node(path);
+    let (dependency, file) = FileDependency::new_with_file(path, stamper)?;
+    self.store.add_file_require_dependency(current_executing_task_node, &amp;node, dependency);
+    Ok(file)
   }

   fn require_task_with_stamper(&amp;mut self, task: &amp;T, stamper: OutputStamper) -&gt; T::Output {
     todo!()
   }</code></pre>
<p>We simply create or get an existing file node, create a file dependency, and add the file require dependency to the graph via <code>store</code>.
Errors are propagated to the caller, so they can react accordingly to filesystem operation failures.</p>
<h2 id="requiring-tasks"><a class="header" href="#requiring-tasks">Requiring tasks</a></h2>
<p>To implement <code>require_task_with_stamper</code>, we need to check whether we should execute a task.
A task should be executed either if it's new (it does not have an output stored yet), or if at least one of its dependencies is inconsistent.
If we don't execute it, then it must have an output value and all its dependencies are consistent, so we just return its output value.</p>
<p>Change <code>pie/src/context/mod.rs</code> to implement this logic:</p>
<pre><code class="language-rust customdiff">     self.store.add_file_require_dependency(current_executing_task_node, &amp;node, dependency);
     Ok(file)
   }

   fn require_task_with_stamper(&amp;mut self, task: &amp;T, stamper: OutputStamper) -&gt; T::Output {
-    todo!()
+    let node = self.store.get_or_create_task_node(task);
+
+    // Get required task output by executing it if needed, or by getting the output from the store if not needed.
+    let output = if self.should_execute_task(&amp;node) {
+      self.store.reset_task(&amp;node);
+      let previous_executing_task = self.current_executing_task.replace(node);
+      let output = task.execute(self);
+      self.current_executing_task = previous_executing_task;
+      self.store.set_task_output(&amp;node, output.clone());
+      output
+    } else {
+      // Correctness: when `should_execute_task` returns `true`, the above block is executed. Otherwise this block is 
+      // executed and `should_execute_task` ensures that the task has an output.
+      self.store.get_task_output(&amp;node).clone()
+    };
+
+    output
   }
 }</code></pre>
<p>We first create or get an existing file node.
Then, we check whether the task should be executed with <code>should_execute_task</code> which we still need to implement.</p>
<p>If that returns true, we reset the task, set the current executing task, actually execute the task, restore the previous executing task, and set the task output.
Otherwise, we get the output of the task from the store, which cannot panic because <code>should_execute_task</code> ensures that the task has an output if it returns false.
Finally, we return the output.</p>
<p>We still need to create a task dependency. Change <code>pie/src/context/mod.rs</code> to add the dependency:</p>
<pre><code class="language-rust customdiff">       // Correctness: when `should_execute_task` returns `true`, the above block is executed. Otherwise this block is 
       // executed and `should_execute_task` ensures that the task has an output.
       self.store.get_task_output(&amp;node).clone()
     };

+    // Create task require dependency if a task is currently executing (i.e., we are not requiring the initial task).
+    if let Some(current_executing_task_node) = &amp;self.current_executing_task {
+      let dependency = TaskDependency::new(task.clone(), stamper, output.clone());
+      if self.store.add_task_require_dependency(current_executing_task_node, &amp;node, dependency).is_err() {
+        let current_executing_task = self.store.get_task(current_executing_task_node);
+        panic!(&quot;Cyclic task dependency; current executing task '{:?}' is requiring task '{:?}' which was already required&quot;, current_executing_task, task);
+      }
+    }
+
     output
   }
 }</code></pre>
<p>If there is no current executing task, which occurs when a user requires the initial task, we skip creating a dependency.
Otherwise, we create a dependency and add it to the store.
However, creating a task dependency can create cycles, and we need to handle that error.</p>
<p>At this point, we need to make a hard decision about the API of our library.
<code>require_task_with_stamper</code> returns the task output, with no opportunity to return an error.
If we want to propagate this error, we'd need to change the <code>Context::require_task</code> API to return <code>Result&lt;T::Output, CycleError&gt;</code>.
However, because tasks call these methods on <code>Context</code>, we'd also need to change <code>Task::execute</code> to return <code>Result&lt;T::Output, CycleError&gt;</code>.
That would require all tasks to propagate these cycle errors every time they require another task.</p>
<p>Furthermore, some tasks want to return their own kinds of errors, where <code>T::Output</code> will be <code>Result&lt;AnOutput, AnError&gt;</code>.
In that case, the concrete return type would be <code>Result&lt;Result&lt;AnOutput, AnError&gt;, CycleError&gt;</code>, which is annoying to deal with.</p>
<p>On the other hand, we can panic when a cycle is found, which requires no changes to the API.
We do end up in a mostly unrecoverable state, so a panic is a valid option.
However, this is not ideal, because it means the build system can panic due to invalid task dependencies created by the user of the system.
Panics will (most of the time) stop the program, which can be annoying to deal with.</p>
<p>This is a hard trade-off to make.
Either we propagate errors which will not end the program but will introduce a lot of boilerplate and annoyance in task implementations.
Or we panic which will end the program but introduces no boilerplate.</p>
<p>In this tutorial, we will go with panics on cycles, because it results in a much simpler system.</p>
<details id="admonition-recovering-from-panics" class="admonition info">
<summary class="admonition-title">
<p>Recovering from panics</p>
<p><a class="admonition-anchor-link" href="2_incrementality/5_context/index.html#admonition-recovering-from-panics"></a></p>
</summary>
<div>
<p>Panics either abort the program (when panics are set to abort in <code>Cargo.toml</code>), or unwind the call stack and then end the program.</p>
<p>When panics abort, there is nothing we can do about it. 
A panic will immediately abort the program.
When panics unwind, the call stack is unwound, which still runs all destructors (<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>), and this unwinding can be caught.</p>
<p>We can catch unwinding panics with <a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a>, which is a way to recover from panics.
This does require that the types used in the closure passed to <code>catch_unwind</code> are <a href="https://doc.rust-lang.org/std/panic/trait.UnwindSafe.html">unwind safe</a>.
This is because panics exit a function early, which can mess up some invariants of your code.
For example, a call to set a task output can be skipped when a panic occurs, breaking a code invariant.
Therefore, types such as <code>&amp;mut T</code> are not unwind safe by default, because these invariants can break under panics.</p>
<p>Note that unwind safety is something different than the general safety guarantees provided by Rust: type-safe, memory-safe, thread-safe.
An unwind unsafe type is still type-safe, memory-safe, and thread-safe.</p>
<p>Unwind safety can be more easily achieved by using owned types which run destructors when the function call ends, which work under normal circumstances, but also when unwinding panics.</p>
<p>In the context of the PIE build system, if we panic on unrecoverable errors, but want to allow catching these panics, we need to think about unwind safety.
At any point we panic, we need to think about keeping the system in a valid state.</p>
<p>Another way to recover from panics is to run the panicking code on a different thread.
If the code panics, it will only end that thread, effectively allowing panic recovery.
However, this does require some form of thread-safety, beause you are moving a computation to a different thread.
Furthermore, some platforms do not have access to threads, such as WASM, where this approach would not work.</p>
<p>A final note is that care must be taken when <a href="https://doc.rust-lang.org/nomicon/ffi.html#ffi-and-unwinding">unwiding panics across foreign function interfaces (FFI)</a>.</p>
</div>
</details>
<h2 id="checking-tasks"><a class="header" href="#checking-tasks">Checking tasks</a></h2>
<p>The final piece to our puzzle is the <code>should_execute_task</code> implementation.</p>
<p>Add the following code to <code>pie/src/context/mod.rs</code>:</p>
<pre><code class="language-rust customdiff ">     }

     output
   }
 }
+
+impl&lt;T: Task&gt; TopDownContext&lt;T, T::Output&gt; {
+  /// Checks whether given task should be executed, returning `true` if it should be executed. A task should be executed
+  /// if any of its dependencies are inconsistent, or when it has no output.
+  fn should_execute_task(&amp;mut self, node: &amp;TaskNode) -&gt; bool {
+    // Borrow: because we pass `self` (which is `&amp;mut self`) to `is_inconsistent` for recursive consistency checking, 
+    //         we need to clone and collect dependencies into a `Vec`. Otherwise we have an immutable borrow of `self`
+    //         through `self.store` while we create a mutable borrow of `self`, which is not allowed.
+    let dependencies: Vec&lt;_&gt; = self.store.get_dependencies_of_task(node).cloned().collect();
+    for dependency in dependencies {
+      match dependency.is_inconsistent(self) {
+        Ok(Some(_)) =&gt; return true,
+        _ =&gt; {} // Consistent: continue checking
+      }
+    }
+    // Task has no dependencies or all dependencies are consistent. Should only execute if it has no output, meaning
+    // that it has never been executed before.
+    return !self.store.task_has_output(node);
+  }
+}</code></pre>
<p>The premise of <code>should_execute_task</code> is simple: go over the dependencies of a task until <code>dependency.is_inconsistent</code> is true, at which we return true.
If all dependencies are consistent, then return true only if the task has no output.
Otherwise, return false.</p>
<p>However, there are some complications due to borrowing.
Checking if a task dependency is inconsistent requires recursive checking: <code>TaskDependency::is_inconsistent</code> requires a <code>&amp;mut Context</code> to call <code>Context::require_task</code>, which in turn can require this method again. 
To that end, we pass <code>self</code> to <code>is_inconsistent</code>, because <code>self</code> is an instance of <code>TopDownContext</code> which implements <code>Context</code>.</p>
<p>In this method, <code>self</code> is <code>&amp;mut self</code>, a mutable borrow.
Therefore, we cannot have <em>any other borrows</em> active while <code>is_inconsistent</code> is being called, because that would violate one of the safety mechanisms of Rust where mutable borrows are <em>exclusive</em>.
Getting the task's dependencies from the store requires a borrow, so we cannot hold onto that borrow.
We get around that here by cloning the dependencies and collecting them into a <code>Vec</code>.</p>
<p>We also document this fact in a comment to explain to readers (us in the future) why we do this cloning, preventing refactorings only to hit that same borrowing issue again. </p>
<p>Cloning and collecting does have a performance overhead as we need to clone the dependencies and heap allocate a <code>Vec</code> to store them.
For this tutorial, that is fine, but in a real-world application we should minimize cloning if possible and look into reducing heap allocations.</p>
<details id="admonition-reference-counting" class="admonition info">
<summary class="admonition-title">
<p>Reference counting</p>
<p><a class="admonition-anchor-link" href="2_incrementality/5_context/index.html#admonition-reference-counting"></a></p>
</summary>
<div>
<p>Cloning a <code>Dependency</code> results in heap allocations, because cloning <code>FileDependency</code> clones a <code>PathBuf</code> which is a heap allocated string (basically a <code>Vec&lt;u8&gt;</code>), and cloning a <code>TaskDependency</code> clones the <code>Task</code>, which may require allocations as well.</p>
<p>One way to avoid heap allocations in both kinds of dependencies is to store the <code>PathBuf</code> and <code>Task</code> in a <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">reference-counting pointer <code>Rc</code></a>.
Then, there will only be one heap allocated <code>PathBuf</code> and <code>Task</code>, and cloning just increments the reference count.
The upside is that this approach is easy to implement and reduces allocations.
The downside is that clones require incrementing the reference count, which is a write operation that does have a tiny bit of overhead.
In many cases, this overhead is smaller than cloning data when the data is large enough or requires heap allocations.
In our case, it would probably be worth doing this, but benchmarking is required to confirm this.</p>
<p>Note that instead of always wrapping tasks in a <code>Rc</code>, task authors could implement <code>Task</code> on <code>Rc&lt;TheirTask&gt;</code> instead.
Since <code>Rc</code> implements <code>Clone</code>, any time we <code>task.clone()</code>, we would just increase the reference count instead.</p>
<p>When working in a multi-threaded situation, you would use the thread-safe <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> instead.</p>
</div>
</details>
<details id="admonition-string-optimizations" class="admonition info">
<summary class="admonition-title">
<p>String optimizations</p>
<p><a class="admonition-anchor-link" href="2_incrementality/5_context/index.html#admonition-string-optimizations"></a></p>
</summary>
<div>
<p>A technique for reducing allocations on strings (and string-like types such as <code>PathBuf</code>) is to apply <a href="https://fasterthanli.me/articles/small-strings-in-rust">small string optimization</a>, where small strings are stored inline instead of requiring a heap allocation.
This only works if the strings are usually small enough to fit inline on the stack (for example, 32 bytes).</p>
<p>Another technique for strings is string interning, where equal strings are stored in a central place and then re-used everywhere.
This technique is great when we use the same string a lot of times.
That may be a good strategy for a build system, where we work with the same file paths over and over.</p>
<p>There are several crates implementing these techniques, but I have not used one myself yet, so I cannot recommend one.</p>
</div>
</details>
<details id="admonition-avoiding-heap-allocations-from-collecting-into-vecs" class="admonition info">
<summary class="admonition-title">
<p>Avoiding heap allocations from collecting into Vecs</p>
<p><a class="admonition-anchor-link" href="2_incrementality/5_context/index.html#admonition-avoiding-heap-allocations-from-collecting-into-vecs"></a></p>
</summary>
<div>
<p>Collecting the elements of an iterator into a <code>Vec</code> requires heap allocations as <code>Vec</code> is allocated on the heap.
We can avoid or at least reduce the number of heap allocations by re-using the same <code>Vec</code> instead of creating a new one.
Instead of collecting, you would store the <code>Vec</code> in the struct, clear it, and then <code>extend</code> it with the iterator.</p>
<p>When you <code>clear</code> a <code>Vec</code>, it removes all the elements, but keeps the heap allocated space.
Only if you would add more elements than it has space for, another heap allocation would be required, which will happen less and less frequently when you keep reusing the same <code>Vec</code>.
The downside is that you are keeping this heap allocated space for as long as you keep reusing the same <code>Vec</code>, which could waste some memory, but usually this is not a big problem.
You could of course call <code>vec.shrink_to_fit()</code> after not using it for a while to free up this space.</p>
<p>However, we cannot apply this technique here, because if we store the <code>Vec</code> in <code>TopDownContext</code>, we would run into the same borrowing problem again.
This technique also requires that you have mutable access to the <code>Vec</code> in order to mutate it.</p>
<p>Both of these limitations can be overcome by using a <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell</code></a>.
<code>Cell</code> allows mutation to its inner value in an immutable context.
The catch is that you <em>cannot get a reference to its inner value</em>, you can only <code>take</code> the value out, mutate it, and then <code>set</code> it back.
Unfortunately, even this technique cannot be fully applied to <code>should_execute_task</code>, because it is called recursively and therefore the <code>Cell</code> will be empty when we try to <code>take</code> the <code>Vec</code> out.</p>
<p>If we want to avoid heap allocations from collecting new <code>Vec</code>s in <code>should_execute_task</code>, we would need to come up with a creative solution.
But this is outside of the scope of even this extra information block, so we'll just leave it at that.</p>
</div>
</details>
<p>Finally, we need to do something with dependency checking failures.
We've ignored the case where <code>dependency.is_inconsistent</code> returns <code>Err</code>.
When dependency checking result in an error, we should store the error for the user to investigate, and assume the dependency is inconsistent.</p>
<p>Change <code>pie/src/context/mod.rs</code> to store dependency check errors and give users access to it:</p>
<pre><code class="language-rust customdiff"> use crate::store::{Store, TaskNode};

 pub struct TopDownContext&lt;T, O&gt; {
   store: Store&lt;T, O&gt;,
   current_executing_task: Option&lt;TaskNode&gt;,
+  dependency_check_errors: Vec&lt;io::Error&gt;,
 }

 impl&lt;T: Task&gt; TopDownContext&lt;T, T::Output&gt; {
   pub fn new() -&gt; Self {
     Self {
       store: Store::default(),
       current_executing_task: None,
+      dependency_check_errors: Vec::default(),
     }
   }
+
+  pub fn get_dependency_check_errors(&amp;self) -&gt; impl Iterator&lt;Item=&amp;io::Error&gt; {
+    self.dependency_check_errors.iter()
+  }
 }

 impl&lt;T: Task&gt; Context&lt;T&gt; for TopDownContext&lt;T, T::Output&gt; {
   fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
     let Some(current_executing_task_node) = &amp;self.current_executing_task else {</code></pre>
<p>And then change <code>pie/src/context/mod.rs</code> to store these errors:</p>
<pre><code class="language-rust customdiff">   pub fn get_dependency_check_errors(&amp;self) -&gt; impl Iterator&lt;Item=&amp;io::Error&gt; {
     self.dependency_check_errors.iter()
   }
 }

+
 impl&lt;T: Task&gt; Context&lt;T&gt; for TopDownContext&lt;T, T::Output&gt; {
   fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
     let Some(current_executing_task_node) = &amp;self.current_executing_task else {
       return fs::open_if_file(path); // No current executing task, so no dependency needs to be made.
     };
@@ -78,10 +79,14 @@
     //         through `self.store` while we create a mutable borrow of `self`, which is not allowed.
     let dependencies: Vec&lt;_&gt; = self.store.get_dependencies_of_task(node).cloned().collect();
     for dependency in dependencies {
       match dependency.is_inconsistent(self) {
         Ok(Some(_)) =&gt; return true,
+        Err(e) =&gt; { // Error while checking: store error and assume inconsistent
+          self.dependency_check_errors.push(e);
+          return true;
+        }
         _ =&gt; {} // Consistent: continue checking
       }
     }
     // Task has no dependencies or all dependencies are consistent. Should only execute if it has no output, meaning
     // that it has never been executed before.</code></pre>
<p>It took us a while, but now we've implemented an incremental build system with dynamic dependencies 🎉.
Let's set up an example to see the fruits of our labour.</p>
<h2 id="incrementality-example"><a class="header" href="#incrementality-example">Incrementality Example</a></h2>
<p>In this example, we will show off incrementality using two tasks: a task that reads a string from a file, and a task that writes a string to a file.
The writing task gets the string by requiring another task.
Therefore, we will have a read task with a file dependency, and a write task with a task and file dependency.
Because we only support one type of task, we will wrap these tasks in an enum.</p>
<h3 id="filetask-enumeration"><a class="header" href="#filetask-enumeration">FileTask enumeration</a></h3>
<p>Create the <code>pie/examples</code> directory, and create the <code>pie/examples/incrementality.rs</code> file with the following contents:</p>
<pre><code class="language-rust ">#![allow(unused_imports, unused_variables)]

use std::fs::{File, read_to_string, remove_file, write};
use std::io::{self, Read, Write};
use std::path::{Path, PathBuf};

use dev_shared::{create_temp_dir, write_until_modified};
use pie::{Context, Task};
use pie::context::top_down::TopDownContext;
use pie::stamp::FileStamper;

/// Enumeration over file pseudo-tasks.
#[derive(Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]
enum FileTask {
  ReadStringFromFile(ReadStringFromFile),
  WriteStringToFile(WriteStringToFile),
}

/// [`Task`] implementation for [`FileTask`], forwarding execute to the execute functions of the pseudo-tasks.
impl Task for FileTask {
  type Output = Result&lt;String, io::ErrorKind&gt;;
  fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
    match self {
      FileTask::ReadStringFromFile(t) =&gt; t.execute(context),
      FileTask::WriteStringToFile(t) =&gt; t.execute(context).map(|_| String::new())
    }
  }
}
</code></pre>
<p><code>FileTask</code> is the enum over the <code>ReadStringFromFile</code> and <code>WriteStringToFile</code> &quot;pseudo-tasks&quot; that we still need to define.
We call these types pseudo-tasks, because they behave like tasks, but do not actually implement <code>Task</code>.
We implement <code>Task</code> on <code>FileTask</code> instead, which forwards the <code>execute</code> method to the pseudo-tasks.</p>
<p>Both tasks can fail due to using filesystem operations, so the output is a <code>Result</code>.
We cannot use <code>std::io::Error</code> as the error in the <code>Result</code>, because it does not implement <code>Clone</code> nor <code>Eq</code>, which need to be implemented for task outputs.
Therefore, we use <code>std::io::ErrorKind</code> which does implement these traits.</p>
<p>On success, we return a <code>String</code>.
Because <code>WriteStringToFile</code> will not return a value (i.e., <code>()</code>) on success, we return an empty string with <code>String::new()</code>.
It would be cleaner to define an <code>FileOutput</code> enum that enumerates the possible outputs of file tasks, which would include a variant for <code>WriteStringToFile</code> returning <code>()</code>.
But to keep this example simple we don't do that.</p>
<h3 id="readwrite-pseudo-tasks"><a class="header" href="#readwrite-pseudo-tasks">Read/write pseudo-tasks</a></h3>
<p>Now add <code>ReadStringFromFile</code> to <code>pie/examples/incrementality.rs</code>:</p>
<pre><code class="language-rust ">/// Pseudo-task that reads a string from a file.
#[derive(Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]
struct ReadStringFromFile(PathBuf, FileStamper);

impl ReadStringFromFile {
  fn new(path: impl AsRef&lt;Path&gt;, stamper: FileStamper) -&gt; FileTask {
    FileTask::ReadStringFromFile(Self(path.as_ref().to_path_buf(), stamper))
  }
  fn execute&lt;C: Context&lt;FileTask&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Result&lt;String, io::ErrorKind&gt; {
    println!(&quot;Reading from {} with {:?} stamper&quot;, self.0.file_name().unwrap().to_string_lossy(), self.1);
    let file = context.require_file_with_stamper(&amp;self.0, self.1).map_err(|e| e.kind())?;
    if let Some(mut file) = file {
      let mut string = String::new();
      file.read_to_string(&amp;mut string).map_err(|e| e.kind())?;
      Ok(string)
    } else {
      Err(io::ErrorKind::NotFound)
    }
  }
}
</code></pre>
<p>We've already defined a task like this before, but now it accepts a <code>FileStamper</code>, prints something when it gets executed, and propagates errors.</p>
<p>Add <code>WriteStringToFile</code> to <code>pie/examples/incrementality.rs</code>:</p>
<pre><code class="language-rust ">/// Pseudo-task that writes a string to a file, where the string is provided by another task. The string provider is 
/// boxed to prevent a cyclic definition of infinite size, due to this type being used in [`FileTask`].
#[derive(Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]
struct WriteStringToFile(Box&lt;FileTask&gt;, PathBuf, FileStamper);

impl WriteStringToFile {
  fn new(string_provider: impl Into&lt;Box&lt;FileTask&gt;&gt;, path: impl Into&lt;PathBuf&gt;, stamper: FileStamper) -&gt; FileTask {
    FileTask::WriteStringToFile(Self(string_provider.into(), path.into(), stamper))
  }
  fn execute&lt;C: Context&lt;FileTask&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Result&lt;(), io::ErrorKind&gt; {
    println!(&quot;Writing to {} with {:?} stamper&quot;, self.1.file_name().unwrap().to_string_lossy(), self.2);
    let string = context.require_task(&amp;self.0)?;
    let mut file = File::create(&amp;self.1).map_err(|e| e.kind())?;
    file.write_all(string.as_bytes()).map_err(|e| e.kind())?;
    context.require_file_with_stamper(&amp;self.1, self.2).map_err(|e| e.kind())?;
    Ok(())
  }
}
</code></pre>
<p>What is special about this task, is that it takes another task as input!
Tasks in a programmatic incremental build system are first-class, meaning that they are just values that can be passed around.</p>
<p>This is similar to closures in Rust and other programming languages, which are functions (with some values captured from the environment), but are also values that can be passed around.
Tasks can therefore be seen as a form of incremental closures, although they need to be executed under a <code>Context</code> for incrementality, whereas closures are more free-form.</p>
<p><code>WriteStringToFile</code> requires the task to (incrementally) get the string, creating a task dependency.
Then it writes that string to a file, and requires that file to create a file dependency.</p>
<details id="admonition-boxing-to-prevent-cyclic-definition" class="admonition info">
<summary class="admonition-title">
<p>Boxing to prevent cyclic definition</p>
<p><a class="admonition-anchor-link" href="2_incrementality/5_context/index.html#admonition-boxing-to-prevent-cyclic-definition"></a></p>
</summary>
<div>
<p>We store the task as <code>Box&lt;FileTask&gt;</code> in order to prevent a cyclic definition, which would cause <code>FileTask</code> to have an undetermined size.
This is due to several reasons:</p>
<ul>
<li>In Rust, values are stored on the stack by default. To store something on the stack, Rust needs to know its size <em>at compile-time</em>.</li>
<li>The size of an <code>enum</code> is the size of the largest variant.</li>
<li>The size of a struct is the sum of the size of the fields.</li>
</ul>
<p>If we don't box the task, to calculate the size of <code>WriteStringToFile</code>, we need to calculate the size of <code>FileTask</code>, which would require calculating the size of <code>WriteStringToFile</code>, and so forth.
Therefore, we can't calulate the size of <code>WriteStringToFile</code> and <code>FileTask</code>, which is an error.</p>
<p>Boxing solves this because <code>Box&lt;FileTask&gt;</code> allocates a <code>FileTask</code> on the heap, and then creates a pointer to it.
Therefore, the size of <code>Box&lt;FileTask&gt;</code> is the size of one pointer, breaking the cycle in the size calculations.</p>
<p>Note that this explanation <a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html">simplifies many aspects of Rust's size calculation</a>.</p>
</div>
</details>
<h3 id="exploring-incrementality"><a class="header" href="#exploring-incrementality">Exploring incrementality</a></h3>
<p>We've implemented the tasks, now add a <code>main</code> function to <code>pie/examples/incrementality.rs</code>:</p>
<pre><code class="language-rust ">fn main() -&gt; Result&lt;(), io::Error&gt; {
  let temp_dir = create_temp_dir()?;
  let input_file = temp_dir.path().join(&quot;input.txt&quot;);
  write(&amp;input_file, &quot;Hi&quot;)?;
  let output_file = temp_dir.path().join(&quot;output.txt&quot;);

  let mut context = TopDownContext::new();
  let read_task = ReadStringFromFile::new(&amp;input_file, FileStamper::Modified);
  let write_task = WriteStringToFile::new(read_task.clone(), &amp;output_file, FileStamper::Modified);

  println!(&quot;A) New task: expect `read_task` to execute&quot;);
  // `read_task` is new, meaning that we have no cached output for it, thus it must be executed.
  let output = context.require_task(&amp;read_task)?;
  assert_eq!(&amp;output, &quot;Hi&quot;);

  Ok(())
}</code></pre>
<p>We create some temporary files, create our tasks, create a context, and require our first task.
Run this example with <code>cargo run --example incremental</code>.
You should see the <code>println!</code> in <code>ReadStringFromFile</code> appear in your console as the incremental context correctly determines that this task is new (i.e., has no output) and must be executed.
It should look something like:</p>
<pre><code>   Compiling pie v0.1.0 (/private/pie)
    Finished dev [unoptimized + debuginfo] target(s) in 1.29s
     Running `/private/pie/target/debug/examples/incremental`
A) New task: expect `read_task` to execute
Reading from input.txt with Modified stamper
</code></pre>
<h4 id="reuse"><a class="header" href="#reuse">Reuse</a></h4>
<p>If we require the task again, what should happen?</p>
<p>Insert the following code into the <code>main</code> method:</p>
<pre><code class="language-rust ">  println!(&quot;\nB) Reuse: expect no execution&quot;);
  // `read_task` is not new and its file dependency is still consistent. It is consistent because the modified time of 
  // `input_file` has not changed, thus the modified stamp is equal.
  let output = context.require_task(&amp;read_task)?;
  assert_eq!(&amp;output, &quot;Hi&quot;);
</code></pre>
<p>Running with <code>cargo run --example incremental</code> should produce output like:</p>
<pre><code>   Compiling pie v0.1.0 (/private/pie)
    Finished dev [unoptimized + debuginfo] target(s) in 0.60s
     Running `/private/pie/target/debug/examples/incremental`
A) New task: expect `read_task` to execute
Reading from input.txt with Modified stamper

B) Reuse: expect no execution
</code></pre>
<p>We don't see the <code>println!</code> from <code>ReadStringFromFile</code>, so it was not executed, so our incremental build system has correctly reused its output!</p>
<p>Normally we would write a test to confirm that the task was executed the first time, and that it was not executed the second time.
However, this is not trivial.
How do we know if the task was executed?
We could track it with a global mutable boolean that <code>ReadStringFromFile</code> keeps track of, but this quickly becomes a mess.
Therefore, we will look into creating a proper testing infrastructure in the next chapter.</p>
<p>For now, we will continue this example with several more interesting cases.
The comments in the code explain in more detail why the build system behaves in this way.</p>
<h4 id="inconsistent-file-dependency"><a class="header" href="#inconsistent-file-dependency">Inconsistent file dependency</a></h4>
<p>Insert into the <code>main</code> method:</p>
<pre><code class="language-rust ">  write_until_modified(&amp;input_file, &quot;Hello&quot;)?;
  println!(&quot;\nC) Inconsistent file dependency: expect `read_task` to execute&quot;);
  // The file dependency of `read_task` is inconsistent due to the changed modified time of `input_file`.
  let output = context.require_task(&amp;read_task)?;
  assert_eq!(&amp;output, &quot;Hello&quot;);
</code></pre>
<p>If we change the file (using <code>write_until_modified</code> to ensure that the modified time changes to trigger the <code>Modified</code> file stamper) and require the task, it should execute, because the file dependency of the task is no longer consistent.</p>
<h4 id="new-write-task-reuse-read-task"><a class="header" href="#new-write-task-reuse-read-task">New write task, reuse read task</a></h4>
<p>Insert into the <code>main</code> method:</p>
<pre><code class="language-rust ">  println!(&quot;\nD) New task, reuse other: expect only `write_task` to execute&quot;);
  // write_task` is new, but `read_task` is not new and its file dependency is still consistent.
  context.require_task(&amp;write_task)?;
  assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello&quot;);
</code></pre>
<p>Now we require a new <code>WriteStringToFile</code> task, which requires the <code>ReadStringFromFile</code> task.
However, since the read task is still consistent (its file dependency is consistent), we only expect the write task to execute. 
We also assert that the write task wrote the correct string to the file.</p>
<h4 id="sound-incrementality-with-top-down-building"><a class="header" href="#sound-incrementality-with-top-down-building">Sound incrementality with top-down building</a></h4>
<p>Insert into the <code>main</code> method:</p>
<pre><code class="language-rust ">  write_until_modified(&amp;input_file, &quot;Hello, World!&quot;)?;
  println!(&quot;\nE) Inconsistent file and task dependency: expect both tasks to execute&quot;);
  // The file dependency of `read_task` is inconsistent. Then, the task dependency from `write_task` to `read_task` is 
  // inconsistent because `read_task` now returns `&quot;Hello, World!&quot;` as output instead of &quot;Hello&quot;, and thus its equals 
  // output stamp is different.
  context.require_task(&amp;write_task)?;
  assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello, World!&quot;);
</code></pre>
<p>We change the input file and expect both read and write tasks to execute.
We require the write task, which checks whether it should be executed by consistency checking its dependencies.
The write task has a task dependency to the read task, so we check that for consistency.
That recurses into requiring the read task, where we again check whether it should be executed.
There, we discover that its input file dependency is inconsistent, so we execute the read task, which now returns <code>&quot;Hello, World!&quot;</code> instead of <code>&quot;Hello&quot;</code>.</p>
<p>Now we are back to the consistency check for the task dependency from the write task to the read task.
The previous output stamp for that task dependency is <code>Equals(&quot;Hello&quot;)</code>, but the new stamp is <code>Equals(&quot;Hello, World!&quot;)</code>, so the task dependency is inconsistent!
Therefore, we execute the write task, which correctly writes the new string to the output file.</p>
<p>This example shows why we need top-down incremental building for sound incrementality.
To ensure that the write task writes the up-to-date string to the output file, we first need to check (and possibly execute) the read task, ensuring it returns the up-to-date string.</p>
<h4 id="early-cutoff"><a class="header" href="#early-cutoff">Early cutoff</a></h4>
<p>Insert into the <code>main</code> method:</p>
<pre><code class="language-rust ">  write_until_modified(&amp;input_file, &quot;Hello, World!&quot;)?; // Note: writing same file contents!
  println!(&quot;\nF) Early cutoff: expect only `read_task` to execute&quot;);
  // File dependency of `read_task` is inconsistent because the modified time changed, but it returns the same output 
  // `&quot;Hello, World!&quot;` because the contents of the file have not actually changed. Then, the task dependency from 
  // `write_task` to `read_task` is consistent because its output did not change, and thus the equality output stamp is 
  // the same.
  context.require_task(&amp;write_task)?;
  assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello, World!&quot;);
</code></pre>
<p>This is very similar to the last operation.
The subtle difference is that we <em>are</em> writing to the input file, but we <em>write the same contents</em>.
This results in a file with a new modified time, but the same contents.</p>
<p>We expect the read task to execute, because its file dependency is inconsistent.
However, the previous output stamp of the task dependency from write to read is <code>Equals(&quot;Hello, World!&quot;)</code>, but the new one is also <code>Equals(&quot;Hello, World!&quot;)</code> because the read task still returns <code>&quot;Hello, World!&quot;</code>.
Therefore, the task dependency is consistent, and we do not execute the write task.</p>
<p>We call this <em>early cutoff</em>, because we can cut off building a task early, if we figure out its task dependency is consistent <em>due to having the same output stamp</em>.
Early cutoff is possible due to the precise dependency tracking provided by dynamic dependencies.
This is one of the pieces that makes this build system incremental: we don't execute the write task because it is not affected by a change.</p>
<details id="admonition-different-stampers" class="admonition info">
<summary class="admonition-title">
<p>Different stampers</p>
<p><a class="admonition-anchor-link" href="2_incrementality/5_context/index.html#admonition-different-stampers"></a></p>
</summary>
<div>
<p>If we want the write task to always write to the output file regardless of what the read task returns, we could implement an <code>Always</code> output stamp that is always inconsistent.</p>
<p>In general, output (and file) stamps can be used to finetune incrementality, ensuring that tasks are only executed when they are really affected by a change.</p>
</div>
</details>
<h4 id="regenerate-output-files"><a class="header" href="#regenerate-output-files">Regenerate output files</a></h4>
<p>Insert into the <code>main</code> method:</p>
<pre><code class="language-rust ">  write_until_modified(&amp;output_file, &quot;&quot;)?;
  println!(&quot;\nG) Regenerate changed output file: expect only `write_task` to execute&quot;);
  // The file dependency of `write_task` to `output_file` is inconsistent.
  context.require_task(&amp;write_task)?;
  assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello, World!&quot;);

  write_until_modified(&amp;output_file, &quot;&quot;)?;
  remove_file(&amp;output_file)?;
  println!(&quot;\nH) Regenerate deleted output file: expect only `write_task` to execute&quot;);
  // Same results when `output_file` is deleted.
  context.require_task(&amp;write_task)?;
  assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello, World!&quot;);
</code></pre>
<p>The write task writes to an output file and then creates a file dependency to it.
Therefore, if we modify or remove the output file, and require the write task, it will regenerate the output file because the file dependency is inconsistent.</p>
<p>Many build systems do not track this dependency to output files, which can result in incrementality bugs due to output files being deleted (for example, due to a <code>git clean</code>).
By tracking these output file dependencies, we ensure that the output files are in a consistent state after every build.</p>
<details id="admonition-dont-regenerate-ouput-files" class="admonition info">
<summary class="admonition-title">
<p>Don't regenerate ouput files</p>
<p><a class="admonition-anchor-link" href="2_incrementality/5_context/index.html#admonition-dont-regenerate-ouput-files"></a></p>
</summary>
<div>
<p>We can omit the file dependency in the write task to not regenerate output files when they are changed or deleted, if desired.
However, this is not recommended due to the possibility of (incrementality) bugs.</p>
</div>
</details>
<h4 id="different-tasks"><a class="header" href="#different-tasks">Different tasks</a></h4>
<p>Insert into the <code>main</code> method:</p>
<pre><code class="language-rust ">  let input_file_b = temp_dir.path().join(&quot;input_b.txt&quot;);
  write(&amp;input_file_b, &quot;Test&quot;)?;
  let read_task_b_modified = ReadStringFromFile::new(&amp;input_file_b, FileStamper::Modified);
  let read_task_b_exists = ReadStringFromFile::new(&amp;input_file_b, FileStamper::Exists);
  println!(&quot;\nI) Different tasks: expect `read_task_b_modified` and `read_task_b_exists` to execute&quot;);
  // Task `read_task`, `read_task_b_modified` and `read_task_b_exists` are different, due to their `Eq` implementation 
  // determining that their paths and stampers are different. Therefore, `read_task_b_modified` and `read_task_b_exists`
  // are new tasks, and must be executed.
  let output = context.require_task(&amp;read_task_b_modified)?;
  assert_eq!(&amp;output, &quot;Test&quot;);
  let output = context.require_task(&amp;read_task_b_exists)?;
  assert_eq!(&amp;output, &quot;Test&quot;);
</code></pre>
<p>The identity of tasks is determined by their <code>Eq</code> and <code>Hash</code> implementations, which are typically derived to compare and hash all their fields.
Therefore, if we create read tasks for different input file <code>input_file_b</code> and different stamper <code>FileStamper::Exists</code>, these read tasks are not equal to the existing read task, and thus are <em>new</em> tasks with a different identity.
We require <code>read_task_b_modified</code> and <code>read_task_b_exists</code>, they are new, and are therefore executed.</p>
<h4 id="same-file-different-stampers"><a class="header" href="#same-file-different-stampers">Same file different stampers</a></h4>
<p>Insert into the <code>main</code> method:</p>
<pre><code class="language-rust ">  write_until_modified(&amp;input_file_b, &quot;Test Test&quot;)?;
  println!(&quot;\nJ) Different stampers: expect only `read_task_b_modified` to execute&quot;);
  // Both `read_task_b_modified` and `read_task_b_exists` read from the same file, but they use different stampers.
  // Therefore, `read_task_b_modified` must be executed because the modified time has changed, but `read_task_b_exists`
  // will not be executed because its file dependency stamper only checks for existence of the file, and the existence 
  // of the file has not changed.
  //
  // Note that using an `Exists` stamper for this task does not make a lot of sense, since it will only read the file 
  // on first execute and when it is recreated. But this is just to demonstrate different stampers.
  let output = context.require_task(&amp;read_task_b_modified)?;
  assert_eq!(&amp;output, &quot;Test Test&quot;);
  let output = context.require_task(&amp;read_task_b_exists)?;
  assert_eq!(&amp;output, &quot;Test&quot;);
</code></pre>
<p>Here we write to <code>input_file_b</code> and then require <code>read_task_b_modified</code> and <code>read_task_b_exists</code>.
We expect <code>read_task_b_modified</code> to be executed, but <code>read_task_b_exists</code> to be skipped, because its file dependency only checks for the existence of the input file, which has not changed.
This shows that tasks can depend on the same file with different stampers, which influences whether the tasks are affected by a file change individually.</p>
<p>Of course, using an <code>Exists</code> stamper for <code>ReadStringFromFile</code> does not make a lot of sense, but this is for demonstration purposes only.</p>
<p>Running <code>cargo run --example incremental</code> now should produce output like:</p>
<pre><code>   Compiling pie v0.1.0 (/private/pie)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68s
     Running `/private/pie/target/debug/examples/incremental`
A) New task: expect `read_task` to execute
Reading from input.txt with Modified stamper

B) Reuse: expect no execution

C) Inconsistent file dependency: expect `read_task` to execute
Reading from input.txt with Modified stamper

D) New task, reuse other: expect only `write_task` to execute
Writing to output.txt with Modified stamper

E) Inconsistent file and task dependency: expect both tasks to execute
Reading from input.txt with Modified stamper
Writing to output.txt with Modified stamper

F) Early cutoff: expect only `read_task` to execute
Reading from input.txt with Modified stamper

G) Regenerate changed output file: expect only `write_task` to execute
Writing to output.txt with Modified stamper

H) Regenerate deleted output file: expect only `write_task` to execute
Writing to output.txt with Modified stamper

I) Different tasks: expect `read_task_b_modified` and `read_task_b_exists` to execute
Reading from input_b.txt with Modified stamper
Reading from input_b.txt with Exists stamper

J) Different stampers: expect only `read_task_b_modified` to execute
Reading from input_b.txt with Modified stamper
</code></pre>
<p>Feel free to experiment more with this example (or new example files) before continuing.
In the next chapter, we will define minimality and soundness, set up an infrastructure for testing those properties, and fix issues uncovered by testing.</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="2_incrementality/5_context/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="2_incrementality/5_context/../../gen/2_incrementality/5b_context_example/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimality-and-soundness"><a class="header" href="#minimality-and-soundness">Minimality and Soundness</a></h1>
<p>So far, the definitions we've used for minimality (incrementality) and soundness (correctness) have been a bit vague.
Let's define this more concretely and precisely.</p>
<p>An incremental and sound build system executes a task, if and only if, it is new or affected by a change.
A task is new if it has not been executed before.
When it is not new, a task is affected by a change when any of its dependencies are inconsistent.
A file dependency is inconsistent if its file stamp changes.
A task dependency is inconsistent if, after recursively checking the task, its output stamp changes. 
The recursive nature of checking task dependencies ensures that indirect changes can affect tasks and cause them to be correctly executed.</p>
<p>By defining minimality and soundness in terms of dependencies, a task author forgetting to create a dependency or not choosing the correct stamper, does not change whether our build system is minimal and sound.
PIE works under the assumption that task authors correctly list all dependencies that mark their task as affected by a change when it actually is. </p>
<details id="admonition-preventing-task-authoring-mistakes" class="admonition info">
<summary class="admonition-title">
<p>Preventing task authoring mistakes</p>
<p><a class="admonition-anchor-link" href="3_min_sound/index.html#admonition-preventing-task-authoring-mistakes"></a></p>
</summary>
<div>
<p>It is of course possible to make mistakes when authoring tasks, for example by creating a dependency to the wrong file, or by forgetting to create a file dependency.
Unfortunately, there is no easy way to solve this.</p>
<p>We will be writing a build event tracking system later, for which we will make an implementation that writes the entire build log to standard output.
This build log can help debug mistakes by precisely showing what the build system is doing.</p>
<p>A technique to catch file dependency mistakes is by sandboxing the filesystem to only have access to files that have been required.
For example, Bazel can perform <a href="https://bazel.build/docs/sandboxing">sandboxing</a>, but it is not fully cross-platform, and still allows reading files from absolute paths.
If a cross-platform and bulletproof sandboxing library exists, it could help catch file dependency mistakes in programmatic incremental build systems.</p>
<p>Finally, the ultimate technique to catch file dependency mistakes is by automatically creating these dependencies using filesystem tracing, instead of having the task author make them.
For example, the <a href="https://github.com/ndmitchell/rattle">Rattle</a> build system uses <a href="https://github.com/jacereda/fsatrace">fsatrace</a> to automatically create file dependencies, freeing task authors from having to think about file dependencies
However, filesystem tracing is also not fully cross-platform and bulletproof, so it cannot always be used.
Again, if a cross-platform and bulletproof filesystem tracing library exists, it would be extremely useful for programmatic incremental build systems.</p>
</div>
</details>
<p>In this chapter, we will show minimality and soundness by testing.
However, before testing, we make minimality and soundness more precise by changing the API to work with <em>sessions</em>, and implement build event tracking that is needed for testing.
We will continue as follows:</p>
<ol>
<li>Introduce sessions and change the API to work with sessions: <code>Session</code> type for performing builds in a session, and the <code>Pie</code> type as the entry point that manages sessions.</li>
<li>Create infrastructure to track build events for testing and debugging purposes. Create the <code>Tracker</code> trait, and implement a <code>WritingTracker</code> for debugging and <code>EventTracker</code> for testing.</li>
<li>Find a soundness hole where multiple tasks write to the same file. Fix it by tracking file write dependencies separately from read dependencies, and catch these mistakes with dynamic verification.</li>
<li>Find a soundness hole where a task reads from a file before another task writes to it. Fix it by catching these mistakes with dynamic verification.</li>
<li>Find a soundness hole where cyclic task execution can still occur. Fix it by changing how task dependencies are stored.</li>
</ol>
<details id="admonition-proving-minimality-and-soundness" class="admonition info">
<summary class="admonition-title">
<p>Proving minimality and soundness?</p>
<p><a class="admonition-anchor-link" href="3_min_sound/index.html#admonition-proving-minimality-and-soundness"></a></p>
</summary>
<div>
<p>While proving minimality and soundness would be a very interesting exercise, I am not at all an expert in formal proofs in proof assistants such as <a href="https://coq.inria.fr/">Coq</a>, <a href="https://wiki.portal.chalmers.se/agda/pmwiki.php">Agda</a>, etc.
If that is something that interests you, do pursue it and get in touch!</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimality-with-sessions"><a class="header" href="#minimality-with-sessions">Minimality with Sessions</a></h1>
<p>A task is consistent if its dependencies are consistent, and consistency of file dependencies is based on the filesystem.
However, the filesystem can change during a build, meaning that a task can be affected by multiple different changes in one build.
For example, after executing a task, it could immediately be affected by a change in a source file again without the build system knowing about it, and that would not be minimal nor sound.</p>
<p>Therefore, we will introduce the concept of a <em>session</em>.
Builds are only performed in a session, and at most one session may exist at any given time.
In one session, each task is checked or executed <em>at most once</em>, meaning that changes made to source files during a session are <em>not guaranteed to be detected</em>.</p>
<p>The result is that if a task is deemed inconsistent at the time it is checked, it will be executed, and will not be checked nor executed any more that session.
If a task is deemed consistent at the time it is checked, it will not be checked any more that session.
This simplifies minimality and soundness, as we do not need to worry about checking tasks multiple times.
Furthermore, it is also an optimisation, as requiring the same task many times only results in one check.</p>
<p>We will implement the <code>Session</code> type to hold all session data, and the <code>Pie</code> type as an entry point into the build system that manages a session.</p>
<h2 id="pie-and-session"><a class="header" href="#pie-and-session">PIE and Session</a></h2>
<p>Change the imports in <code>pie/src/lib.rs</code>: </p>
<pre><code class="language-rust customdiff "> use std::io;
 use std::path::Path;

 use stamp::{FileStamper, OutputStamper};

+use crate::context::top_down::TopDownContext;
+use crate::store::{Store, TaskNode};
+
 pub mod stamp;
 pub mod context;
 mod fs;
 mod dependency;
 mod store;</code></pre>
<p>Now add the <code>Pie</code> and <code>Session</code> types to <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust ">/// Main entry point into PIE, a sound and incremental programmatic build system.
pub struct Pie&lt;T, O&gt; {
  store: Store&lt;T, O&gt;,
}

impl&lt;T: Task&gt; Default for Pie&lt;T, T::Output&gt; {
  fn default() -&gt; Self { Self { store: Store::default() } }
}

impl&lt;T: Task&gt; Pie&lt;T, T::Output&gt; {
  /// Creates a new build session. Only one session may be active at once, enforced via mutable (exclusive) borrow.
  pub fn new_session(&amp;mut self) -&gt; Session&lt;T, T::Output&gt; { Session::new(self) }
  /// Runs `f` inside a new build session.
  pub fn run_in_session&lt;R&gt;(&amp;mut self, f: impl FnOnce(Session&lt;T, T::Output&gt;) -&gt; R) -&gt; R {
    let session = self.new_session();
    f(session)
  }
}

/// A session in which builds are executed.
pub struct Session&lt;'p, T, O&gt; {
  store: &amp;'p mut Store&lt;T, O&gt;,
  current_executing_task: Option&lt;TaskNode&gt;,
  dependency_check_errors: Vec&lt;io::Error&gt;,
}

impl&lt;'p, T: Task&gt; Session&lt;'p, T, T::Output&gt; {
  fn new(pie: &amp;'p mut Pie&lt;T, T::Output&gt;) -&gt; Self {
    Self {
      store: &amp;mut pie.store,
      current_executing_task: None,
      dependency_check_errors: Vec::default(),
    }
  }

  /// Requires `task`, returning its up-to-date output.
  pub fn require(&amp;mut self, task: &amp;T) -&gt; T::Output {
    todo!(&quot;Create TopDownContext with this session, and require the task&quot;)
  }

  /// Gets all errors produced during dependency checks.
  pub fn dependency_check_errors(&amp;self) -&gt; impl Iterator&lt;Item=&amp;io::Error&gt; { self.dependency_check_errors.iter() }
}</code></pre>
<p>We set up the types such that <code>Pie</code> owns the store, and <code>Session</code> owns all data for a build session that <code>TopDownContext</code> previously owned.
We put the store in <code>Pie</code> because we want to keep the dependency graph and task outputs between build sessions, otherwise we cannot be incremental.</p>
<p>A <code>Session</code> is created with <code>Pie::new_session</code>, which borrows <code>Pie</code> mutibly, ensuring that there can only be one <code>Session</code> instance (per <code>Pie</code> instance).
<code>run_in_session</code> is a convenience method that runs given function inside a new session.</p>
<p><code>Session::require</code> should require the task with the top-down context and return its up-to-date output, which we will implement once we've changed <code>TopDownContext</code>.
The dependency check errors can be accessed with <code>Session::dependency_check_errors</code>.</p>
<p>Note that <code>Session</code> also has access to <code>Store</code>, because <code>TopDownContext</code> needs access to the store.
The store is mutibly borrowed from <code>Pie</code>.
Therefore, the <code>Session</code> struct is generic over the <code>'p</code> lifetime, where the <code>p</code> stands for <code>Pie</code>.
We can leave out this lifetime in <code>Pie::new_session</code>, because the compiler infers it from us, but we must be explicit in structs and most impls.</p>
<p>Check that the code compiles (but gives warnings) with <code>cargo check</code>.</p>
<p>Now we need to modify <code>TopDownContext</code> to work with <code>Session</code>.</p>
<h2 id="update-topdowncontext"><a class="header" href="#update-topdowncontext">Update TopDownContext</a></h2>
<p>Change <code>TopDownContext</code> to only contain a mutable reference to <code>Session</code> in <code>pie/src/context/top_down.rs</code>:</p>
<pre><code class="language-rust customdiff "> use std::fs::File;
 use std::io;
 use std::path::Path;

-use crate::{Context, fs, Task};
+use crate::{Context, fs, Session, Task};
 use crate::dependency::{FileDependency, TaskDependency};
 use crate::stamp::{FileStamper, OutputStamper};
-use crate::store::{Store, TaskNode};
+use crate::store::TaskNode;

-pub struct TopDownContext&lt;T, O&gt; {
-  store: Store&lt;T, O&gt;,
-  current_executing_task: Option&lt;TaskNode&gt;,
-  dependency_check_errors: Vec&lt;io::Error&gt;,
+pub struct TopDownContext&lt;'p, 's, T, O&gt; {
+  session: &amp;'s mut Session&lt;'p, T, O&gt;,
 }

-impl&lt;T: Task&gt; TopDownContext&lt;T, T::Output&gt; {
-  pub fn new() -&gt; Self {
-    Self {
-      store: Store::default(),
-      current_executing_task: None,
-      dependency_check_errors: Vec::default(),
-    }
-  }
+impl&lt;'p, 's, T: Task&gt; TopDownContext&lt;'p, 's, T, T::Output&gt; {
+  pub fn new(session: &amp;'s mut Session&lt;'p, T, T::Output&gt;) -&gt; Self { Self { session } }

-  pub fn get_dependency_check_errors(&amp;self) -&gt; impl Iterator&lt;Item=&amp;io::Error&gt; {
-    self.dependency_check_errors.iter()
+  pub fn require_initial(&amp;mut self, task: &amp;T) -&gt; T::Output {
+    self.require_task(task)
   }
 }


 impl&lt;T: Task&gt; Context&lt;T&gt; for TopDownContext&lt;T, T::Output&gt; {</code></pre>
<p>Here, we use lifetime <code>'s</code> to denote the lifetime of a session, and make <code>TopDownContext</code> generic over it.
<code>new</code> now just accepts a mutable reference to the session.
The <code>get_dependency_check_errors</code> method can be removed.
We add a <code>require_initial</code> convenience method for <code>Session</code>.</p>
<p>In the rest of the file, we need to update the <code>impl</code> lines to include the lifetimes, and we need to replace most instances of <code>self</code> with <code>self.session</code>.
You could do this with the following find-replace regex: <code>self\.([\w\d_]+)\.</code> -&gt; <code>self.session.$1.</code></p>
<p>Change <code>pie/src/context/top_down.rs</code>:</p>
<pre><code class="language-rust customdiff ">     self.require_task(task)
   }
 }


-impl&lt;T: Task&gt; Context&lt;T&gt; for TopDownContext&lt;T, T::Output&gt; {
+impl&lt;'p, 's, T: Task&gt; Context&lt;T&gt; for TopDownContext&lt;'p, 's, T, T::Output&gt; {
   fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
-    let Some(current_executing_task_node) = &amp;self.current_executing_task else {
+    let Some(current_executing_task_node) = &amp;self.session.current_executing_task else {
       return fs::open_if_file(path); // No current executing task, so no dependency needs to be made.
     };
     let path = path.as_ref();
-    let node = self.store.get_or_create_file_node(path);
+    let node = self.session.store.get_or_create_file_node(path);
     let (dependency, file) = FileDependency::new_with_file(path, stamper)?;
-    self.store.add_file_require_dependency(current_executing_task_node, &amp;node, dependency);
+    self.session.store.add_file_require_dependency(current_executing_task_node, &amp;node, dependency);
     Ok(file)
   }

   fn require_task_with_stamper(&amp;mut self, task: &amp;T, stamper: OutputStamper) -&gt; T::Output {
-    let node = self.store.get_or_create_task_node(task);
+    let node = self.session.store.get_or_create_task_node(task);

     // Get required task output by executing it if needed, or by getting the output from the store if not needed.
     let output = if self.should_execute_task(&amp;node) {
-      self.store.reset_task(&amp;node);
-      let previous_executing_task = self.current_executing_task.replace(node);
+      self.session.store.reset_task(&amp;node);
+      let previous_executing_task = self.session.current_executing_task.replace(node);
       let output = task.execute(self);
-      self.current_executing_task = previous_executing_task;
-      self.store.set_task_output(&amp;node, output.clone());
+      self.session.current_executing_task = previous_executing_task;
+      self.session.store.set_task_output(&amp;node, output.clone());
       output
     } else {
       // Correctness: when `should_execute_task` returns `true`, the above block is executed. Otherwise this block is 
       // executed and `should_execute_task` ensures that the task has an output.
-      self.store.get_task_output(&amp;node).clone()
+      self.session.store.get_task_output(&amp;node).clone()
     };

     // Create task require dependency if a task is currently executing (i.e., we are not requiring the initial task).
-    if let Some(current_executing_task_node) = &amp;self.current_executing_task {
+    if let Some(current_executing_task_node) = &amp;self.session.current_executing_task {
       let dependency = TaskDependency::new(task.clone(), stamper, output.clone());
-      if self.store.add_task_require_dependency(current_executing_task_node, &amp;node, dependency).is_err() {
-        let current_executing_task = self.store.get_task(current_executing_task_node);
+      if self.session.store.add_task_require_dependency(current_executing_task_node, &amp;node, dependency).is_err() {
+        let current_executing_task = self.session.store.get_task(current_executing_task_node);
         panic!(&quot;Cyclic task dependency; current executing task '{:?}' is requiring task '{:?}' which was already required&quot;, current_executing_task, task);
       }
     }

     output
   }
 }

-impl&lt;T: Task&gt; TopDownContext&lt;T, T::Output&gt; {
+impl&lt;'p, 's, T: Task&gt; TopDownContext&lt;'p, 's, T, T::Output&gt; {
   /// Checks whether given task should be executed, returning `true` if it should be executed. A task should be executed
   /// if any of its dependencies are inconsistent, or when it has no output.
   fn should_execute_task(&amp;mut self, node: &amp;TaskNode) -&gt; bool {
     // Borrow: because we pass `self` (which is `&amp;mut self`) to `is_inconsistent` for recursive consistency checking, 
     //         we need to clone and collect dependencies into a `Vec`. Otherwise we have an immutable borrow of `self`
     //         through `self.store` while we create a mutable borrow of `self`, which is not allowed.
-    let dependencies: Vec&lt;_&gt; = self.store.get_dependencies_of_task(node).cloned().collect();
+    let dependencies: Vec&lt;_&gt; = self.session.store.get_dependencies_of_task(node).cloned().collect();
     for dependency in dependencies {
       match dependency.is_inconsistent(self) {
         Ok(Some(_)) =&gt; return true,
         Err(e) =&gt; { // Error while checking: store error and assume inconsistent
-          self.dependency_check_errors.push(e);
+          self.session.dependency_check_errors.push(e);
           return true;
         }
         _ =&gt; {} // Consistent: continue checking
       }
     }
     // Task has no dependencies or all dependencies are consistent. Should only execute if it has no output, meaning
     // that it has never been executed before.
-    return !self.store.task_has_output(node);
+    return !self.session.store.task_has_output(node);
   }
 }</code></pre>
<p>Now we change <code>Session</code> to use <code>TopDownContext</code>. </p>
<h2 id="update-session"><a class="header" href="#update-session">Update Session</a></h2>
<p>Change <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff ">     }
   }

   /// Requires `task`, returning its up-to-date output.
   pub fn require(&amp;mut self, task: &amp;T) -&gt; T::Output {
-    todo!(&quot;Create TopDownContext with this session, and require the task&quot;)
+    self.current_executing_task = None;
+    TopDownContext::new(self).require_initial(task)
   }

   /// Gets all errors produced during dependency checks.
   pub fn dependency_check_errors(&amp;self) -&gt; impl Iterator&lt;Item=&amp;io::Error&gt; { self.dependency_check_errors.iter() }
 }</code></pre>
<p>We reset the <code>current_executing_task</code> to <code>None</code>, to be sure that we start a build without an executing task.
Then, we just create a <code>TopDownContext</code> and call <code>require_initial</code>.</p>
<p>Finally, we can now make the <code>context</code> module private, as users of the library run builds using <code>Session</code>, instead of having to create a context implementation.
Change <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff ">
 use crate::context::top_down::TopDownContext;
 use crate::store::{Store, TaskNode};

 pub mod stamp;
-pub mod context;
+mod context;
 mod fs;
 mod dependency;
 mod store;

 /// A unit of computation in a programmatic incremental build system.</code></pre>
<p>Check that the code compiles with <code>cargo check --lib</code>.
This only checks if the library builds, but not any examples.
We need to update the incrementality example to work with these changes.</p>
<h2 id="update-incremental-example"><a class="header" href="#update-incremental-example">Update incremental example</a></h2>
<p>First change some imports in <code>pie/examples/incremental.rs</code>:</p>
<pre><code class="language-rust customdiff "> use std::fs::{File, read_to_string, remove_file, write};
 use std::io::{self, Read, Write};
 use std::path::{Path, PathBuf};

 use dev_shared::{create_temp_dir, write_until_modified};
-use pie::{Context, Task};
-use pie::context::top_down::TopDownContext;
+use pie::{Context, Pie, Task};
 use pie::stamp::FileStamper;

 /// Enumeration over file pseudo-tasks.
 #[derive(Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]
 enum FileTask {</code></pre>
<p>Then, change <code>pie/examples/incremental.rs</code> to use sessions:</p>
<pre><code class="language-rust customdiff ">     Ok(())
   }
 }

 fn main() -&gt; Result&lt;(), io::Error&gt; {
   let temp_dir = create_temp_dir()?;
   let input_file = temp_dir.path().join(&quot;input.txt&quot;);
   write(&amp;input_file, &quot;Hi&quot;)?;
   let output_file = temp_dir.path().join(&quot;output.txt&quot;);

-  let mut context = TopDownContext::new();
+  let mut pie = Pie::default();
   let read_task = ReadStringFromFile::new(&amp;input_file, FileStamper::Modified);
   let write_task = WriteStringToFile::new(read_task.clone(), &amp;output_file, FileStamper::Modified);

   println!(&quot;A) New task: expect `read_task` to execute&quot;);
   // `read_task` is new, meaning that we have no cached output for it, thus it must be executed.
-  let output = context.require_task(&amp;read_task)?;
+  let output = pie.new_session().require(&amp;read_task)?;
   assert_eq!(&amp;output, &quot;Hi&quot;);

   println!(&quot;\nB) Reuse: expect no execution&quot;);
   // `read_task` is not new and its file dependency is still consistent. It is consistent because the modified time of 
   // `input_file` has not changed, thus the modified stamp is equal.
-  let output = context.require_task(&amp;read_task)?;
+  let output = pie.new_session().require(&amp;read_task)?;
   assert_eq!(&amp;output, &quot;Hi&quot;);

   write_until_modified(&amp;input_file, &quot;Hello&quot;)?;
   println!(&quot;\nC) Inconsistent file dependency: expect `read_task` to execute&quot;);
   // The file dependency of `read_task` is inconsistent due to the changed modified time of `input_file`.
-  let output = context.require_task(&amp;read_task)?;
+  let output = pie.new_session().require(&amp;read_task)?;
   assert_eq!(&amp;output, &quot;Hello&quot;);

   println!(&quot;\nD) New task, reuse other: expect only `write_task` to execute&quot;);
   // write_task` is new, but `read_task` is not new and its file dependency is still consistent.
-  context.require_task(&amp;write_task)?;
+  pie.new_session().require(&amp;write_task)?;
   assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello&quot;);

   write_until_modified(&amp;input_file, &quot;Hello, World!&quot;)?;
   println!(&quot;\nE) Inconsistent file and task dependency: expect both tasks to execute&quot;);
   // The file dependency of `read_task` is inconsistent. Then, the task dependency from `write_task` to `read_task` is 
   // inconsistent because `read_task` now returns `&quot;Hello, World!&quot;` as output instead of &quot;Hello&quot;, and thus its equals 
   // output stamp is different.
-  context.require_task(&amp;write_task)?;
+  pie.new_session().require(&amp;write_task)?;
   assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello, World!&quot;);

   write_until_modified(&amp;input_file, &quot;Hello, World!&quot;)?; // Note: writing same file contents!
   println!(&quot;\nF) Early cutoff: expect only `read_task` to execute&quot;);
   // File dependency of `read_task` is inconsistent because the modified time changed, but it returns the same output 
   // `&quot;Hello, World!&quot;` because the contents of the file have not actually changed. Then, the task dependency from 
   // `write_task` to `read_task` is consistent because its output did not change, and thus the equality output stamp is 
   // the same.
-  context.require_task(&amp;write_task)?;
+  pie.new_session().require(&amp;write_task)?;
   assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello, World!&quot;);

   write_until_modified(&amp;output_file, &quot;&quot;)?;
   println!(&quot;\nG) Regenerate changed output file: expect only `write_task` to execute&quot;);
   // The file dependency of `write_task` to `output_file` is inconsistent.
-  context.require_task(&amp;write_task)?;
+  pie.new_session().require(&amp;write_task)?;
   assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello, World!&quot;);

   write_until_modified(&amp;output_file, &quot;&quot;)?;
   remove_file(&amp;output_file)?;
   println!(&quot;\nH) Regenerate deleted output file: expect only `write_task` to execute&quot;);
   // Same results when `output_file` is deleted.
-  context.require_task(&amp;write_task)?;
+  pie.new_session().require(&amp;write_task)?;
   assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello, World!&quot;);

   let input_file_b = temp_dir.path().join(&quot;input_b.txt&quot;);
   write(&amp;input_file_b, &quot;Test&quot;)?;
   let read_task_b_modified = ReadStringFromFile::new(&amp;input_file_b, FileStamper::Modified);
   let read_task_b_exists = ReadStringFromFile::new(&amp;input_file_b, FileStamper::Exists);
   println!(&quot;\nI) Different tasks: expect `read_task_b_modified` and `read_task_b_exists` to execute&quot;);
   // Task `read_task`, `read_task_b_modified` and `read_task_b_exists` are different, due to their `Eq` implementation 
   // determining that their paths and stampers are different. Therefore, `read_task_b_modified` and `read_task_b_exists`
   // are new tasks, and must be executed.
-  let output = context.require_task(&amp;read_task_b_modified)?;
+  let mut session = pie.new_session();
+  let output = session.require(&amp;read_task_b_modified)?;
   assert_eq!(&amp;output, &quot;Test&quot;);
-  let output = context.require_task(&amp;read_task_b_exists)?;
+  let output = session.require(&amp;read_task_b_exists)?;
   assert_eq!(&amp;output, &quot;Test&quot;);

   write_until_modified(&amp;input_file_b, &quot;Test Test&quot;)?;
   println!(&quot;\nJ) Different stampers: expect only `read_task_b_modified` to execute&quot;);
   // Both `read_task_b_modified` and `read_task_b_exists` read from the same file, but they use different stampers.
   // Therefore, `read_task_b_modified` must be executed because the modified time has changed, but `read_task_b_exists`
   // will not be executed because its file dependency stamper only checks for existence of the file, and the existence 
   // of the file has not changed.
   //
   // Note that using an `Exists` stamper for this task does not make a lot of sense, since it will only read the file 
   // on first execute and when it is recreated. But this is just to demonstrate different stampers.
-  let output = context.require_task(&amp;read_task_b_modified)?;
+  let mut session = pie.new_session();
+  let output = session.require(&amp;read_task_b_modified)?;
   assert_eq!(&amp;output, &quot;Test Test&quot;);
-  let output = context.require_task(&amp;read_task_b_exists)?;
+  let output = session.require(&amp;read_task_b_exists)?;
   assert_eq!(&amp;output, &quot;Test&quot;);

   Ok(())
 }</code></pre>
<p>When we only require one task, we replace <code>context.require_task</code> with <code>pie.new_session().require</code>.
When we want to require multiple tasks, we use <code>new_session</code> and call <code>session.require</code> multiple times.</p>
<p>It is very important to create a new session each time in this example, because a task is only checked/executed once each session.
If we use a single session, our changes are never seen, and we just execute each task once, which is not what we want.
Therefore, every time we make changes to source files, or expect that changes have been made to source files, we must create a new session.</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="3_min_sound/1_session/index.html#admonition-note"></a></p>
</div>
<div>
<p>In changes I and J, Rust is smart enough to allow creating a new session even though the previous <code>session</code> variable is still active, because it knows that we don't use that previous session anymore.</p>
</div>
</div>
<p>Check that all code works by running <code>cargo test</code>.</p>
<p>With this new API in place, and all code adjusted to work with it, we can continue with tracking build events.</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="3_min_sound/1_session/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="3_min_sound/1_session/../../gen/3_min_sound/1_session/source.zip">download the source files up to this point</a>.</p>
</div>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracking-build-events"><a class="header" href="#tracking-build-events">Tracking Build Events</a></h1>
<p>So far we have had no convenient way to inspect what our build system is doing, apart from <code>println!</code> debugging or attaching a debugger to the program.
In this section, we will change that by tracking build events for debugging and integration testing purposes.</p>
<p>We will:</p>
<ol>
<li>Create a <code>Tracker</code> trait that receives build events through method calls. The <code>Tracker</code> trait can be implemented in different ways to handle build events in different ways.</li>
<li>Implement a <code>NoopTracker</code> that does nothing, removing the tracking overhead.</li>
<li>Make the build system generic over <code>Tracker</code>, such that <code>Context</code> implementations call methods on the tracker to create build events.</li>
<li>Implement a <code>WritingTracker</code> that writes build events to standard output or standard error, for debugging purposes.</li>
<li>Implement an <code>EventTracker</code> that stores build events for later inspection, for integration testing purposes.</li>
<li>Implement a <code>CompositeTracker</code> that forwards build events to 2 other trackers, so we can use multiple trackers at the same time.</li>
</ol>
<h2 id="tracker-trait"><a class="header" href="#tracker-trait"><code>Tracker</code> trait</a></h2>
<p>Add the <code>tracker</code> module to <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-diff2html">--- lib.rs
+++ lib.rs
@@ -8,10 +8,11 @@

 use crate::context::top_down::TopDownContext;
 use crate::store::{Store, TaskNode};

 pub mod stamp;
+pub mod tracker;
 mod context;
 mod fs;
 mod dependency;
 mod store;
</code></pre>
<p>Then create the <code>pie/src/tracker</code> directory, create the <code>pie/src/tracker/mod.rs</code> file, and add the following content:</p>
<pre><code class="language-rust ">use std::path::Path;

use crate::stamp::{FileStamp, FileStamper, OutputStamp, OutputStamper};
use crate::Task;

/// Trait for tracking build events. Can be used to implement logging, event tracing, progress tracking, metrics, etc.
#[allow(unused_variables)]
pub trait Tracker&lt;T: Task&gt; {
  /// Start a new build.
  fn build_start(&amp;mut self) {}
  /// A build has been completed.
  fn build_end(&amp;mut self) {}

  /// A file at `path` has been required, using `stamper` to create `stamp`.
  fn required_file(&amp;mut self, path: &amp;Path, stamper: &amp;FileStamper, stamp: &amp;FileStamp) {}
  /// Require `task` using `stamper`.
  fn require_task(&amp;mut self, task: &amp;T, stamper: &amp;OutputStamper) {}
  /// A `task` has been required, resulting in consistent `output`, using `stamper` to create `stamp`, and task 
  /// `was_executed`.
  fn required_task(&amp;mut self, task: &amp;T, output: &amp;T::Output, stamper: &amp;OutputStamper, stamp: &amp;OutputStamp&lt;T::Output&gt;, was_executed: bool) {}

  /// Execute `task`.
  fn execute(&amp;mut self, task: &amp;T) {}
  /// A `task` has been executed, producing `output`.
  fn executed(&amp;mut self, task: &amp;T, output: &amp;T::Output) {}
}</code></pre>
<p>The <code>Tracker</code> trait is generic over <code>Task</code>.</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="3_min_sound/2_tracker/index.html#admonition-note"></a></p>
</div>
<div>
<p>Here, we chose to put the <code>Task</code> constraint on the trait itself.
This will not lead to cascading constraints, as the <code>Tracker</code> trait will only be used as a constraint in <code>impl</code>s, not in structs or other traits.</p>
</div>
</div>
<p><code>Tracker</code> has methods corresponding to events that happen during a build, such as a build starting or ending, requiring a file, requiring a task, and executing a task.
These methods accept <code>&amp;mut self</code> so that tracker implementations can perform mutation, such as storing a build event.
We provide default methods that do nothing so that implementors of <code>Tracker</code> only have to override the methods for events they are interested in.
We use <code>#[allow(unused_variables)]</code> on the trait to not give warnings for unused variables, as all variables are unused due to the empty default implementations.</p>
<details id="admonition-default-methods" class="admonition info">
<summary class="admonition-title">
<p>Default methods</p>
<p><a class="admonition-anchor-link" href="3_min_sound/2_tracker/index.html#admonition-default-methods"></a></p>
</summary>
<div>
<p>Adding a method to <code>Tracker</code> with a default implementation ensures that implementations of <code>Tracker</code> do not have to be changed to work with the new method.
This is both good and bad.
Good because we can add methods without breaking compatibility.
Bad because we can forget to handle a new method, which can lead to problems with for example a composite tracker that forwards events to 2 trackers.
In this tutorial we chose the convenient option, but be sure to think about these kind of tradeoffs yourself!</p>
</div>
</details>
<p>Check that the code compiles with <code>cargo test</code>.</p>
<h2 id="no-op-tracker"><a class="header" href="#no-op-tracker">No-op tracker</a></h2>
<p>Add a no-op tracker, which is a tracker that does nothing, by adding the following code to <code>pie/src/tracker/mod.rs</code>:</p>
<pre><code class="language-rust ">/// [`Tracker`] that does nothing.
#[derive(Copy, Clone, Debug)]
pub struct NoopTracker;
impl&lt;T: Task&gt; Tracker&lt;T&gt; for NoopTracker {}</code></pre>
<p>Due to the default methods that do nothing on <code>Tracker</code>, this implementation is extremely simple. </p>
<details id="admonition-removing-tracker-overhead" class="admonition info">
<summary class="admonition-title">
<p>Removing tracker overhead</p>
<p><a class="admonition-anchor-link" href="3_min_sound/2_tracker/index.html#admonition-removing-tracker-overhead"></a></p>
</summary>
<div>
<p>We will use generics to select which tracker implementation to use.
Therefore, all calls to trackers are statically dispatched, and could be inlined.
Because <code>NoopTracker</code> only has empty methods, and those empty methods can be inlined, using <code>NoopTracker</code> will effectively remove all tracking code from your binary, thus removing the overhead of tracking if you don't want it.</p>
<p>In this tutorial, we do not annotate methods with <a href="https://nnethercote.github.io/perf-book/inlining.html"><code>#[inline]</code></a>, meaning that the Rust compiler (and the LLVM backend) will make its own decisions on what to make inlineable and what not.
If you care about performance here, be sure to annotate those default empty methods with <code>#[inline]</code>.</p>
</div>
</details>
<h2 id="using-the-tracker-trait"><a class="header" href="#using-the-tracker-trait">Using the <code>Tracker</code> trait</a></h2>
<p>Now we will make the build system generic over <code>Tracker</code>, and insert <code>Tracker</code> calls in context implementations.</p>
<p>Make <code>Pie</code> and <code>Session</code> generic over <code>Tracker</code> by modifying <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::fmt::Debug;
 use std::fs::File;
 use std::hash::Hash;
 use std::io;
 use std::path::Path;

 use stamp::{FileStamper, OutputStamper};

 use crate::context::top_down::TopDownContext;
 use crate::store::{Store, TaskNode};
+use crate::tracker::{NoopTracker, Tracker};

 pub mod stamp;
 pub mod tracker;
 mod context;
 mod fs;
 mod dependency;
 mod store;

 /// A unit of computation in a programmatic incremental build system.
 pub trait Task: Clone + Eq + Hash + Debug {
@@ -53,53 +54,68 @@
     self.require_task_with_stamper(task, self.default_output_stamper())
   }
   /// Requires given `task`, recording a dependency (using given `stamper`) and selectively executing it. Returns its
   /// up-to-date output.
   fn require_task_with_stamper(&amp;mut self, task: &amp;T, stamper: OutputStamper) -&gt; T::Output;
   /// Returns the default output stamper.
   fn default_output_stamper(&amp;self) -&gt; OutputStamper { OutputStamper::Equals }
 }

 /// Main entry point into PIE, a sound and incremental programmatic build system.
-pub struct Pie&lt;T, O&gt; {
+pub struct Pie&lt;T, O, A = NoopTracker&gt; {
   store: Store&lt;T, O&gt;,
+  tracker: A,
 }

 impl&lt;T: Task&gt; Default for Pie&lt;T, T::Output&gt; {
-  fn default() -&gt; Self { Self { store: Store::default() } }
+  fn default() -&gt; Self { Self::with_tracker(NoopTracker) }
 }

-impl&lt;T: Task&gt; Pie&lt;T, T::Output&gt; {
+impl&lt;T: Task, A: Tracker&lt;T&gt;&gt; Pie&lt;T, T::Output, A&gt; {
+  /// Creates a new [`Pie`] instance with given `tracker`.
+  pub fn with_tracker(tracker: A) -&gt; Self { Self { store: Store::default(), tracker } }
+  
   /// Creates a new build session. Only one session may be active at once, enforced via mutable (exclusive) borrow.
-  pub fn new_session(&amp;mut self) -&gt; Session&lt;T, T::Output&gt; { Session::new(self) }
+  pub fn new_session(&amp;mut self) -&gt; Session&lt;T, T::Output, A&gt; { Session::new(self) }
   /// Runs `f` inside a new build session.
-  pub fn run_in_session&lt;R&gt;(&amp;mut self, f: impl FnOnce(Session&lt;T, T::Output&gt;) -&gt; R) -&gt; R {
+  pub fn run_in_session&lt;R&gt;(&amp;mut self, f: impl FnOnce(Session&lt;T, T::Output, A&gt;) -&gt; R) -&gt; R {
     let session = self.new_session();
     f(session)
   }
+
+  /// Gets the [`Tracker`] instance.
+  pub fn tracker(&amp;self) -&gt; &amp;A { &amp;self.tracker }
+  /// Gets the mutable [`Tracker`] instance.
+  pub fn tracker_mut(&amp;mut self) -&gt; &amp;mut A { &amp;mut self.tracker }
 }

 /// A session in which builds are executed.
-pub struct Session&lt;'p, T, O&gt; {
+pub struct Session&lt;'p, T, O, A&gt; {
   store: &amp;'p mut Store&lt;T, O&gt;,
+  tracker: &amp;'p mut A,
   current_executing_task: Option&lt;TaskNode&gt;,
   dependency_check_errors: Vec&lt;io::Error&gt;,
 }

-impl&lt;'p, T: Task&gt; Session&lt;'p, T, T::Output&gt; {
-  fn new(pie: &amp;'p mut Pie&lt;T, T::Output&gt;) -&gt; Self {
+impl&lt;'p, T: Task, A: Tracker&lt;T&gt;&gt; Session&lt;'p, T, T::Output, A&gt; {
+  fn new(pie: &amp;'p mut Pie&lt;T, T::Output, A&gt;) -&gt; Self {
     Self {
       store: &amp;mut pie.store,
+      tracker: &amp;mut pie.tracker,
       current_executing_task: None,
       dependency_check_errors: Vec::default(),
     }
   }

   /// Requires `task`, returning its up-to-date output.
   pub fn require(&amp;mut self, task: &amp;T) -&gt; T::Output {
     self.current_executing_task = None;
     TopDownContext::new(self).require_initial(task)
   }

+  /// Gets the [`Tracker`] instance.
+  pub fn tracker(&amp;self) -&gt; &amp;A { &amp;self.tracker }
+  /// Gets the mutable [`Tracker`] instance.
+  pub fn tracker_mut(&amp;mut self) -&gt; &amp;mut A { &amp;mut self.tracker }
   /// Gets all errors produced during dependency checks.
   pub fn dependency_check_errors(&amp;self) -&gt; impl Iterator&lt;Item=&amp;io::Error&gt; { self.dependency_check_errors.iter() }
 }</code></pre>
<p>We use <code>A</code> as the generic argument for tracker types in the source code.
The <code>Pie</code> struct owns the tracker, similarly to how it owns the store.
<code>Pie</code> can be created with a specific tracker with <code>with_tracker</code>, and provides access to the tracker with <code>tracker</code> and <code>tracker_mut</code>.</p>
<details id="admonition-default-type" class="admonition info">
<summary class="admonition-title">
<p>Default type</p>
<p><a class="admonition-anchor-link" href="3_min_sound/2_tracker/index.html#admonition-default-type"></a></p>
</summary>
<div>
<p>We assign <code>NoopTracker</code> as the default type for trackers in <code>Pie</code>, so that no tracking is performed when we use the <code>Pie</code> type without an explicit tracker type.
The <code>Default</code> implementation only works with <code>NoopTracker</code>, because we <code>impl Default for Pie&lt;T, T::Output&gt;</code>, which is equivalent to <code>impl Default for Pie&lt;T, T::Output, NoopTracker&gt;</code> due to the default type.</p>
</div>
</details>
<p>We make <code>Session</code> generic over trackers, and mutibly borrow the tracker from <code>Pie</code>, again like we do with the store.
For convenience, <code>Session</code> also provides access to the tracker with <code>tracker</code> and <code>tracker_mut</code>.</p>
<p>Now we make <code>TopDownContext</code> generic over <code>Tracker</code>, and insert calls to tracker methods.
Modify <code>pie/src/context/top_down.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::fs::File;
 use std::io;
 use std::path::Path;

 use crate::{Context, fs, Session, Task};
 use crate::dependency::{FileDependency, TaskDependency};
 use crate::stamp::{FileStamper, OutputStamper};
 use crate::store::TaskNode;
+use crate::tracker::Tracker;

-pub struct TopDownContext&lt;'p, 's, T, O&gt; {
-  session: &amp;'s mut Session&lt;'p, T, O&gt;,
+pub struct TopDownContext&lt;'p, 's, T, O, A&gt; {
+  session: &amp;'s mut Session&lt;'p, T, O, A&gt;,
 }

-impl&lt;'p, 's, T: Task&gt; TopDownContext&lt;'p, 's, T, T::Output&gt; {
-  pub fn new(session: &amp;'s mut Session&lt;'p, T, T::Output&gt;) -&gt; Self { Self { session } }
+impl&lt;'p, 's, T: Task, A: Tracker&lt;T&gt;&gt; TopDownContext&lt;'p, 's, T, T::Output, A&gt; {
+  pub fn new(session: &amp;'s mut Session&lt;'p, T, T::Output, A&gt;) -&gt; Self { Self { session } }

   pub fn require_initial(&amp;mut self, task: &amp;T) -&gt; T::Output {
-    self.require_task(task)
+    self.session.tracker.build_start();
+    let output = self.require_task(task);
+    self.session.tracker.build_end();
+    output
   }
 }


-impl&lt;'p, 's, T: Task&gt; Context&lt;T&gt; for TopDownContext&lt;'p, 's, T, T::Output&gt; {
+impl&lt;'p, 's, T: Task, A: Tracker&lt;T&gt;&gt; Context&lt;T&gt; for TopDownContext&lt;'p, 's, T, T::Output, A&gt; {
   fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
     let Some(current_executing_task_node) = &amp;self.session.current_executing_task else {
       return fs::open_if_file(path); // No current executing task, so no dependency needs to be made.
     };
     let path = path.as_ref();
     let node = self.session.store.get_or_create_file_node(path);
     let (dependency, file) = FileDependency::new_with_file(path, stamper)?;
+    self.session.tracker.required_file(path, dependency.stamper(), dependency.stamp());
     self.session.store.add_file_require_dependency(current_executing_task_node, &amp;node, dependency);
     Ok(file)
   }

   fn require_task_with_stamper(&amp;mut self, task: &amp;T, stamper: OutputStamper) -&gt; T::Output {
+    self.session.tracker.require_task(task, &amp;stamper);
     let node = self.session.store.get_or_create_task_node(task);

     // Get required task output by executing it if needed, or by getting the output from the store if not needed.
-    let output = if self.should_execute_task(&amp;node) {
+    let should_execute = self.should_execute_task(&amp;node);
+    let output = if should_execute {
+      self.session.tracker.execute(task);
       self.session.store.reset_task(&amp;node);
       let previous_executing_task = self.session.current_executing_task.replace(node);
       let output = task.execute(self);
       self.session.current_executing_task = previous_executing_task;
       self.session.store.set_task_output(&amp;node, output.clone());
+      self.session.tracker.executed(task, &amp;output);
       output
     } else {
       // Correctness: when `should_execute_task` returns `true`, the above block is executed. Otherwise this block is 
       // executed and `should_execute_task` ensures that the task has an output.
       self.session.store.get_task_output(&amp;node).clone()
     };

+    let dependency = TaskDependency::new(task.clone(), stamper, output.clone());
+    self.session.tracker.required_task(task, &amp;output,dependency.stamper(), dependency.stamp(), should_execute);
+
     // Create task require dependency if a task is currently executing (i.e., we are not requiring the initial task).
     if let Some(current_executing_task_node) = &amp;self.session.current_executing_task {
-      let dependency = TaskDependency::new(task.clone(), stamper, output.clone());
       if self.session.store.add_task_require_dependency(current_executing_task_node, &amp;node, dependency).is_err() {
         let current_executing_task = self.session.store.get_task(current_executing_task_node);
         panic!(&quot;Cyclic task dependency; current executing task '{:?}' is requiring task '{:?}' which was already required&quot;, current_executing_task, task);
       }
     }

     output
   }
 }

-impl&lt;'p, 's, T: Task&gt; TopDownContext&lt;'p, 's, T, T::Output&gt; {
+impl&lt;'p, 's, T: Task, A: Tracker&lt;T&gt;&gt; TopDownContext&lt;'p, 's, T, T::Output, A&gt; {
   /// Checks whether given task should be executed, returning `true` if it should be executed. A task should be executed
   /// if any of its dependencies are inconsistent, or when it has no output.
   fn should_execute_task(&amp;mut self, node: &amp;TaskNode) -&gt; bool {
     // Borrow: because we pass `self` (which is `&amp;mut self`) to `is_inconsistent` for recursive consistency checking, 
     //         we need to clone and collect dependencies into a `Vec`. Otherwise we have an immutable borrow of `self`
     //         through `self.store` while we create a mutable borrow of `self`, which is not allowed.
     let dependencies: Vec&lt;_&gt; = self.session.store.get_dependencies_of_task(node).cloned().collect();
     for dependency in dependencies {
       match dependency.is_inconsistent(self) {
         Ok(Some(_)) =&gt; return true,</code></pre>
<p>We make <code>TopDownContext</code> generic over trackers, and call methods on the tracker:</p>
<ul>
<li><code>build_start</code>/<code>build_end</code> in <code>require_initial</code> to track build start and ends,</li>
<li><code>required_file</code> in <code>require_file_with_stamper</code> to track file dependencies,</li>
<li><code>require_task</code>/<code>required_task</code> in <code>require_file_with_stamper</code> to track task dependencies,</li>
<li><code>execute</code>/<code>executed</code> in <code>require_task_with_stamper</code> to track task execution start and ends.</li>
</ul>
<p>In <code>require_file_with_stamper</code>, we also extract <code>should_execute</code> into a variable, and pull <code>dependency</code> out of the <code>if</code>, so that we can pass the required data to <code>tracker.required_task</code>.</p>
<p>Check that the code compiles with <code>cargo test</code>.
Existing code should keep working due to the <code>NoopTracker</code> default type in <code>Pie</code>.</p>
<p>We won't modify <code>NonIncrementalContext</code> to use a tracker, as <code>NonIncrementalContext</code> has no state, so we cannot pass a tracker to it.</p>
<h2 id="implement-writing-tracker"><a class="header" href="#implement-writing-tracker">Implement writing tracker</a></h2>
<p>Now we can implement some interesting trackers.
We start with a simple <code>WritingTracker</code> that writes build events to some writer.</p>
<p>Add the <code>writing</code> module to <code>pie/src/tracker/mod.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::path::Path;

 use crate::stamp::{FileStamp, FileStamper, OutputStamp, OutputStamper};
 use crate::Task;

+pub mod writing;
+
 /// Trait for tracking build events. Can be used to implement logging, event tracing, progress tracking, metrics, etc.
 #[allow(unused_variables)]
 pub trait Tracker&lt;T: Task&gt; {
   /// Start a new build.
   fn build_start(&amp;mut self) {}</code></pre>
<p>Then create the <code>pie/src/tracker/writing.rs</code> file and add:</p>
<pre><code class="language-rust ">use std::io::{self, BufWriter, Stderr, Stdout, Write};

use crate::stamp::{OutputStamp, OutputStamper};
use crate::Task;
use crate::tracker::Tracker;

/// [`Tracker`] that writes events to a [`Write`] instance, for example [`Stdout`].
#[derive(Clone, Debug)]
pub struct WritingTracker&lt;W&gt; {
  writer: W,
  indentation: u32,
}

impl WritingTracker&lt;BufWriter&lt;Stdout&gt;&gt; {
  /// Creates a [`WritingTracker`] that writes to buffered standard output.
  pub fn with_stdout() -&gt; Self { Self::new(BufWriter::new(io::stdout())) }
}
impl WritingTracker&lt;BufWriter&lt;Stderr&gt;&gt; {
  /// Creates a [`WritingTracker`] that writes to buffered standard error.
  pub fn with_stderr() -&gt; Self { Self::new(BufWriter::new(io::stderr())) }
}
impl&lt;W: Write&gt; WritingTracker&lt;W&gt; {
  /// Creates a [`WritingTracker`] that writes to `writer`.
  pub fn new(writer: W) -&gt; Self {
    Self {
      writer,
      indentation: 0,
    }
  }
}</code></pre>
<p>The <code>WritingTracker</code> is generic over a writer <code>W</code> that must implement <code>Write</code>, which is a standard trait for writing bytes to something.
<code>with_stdout</code> and <code>with_stderr</code> can be used to create buffered writers to standard output and standard error.
<code>new</code> can be used to create a writer to anything that implements <code>Write</code>, such as a <code>File</code>.</p>
<p>Add the <code>Tracker</code> implementation to <code>pie/src/tracker/writing.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;W: Write, T: Task&gt; Tracker&lt;T&gt; for WritingTracker&lt;W&gt; {
  fn required_task(&amp;mut self, task: &amp;T, _output: &amp;T::Output, _stamper: &amp;OutputStamper, _stamp: &amp;OutputStamp&lt;T::Output&gt;, was_executed: bool) {
    if !was_executed {
      self.writeln(format_args!(&quot;✓ {:?}&quot;, task));
      self.flush();
    }
  }

  fn execute(&amp;mut self, task: &amp;T) {
    self.writeln(format_args!(&quot;→ {:?}&quot;, task));
    self.indent();
    self.flush();
  }
  fn executed(&amp;mut self, _task: &amp;T, output: &amp;T::Output) {
    self.unindent();
    self.writeln(format_args!(&quot;← {:?}&quot;, output));
    self.flush();
  }
}

#[allow(dead_code)]
impl&lt;W: Write&gt; WritingTracker&lt;W&gt; {
  fn writeln(&amp;mut self, args: std::fmt::Arguments) {
    self.write_indentation();
    writeln!(&amp;mut self.writer, &quot;{}&quot;, args).ok();
  }
  fn write(&amp;mut self, args: std::fmt::Arguments) {
    write!(&amp;mut self.writer, &quot;{}&quot;, args).ok();
  }
  fn write_nl(&amp;mut self) {
    write!(&amp;mut self.writer, &quot;\n&quot;).ok();
  }

  fn indent(&amp;mut self) {
    self.indentation = self.indentation.saturating_add(1);
  }
  fn unindent(&amp;mut self) {
    self.indentation = self.indentation.saturating_sub(1);
  }
  fn write_indentation(&amp;mut self) {
    for _ in 0..self.indentation {
      write!(&amp;mut self.writer, &quot; &quot;).ok();
    }
  }

  fn flush(&amp;mut self) {
    self.writer.flush().ok();
  }
}</code></pre>
<p>We implement 3 tracker methods that write when:</p>
<ul>
<li>✓: a task is required but was not executed (i.e., consistent),</li>
<li>→: a task starts to execute,</li>
<li>←: when the task is done executing.</li>
</ul>
<p>The text to write is formatted with <code>format_args!</code>, which is passed into <code>writeln</code> using <code>std::fmt::Arguments</code> for flexibility.
We <code>flush</code> the writer after every event to ensure that bytes are written out.
When a task starts to execute, we increase indentation to signify the recursive checking/execution.
When a task is done executing, we decrease the indentation again.</p>
<details id="admonition-saturating-arithmetic" class="admonition info">
<summary class="admonition-title">
<p>Saturating arithmetic</p>
<p><a class="admonition-anchor-link" href="3_min_sound/2_tracker/index.html#admonition-saturating-arithmetic"></a></p>
</summary>
<div>
<p>We use <code>saturating_add</code> and <code>saturating_sub</code> for safety, which are saturating arithmetic operations that saturate at the numeric bounds instead of overflowing.
For example, <code>0u32.saturating_sub(1)</code> will result in <code>0</code> instead of overflowing into <code>4294967295</code>.</p>
<p>These saturating operations are not really needed when calls to <code>indent</code> and <code>unindent</code> are balanced.
However, if we make a mistake, it is better to write no indentation than to write 4294967295 spaces of indentation.</p>
<p>Alternatively, we could use standard arithmetic operations, which panic on overflow in debug/development mode, but silently overflow in release mode.</p>
</div>
</details>
<details id="admonition-failing-writes" class="admonition info">
<summary class="admonition-title">
<p>Failing writes</p>
<p><a class="admonition-anchor-link" href="3_min_sound/2_tracker/index.html#admonition-failing-writes"></a></p>
</summary>
<div>
<p>Writes can fail, but we silently ignore them in this tutorial (with <code>let _ = ...</code>) for simplicity.
You could panic when writing fails, but panicking when writing to standard output fails is probably going a bit too far.
You could store the latest write error and give access to it, which at least allows users of <code>WritingTracker</code> check for some errors.</p>
<p>In general, tracking events can fail, but the current <code>Tracker</code> API does not allow for propagating these errors with <code>Result</code>.
This in turn because <code>TopDownContext</code> does not return <code>Result</code> for <code>require_task</code> due to the trade-offs discussed in the section on <code>TopDownContext</code>.</p>
</div>
</details>
<p>If you want, you can capture more build events and write them, and/or provide more configuration as to what build events should be written.
But in this tutorial, we will keep it simple like this.</p>
<p>Check that the code compiles with <code>cargo test</code>.</p>
<p>Let's try out our writing tracker in the incrementality example by modifying <code>pie/examples/incremental.rs</code>:</p>
<pre><code class="language-rust customdiff">
 /// Pseudo-task that reads a string from a file.
 #[derive(Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]
 struct ReadStringFromFile(PathBuf, FileStamper);

 impl ReadStringFromFile {
   fn new(path: impl AsRef&lt;Path&gt;, stamper: FileStamper) -&gt; FileTask {
     FileTask::ReadStringFromFile(Self(path.as_ref().to_path_buf(), stamper))
   }
   fn execute&lt;C: Context&lt;FileTask&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Result&lt;String, io::ErrorKind&gt; {
-    println!(&quot;Reading from {} with {:?} stamper&quot;, self.0.file_name().unwrap().to_string_lossy(), self.1);
     let file = context.require_file_with_stamper(&amp;self.0, self.1).map_err(|e| e.kind())?;
     if let Some(mut file) = file {
       let mut string = String::new();
       file.read_to_string(&amp;mut string).map_err(|e| e.kind())?;
       Ok(string)
     } else {
       Err(io::ErrorKind::NotFound)
     }
   }
 }
@@ -50,36 +49,35 @@
 /// Pseudo-task that writes a string to a file, where the string is provided by another task. The string provider is 
 /// boxed to prevent a cyclic definition of infinite size, due to this type being used in [`FileTask`].
 #[derive(Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]
 struct WriteStringToFile(Box&lt;FileTask&gt;, PathBuf, FileStamper);

 impl WriteStringToFile {
   fn new(string_provider: impl Into&lt;Box&lt;FileTask&gt;&gt;, path: impl Into&lt;PathBuf&gt;, stamper: FileStamper) -&gt; FileTask {
     FileTask::WriteStringToFile(Self(string_provider.into(), path.into(), stamper))
   }
   fn execute&lt;C: Context&lt;FileTask&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Result&lt;(), io::ErrorKind&gt; {
-    println!(&quot;Writing to {} with {:?} stamper&quot;, self.1.file_name().unwrap().to_string_lossy(), self.2);
     let string = context.require_task(&amp;self.0)?;
     let mut file = File::create(&amp;self.1).map_err(|e| e.kind())?;
     file.write_all(string.as_bytes()).map_err(|e| e.kind())?;
     context.require_file_with_stamper(&amp;self.1, self.2).map_err(|e| e.kind())?;
     Ok(())
   }
 }

 fn main() -&gt; Result&lt;(), io::Error&gt; {
   let temp_dir = create_temp_dir()?;
   let input_file = temp_dir.path().join(&quot;input.txt&quot;);
   write(&amp;input_file, &quot;Hi&quot;)?;
   let output_file = temp_dir.path().join(&quot;output.txt&quot;);

-  let mut pie = Pie::default();
+  let mut pie = Pie::with_tracker(pie::tracker::writing::WritingTracker::with_stdout());
   let read_task = ReadStringFromFile::new(&amp;input_file, FileStamper::Modified);
   let write_task = WriteStringToFile::new(read_task.clone(), &amp;output_file, FileStamper::Modified);

   println!(&quot;A) New task: expect `read_task` to execute&quot;);
   // `read_task` is new, meaning that we have no cached output for it, thus it must be executed.
   let output = pie.new_session().require(&amp;read_task)?;
   assert_eq!(&amp;output, &quot;Hi&quot;);

   println!(&quot;\nB) Reuse: expect no execution&quot;);
   // `read_task` is not new and its file dependency is still consistent. It is consistent because the modified time of </code></pre>
<p>We remove the <code>println!</code> statements from tasks and create <code>Pie</code> with <code>WritingTracker</code>.
Now run the example with <code>cargo run --example incremental</code>, and you should see the writing tracker print consistent tasks and task executions to standard output.</p>
<h2 id="implement-event-tracker"><a class="header" href="#implement-event-tracker">Implement event tracker</a></h2>
<p>The writing tracker is great for debugging purposes, but we cannot use it to check whether our build system is incremental and sound.
To check incrementality and soundness, we need to be able to check whether a task has executed or not, and check the order of build events.
Therefore, we will implement the <code>EventTracker</code> that stores build events for later inspection.</p>
<p>Add the <code>event</code> module to <code>pie/src/tracker/mod.rs</code>:</p>
<pre><code class="language-rust customdiff">
 use crate::stamp::{FileStamp, FileStamper, OutputStamp, OutputStamper};
 use crate::Task;

 pub mod writing;
+pub mod event;

 /// Trait for tracking build events. Can be used to implement logging, event tracing, progress tracking, metrics, etc.
 #[allow(unused_variables)]
 pub trait Tracker&lt;T: Task&gt; {
   /// Start a new build.</code></pre>
<p>Then create the <code>pie/src/tracker/event.rs</code> file and add:</p>
<pre><code class="language-rust ">use std::path::{Path, PathBuf};

use crate::stamp::{FileStamp, FileStamper, OutputStamp, OutputStamper};
use crate::Task;
use crate::tracker::Tracker;

/// [`Tracker`] that stores [events](Event) in a [`Vec`], useful in testing to assert that a context implementation is 
/// incremental and sound.
#[derive(Clone, Debug)]
pub struct EventTracker&lt;T: Task&gt; {
  events: Vec&lt;Event&lt;T&gt;&gt;,
}

impl&lt;T: Task&gt; Default for EventTracker&lt;T&gt; {
  fn default() -&gt; Self { Self { events: Vec::new() } }
}

/// Enumeration of important build events.
#[derive(Debug, Clone)]
pub enum Event&lt;T: Task&gt; {
  /// A file at `path` has been required, using `stamper` to create `stamp`.
  RequiredFile { path: PathBuf, stamper: FileStamper, stamp: FileStamp },
  /// Require `task` using `stamper`.
  RequireTask { task: T, stamper: OutputStamper },
  /// A `task` has been required, resulting in consistent `output`, using `stamper` to create `stamp`, and task 
  /// `was_executed`.
  RequiredTask { task: T, output: T::Output, stamper: OutputStamper, stamp: OutputStamp&lt;T::Output&gt;, was_executed: bool },

  /// Execute `task`.
  Execute { task: T },
  /// A `task` has been executed, producing `output`.
  Executed { task: T, output: T::Output },
}</code></pre>
<p>The <code>EventTracker</code> stores build events in a <code>Vec</code>.
The <code>Event</code> enumeration mimics the <code>Tracker</code> methods, but has all arguments in owned form (for example <code>task: T</code> instead of <code>task: &amp;T</code>) as we want to store these events.</p>
<p>Add the tracker implementation to <code>pie/src/tracker/event.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;T: Task&gt; Tracker&lt;T&gt; for EventTracker&lt;T&gt; {
  fn build_start(&amp;mut self) {
    self.events.clear();
  }

  fn required_file(&amp;mut self, path: &amp;Path, stamper: &amp;FileStamper, stamp: &amp;FileStamp) {
    self.events.push(Event::RequiredFile { path: path.to_path_buf(), stamper: *stamper, stamp: *stamp });
  }
  fn require_task(&amp;mut self, task: &amp;T, stamper: &amp;OutputStamper) {
    self.events.push(Event::RequireTask { task: task.clone(), stamper: stamper.clone() });
  }
  fn required_task(&amp;mut self, task: &amp;T, output: &amp;T::Output, stamper: &amp;OutputStamper, stamp: &amp;OutputStamp&lt;T::Output&gt;, was_executed: bool) {
    self.events.push(Event::RequiredTask { task: task.clone(), output: output.clone(), stamper: *stamper, stamp: stamp.clone(), was_executed });
  }

  fn execute(&amp;mut self, task: &amp;T) {
    self.events.push(Event::Execute { task: task.clone() });
  }
  fn executed(&amp;mut self, task: &amp;T, output: &amp;T::Output) {
    self.events.push(Event::Executed { task: task.clone(), output: output.clone() });
  }
}</code></pre>
<p>We implement the relevant methods from <code>Tracker</code> and store the build events as <code>Event</code> instances in <code>self.events</code>.
When a new build starts, we clear the events.</p>
<p>Now we will add code to inspect the build events.
This is quite a bit of code that we will be using in integration testing to test incrementality and soundness.
We'll add in one go to keep the tutorial going, and we will use this code in the next section, but feel free to take some time to inspect the code.</p>
<p>Add the following code to <code>pie/src/tracker/event.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;T: Task&gt; EventTracker&lt;T&gt; {
  /// Returns a slice over all events.
  pub fn slice(&amp;self) -&gt; &amp;[Event&lt;T&gt;] {
    &amp;self.events
  }
  /// Returns an iterator over all events.
  pub fn iter(&amp;self) -&gt; impl Iterator&lt;Item=&amp;Event&lt;T&gt;&gt; {
    self.events.iter()
  }

  /// Returns `true` if `predicate` returns `true` for any event.
  pub fn any(&amp;self, predicate: impl FnMut(&amp;Event&lt;T&gt;) -&gt; bool) -&gt; bool {
    self.iter().any(predicate)
  }
  /// Returns the number of times `predicate` returns `true`.
  pub fn count(&amp;self, predicate: impl FnMut(&amp;&amp;Event&lt;T&gt;) -&gt; bool) -&gt; usize {
    self.iter().filter(predicate).count()
  }
  /// Returns `true` if `predicate` returns `true` for exactly one event.
  pub fn one(&amp;self, predicate: impl FnMut(&amp;&amp;Event&lt;T&gt;) -&gt; bool) -&gt; bool {
    self.count(predicate) == 1
  }

  /// Returns `Some(index)` for the first event `e` where `predicate(e)` returns `true`, or `None` otherwise.
  pub fn index_of(&amp;self, predicate: impl FnMut(&amp;Event&lt;T&gt;) -&gt; bool) -&gt; Option&lt;usize&gt; {
    self.iter().position(predicate)
  }
  /// Returns `Some(v)` for the first event `e` where `f(e)` returns `Some(v)`, or `None` otherwise.
  pub fn find_map&lt;R&gt;(&amp;self, f: impl FnMut(&amp;Event&lt;T&gt;) -&gt; Option&lt;&amp;R&gt;) -&gt; Option&lt;&amp;R&gt; {
    self.iter().find_map(f)
  }
  /// Returns `Some((index, v))` for the first event `e` where `f(e)` returns `Some(v)`, or `None` otherwise.
  pub fn index_find_map&lt;R&gt;(&amp;self, mut f: impl FnMut(&amp;Event&lt;T&gt;) -&gt; Option&lt;&amp;R&gt;) -&gt; Option&lt;(usize, &amp;R)&gt; {
    self.iter().enumerate().find_map(|(i, e)| f(e).map(|o| (i, o)))
  }


  /// Finds the first [required file event](Event::RequiredFile) for `path` and returns its stamp as `Some(stamp)`, or 
  /// `None` if no event was found.
  pub fn stamp_of_first_required_file(&amp;self, path: &amp;PathBuf) -&gt; Option&lt;&amp;FileStamp&gt; {
    self.find_map(|e| e.stamp_of_required_file(path))
  }

  /// Returns `true` if any task was executed.
  pub fn any_execution(&amp;self) -&gt; bool {
    self.any(|e| e.is_execution())
  }
  /// Returns `true` if `task` was executed.
  pub fn any_execution_of(&amp;self, task: &amp;T) -&gt; bool {
    self.any(|e| e.is_execution_of(task))
  }
  /// Returns `true` if `task` was executed exactly once.
  pub fn one_execute_of(&amp;self, task: &amp;T) -&gt; bool {
    self.one(|e| e.is_execute(task))
  }

  /// Finds the first [task execute event](Event::Execute) for `task` and returns its index as `Some(index)`, or `None` 
  /// if no event was found.
  pub fn index_of_first_execute(&amp;self, task: &amp;T) -&gt; Option&lt;usize&gt; {
    self.index_of(|e| e.is_execute(task))
  }
  /// Finds the first [task executed event](Event::Executed) for `task` and returns its index as `Some(index)`, or 
  /// `None` if no event was found.
  pub fn index_of_first_executed(&amp;self, task: &amp;T) -&gt; Option&lt;usize&gt; {
    self.index_of(|e| e.output_of_executed(task).is_some())
  }
  /// Finds the first [task executed event](Event::Executed) for `task` and returns its index and output as 
  /// `Some((index, output))`, or `None` if no event was found.
  pub fn index_output_of_first_executed(&amp;self, task: &amp;T) -&gt; Option&lt;(usize, &amp;T::Output)&gt; {
    self.index_find_map(|e| e.output_of_executed(task))
  }
}

impl&lt;T: Task&gt; Event&lt;T&gt; {
  /// Returns `Some(stamp)` if this is a [required file event](Event::RequiredFile) for file at `path`, or `None` 
  /// otherwise.
  pub fn stamp_of_required_file(&amp;self, path: &amp;PathBuf) -&gt; Option&lt;&amp;FileStamp&gt; {
    match self {
      Event::RequiredFile { path: p, stamp, .. } if p == path =&gt; Some(stamp),
      _ =&gt; None,
    }
  }

  /// Returns `true` if this is a task execution (execute or executed) event.
  pub fn is_execution(&amp;self) -&gt; bool {
    match self {
      Event::Execute { .. } =&gt; true,
      Event::Executed { .. } =&gt; true,
      _ =&gt; false,
    }
  }
  /// Returns `true` if this is an execution (execute or executed) event for `task`.
  pub fn is_execution_of(&amp;self, task: &amp;T) -&gt; bool {
    match self {
      Event::Execute { task: t } if t == task =&gt; true,
      Event::Executed { task: t, .. } if t == task =&gt; true,
      _ =&gt; false,
    }
  }
  /// Returns `true` if this is a [task execute event](Event::Execute) for `task`.
  pub fn is_execute(&amp;self, task: &amp;T) -&gt; bool {
    match self {
      Event::Execute { task: t } if t == task =&gt; true,
      _ =&gt; false,
    }
  }
  /// Returns `Some(output)` if this is a [task executed event](Event::Executed) for `task`, or `None` otherwise.
  pub fn output_of_executed(&amp;self, task: &amp;T) -&gt; Option&lt;&amp;T::Output&gt; {
    match self {
      Event::Executed { task: t, output: o } if t == task =&gt; Some(o),
      _ =&gt; None,
    }
  }
}</code></pre>
<p>We add several general inspection methods to <code>EventTracker</code>:</p>
<ul>
<li><code>slice</code> and <code>iter</code> provide raw access to all stored <code>Event</code>s,</li>
<li><code>any</code>, <code>count</code>, and <code>one</code> are for checking predicates over all events,</li>
<li><code>index_of</code> for finding the index of the first event given a predicate,</li>
<li><code>find_map</code> and <code>index_find_map</code> for finding the first event given some function, returning the output (and also index in <code>index_find_map</code>) of that function.</li>
</ul>
<p>We add methods for specific kinds of events, following the general methods.
Finally, we add convenience methods to <code>Event</code> for checking specific kinds of events.</p>
<p>Check that the code compiles with <code>cargo test</code>.</p>
<h2 id="implement-composite-tracker"><a class="header" href="#implement-composite-tracker">Implement composite tracker</a></h2>
<p>Currently, we cannot use both <code>EventTracker</code> and <code>WritingTracker</code> at the same time.
We want this so that we can check incrementality and soundness, but also look at standard output for debugging, at the same time.
Therefore, we will implement a <code>CompositeTracker</code> that forwards build events to 2 trackers.</p>
<p>Add the following code to <code>pie/src/tracker/mod.rs</code>:</p>
<pre><code class="language-rust ">/// [`Tracker`] that forwards build events to 2 trackers.
#[derive(Copy, Clone, Debug)]
pub struct CompositeTracker&lt;A1, A2&gt;(pub A1, pub A2);
impl&lt;T: Task, A1: Tracker&lt;T&gt;, A2: Tracker&lt;T&gt;&gt; Tracker&lt;T&gt; for CompositeTracker&lt;A1, A2&gt; {
  fn build_start(&amp;mut self) {
    self.0.build_start();
    self.1.build_start();
  }
  fn build_end(&amp;mut self) {
    self.0.build_end();
    self.1.build_end();
  }

  fn required_file(&amp;mut self, path: &amp;Path, stamper: &amp;FileStamper, stamp: &amp;FileStamp) {
    self.0.required_file(path, stamper, stamp);
    self.1.required_file(path, stamper, stamp);
  }
  fn require_task(&amp;mut self, task: &amp;T, stamper: &amp;OutputStamper) {
    self.0.require_task(task, stamper);
    self.1.require_task(task, stamper);
  }
  fn required_task(&amp;mut self, task: &amp;T, output: &amp;T::Output, stamper: &amp;OutputStamper, stamp: &amp;OutputStamp&lt;T::Output&gt;, was_executed: bool) {
    self.0.required_task(task, output, stamper, stamp, was_executed);
    self.1.required_task(task, output, stamper, stamp, was_executed);
  }

  fn execute(&amp;mut self, task: &amp;T) {
    self.0.execute(task);
    self.1.execute(task);
  }
  fn executed(&amp;mut self, task: &amp;T, output: &amp;T::Output) {
    self.0.executed(task, output);
    self.1.executed(task, output);
  }
}</code></pre>
<p><code>CompositeTracker</code> is a tuple struct containing 2 trackers that implements all tracker methods and forwards them to the 2 contained trackers.
Its tuple fields are <code>pub</code> so it can be constructed with <code>CompositeTracker(t1, t2)</code> and the contained trackers can be accessed with <code>c.0</code> and <code>c.1</code>.</p>
<p>Check that the code compiles with <code>cargo test</code>.</p>
<p>Now that the build event tracking infrastructure is in place, we can start integration testing!</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="3_min_sound/2_tracker/index.html#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="3_min_sound/2_tracker/../../gen/3_min_sound/2_tracker/source.zip">download the source files up to this point</a>.</p>
</div>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/diff2html-ui-base.min.js"></script>
        <script src="src/diff.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
