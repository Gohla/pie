<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Incremental Top-Down Context - Build your own Programmatic Incremental Build System</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../src/custom.css">
        <link rel="stylesheet" href="../../src/mdbook-admonish.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Introduction</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Programmability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../1_programmability/0_setup/index.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../../1_programmability/1_api/index.html"><strong aria-hidden="true">2.2.</strong> Programmable Build System API</a></li><li class="chapter-item expanded "><a href="../../1_programmability/2_non_incremental/index.html"><strong aria-hidden="true">2.3.</strong> Non-Incremental Context</a></li></ol></li><li class="chapter-item expanded "><a href="../../2_incrementality/index.html"><strong aria-hidden="true">3.</strong> Incrementality</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../2_incrementality/1_require_file/index.html"><strong aria-hidden="true">3.1.</strong> Requiring Files</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/2_stamp/index.html"><strong aria-hidden="true">3.2.</strong> Stamps</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/3_dependency/index.html"><strong aria-hidden="true">3.3.</strong> Dynamic Dependencies</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/4_store/index.html"><strong aria-hidden="true">3.4.</strong> Dependency Graph Store</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/5_context/index.html" class="active"><strong aria-hidden="true">3.5.</strong> Incremental Top-Down Context</a></li></ol></li><li class="chapter-item expanded "><a href="../../3_min_sound/index.html"><strong aria-hidden="true">4.</strong> Minimality and Soundness</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../3_min_sound/1_session/index.html"><strong aria-hidden="true">4.1.</strong> Minimality with Sessions</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/2_tracker/index.html"><strong aria-hidden="true">4.2.</strong> Tracking Build Events</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Prevent Overlapping File Writes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> Prevent Hidden Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> Prevent Cycles</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Improvements</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Serialization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> More Stampers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Configurable Hashing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Efficiency</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Incremental Bottom-Up Context</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Observability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Deferred Tasks</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Multiple Task Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> On Static Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> On Declarativity</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Related Work</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/edit/master/tutorial/src/2_incrementality/5_context/index.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="top-down-context"><a class="header" href="#top-down-context">Top-down Context</a></h1>
<p>We‚Äôve implemented all the prerequisites for incremental top-down building.
Now we will create the <code>TopDownContext</code> type which implements the <code>Context</code> trait in an incremental way. </p>
<h2 id="top-down-context-basics"><a class="header" href="#top-down-context-basics">Top-down context basics</a></h2>
<p>Add the <code>top_down</code> module to <code>pie/src/context/mod.rs</code>:</p>
<pre><code class="language-rust customdiff"> pub mod non_incremental;
+pub mod top_down;</code></pre>
<p>Create the <code>pie/src/context/top_down.rs</code> file and add the following to get started:</p>
<pre><code class="language-rust ">use std::fs::File;
use std::io;
use std::path::Path;

use crate::{Context, fs, Task};
use crate::dependency::{FileDependency, TaskDependency};
use crate::stamp::{FileStamper, OutputStamper};
use crate::store::{Store, TaskNode};

pub struct TopDownContext&lt;T, O&gt; {
  store: Store&lt;T, O&gt;,
}

impl&lt;T: Task&gt; TopDownContext&lt;T, T::Output&gt; {
  pub fn new() -&gt; Self {
    Self {
      store: Store::default(),
    }
  }
}

impl&lt;T: Task&gt; Context&lt;T&gt; for TopDownContext&lt;T, T::Output&gt; {
  fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
    todo!()
  }

  fn require_task_with_stamper(&amp;mut self, task: &amp;T, stamper: OutputStamper) -&gt; T::Output {
    todo!()
  }
}</code></pre>
<p>The <code>TopDownContext</code> type is generic over tasks <code>T</code> and their outputs <code>O</code>, owns a <code>Store</code>, and can be created using <code>new</code>.</p>
<p><code>TopDownContext</code> implements <code>Context</code>, and the main challenge will be implementing the <code>require_file_with_stamper</code> and <code>require_task_with_stamper</code> methods <em>incrementally</em> and <em>correctly</em>.</p>
<h2 id="requiring-files"><a class="header" href="#requiring-files">Requiring files</a></h2>
<p>Tasks such as <code>ReadStringFromFile</code> which we‚Äôve used in tests before call <code>context.require_file</code> to declare that they depend on a file in the filesystem.
For incrementality, we need to add this dependency to the dependency graph.
This dependency will go from the <em>current executing task</em> to the file.
Therefore, we will need to keep track of the current executing task.</p>
<p>Change <code>pie/src/context/mod.rs</code> to add a field for tracking the current executing task, and use it in <code>require_file_with_stamper</code>:</p>
<pre><code class="language-rust customdiff">
 use crate::{Context, fs, Task};
 use crate::dependency::{FileDependency, TaskDependency};
 use crate::stamp::{FileStamper, OutputStamper};
 use crate::store::{Store, TaskNode};

 pub struct TopDownContext&lt;T, O&gt; {
   store: Store&lt;T, O&gt;,
+  current_executing_task: Option&lt;TaskNode&gt;,
 }

 impl&lt;T: Task&gt; TopDownContext&lt;T, T::Output&gt; {
   pub fn new() -&gt; Self {
     Self {
       store: Store::default(),
+      current_executing_task: None,
     }
   }
 }

 impl&lt;T: Task&gt; Context&lt;T&gt; for TopDownContext&lt;T, T::Output&gt; {
   fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
+    let Some(current_executing_task_node) = &amp;self.current_executing_task else {
+      return fs::open_if_file(path); // No current executing task, so no dependency needs to be made.
+    };
     todo!()
   }

   fn require_task_with_stamper(&amp;mut self, task: &amp;T, stamper: OutputStamper) -&gt; T::Output {
     todo!()
   }
 }</code></pre>
<p>We‚Äôre not setting <code>current_executing_task</code> yet, as that is the responsibility of <code>require_task_with_stamper</code> which we will implement later.
In <code>require_file_with_stamper</code> we‚Äôre now getting the current executing task.
If there is no current executing task, which only happens if a user directly calls <code>require_file</code> on a context, we don‚Äôt make a dependency and just open the file.</p>
<p>Now we need to add the file dependency, change <code>pie/src/context/mod.rs</code> to do this: </p>
<pre><code class="language-rust customdiff"> impl&lt;T: Task&gt; Context&lt;T&gt; for TopDownContext&lt;T, T::Output&gt; {
   fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
     let Some(current_executing_task_node) = &amp;self.current_executing_task else {
       return fs::open_if_file(path); // No current executing task, so no dependency needs to be made.
     };
-    todo!()
+    let path = path.as_ref();
+    let node = self.store.get_or_create_file_node(path);
+    let (dependency, file) = FileDependency::new_with_file(path, stamper)?;
+    self.store.add_file_require_dependency(current_executing_task_node, &amp;node, dependency);
+    Ok(file)
   }

   fn require_task_with_stamper(&amp;mut self, task: &amp;T, stamper: OutputStamper) -&gt; T::Output {
     todo!()
   }</code></pre>
<p>We simply create or get an existing file node, create a file dependency, and add the file require dependency to the graph via <code>store</code>.
Errors are propagated to the caller, so they can react accordingly to filesystem operation failures.</p>
<h2 id="requiring-tasks"><a class="header" href="#requiring-tasks">Requiring tasks</a></h2>
<p>To implement <code>require_task_with_stamper</code>, we need to check whether we should execute a task.
A task should be executed either if it‚Äôs new (it does not have an output stored yet), or if at least one of its dependencies is inconsistent.
If we don‚Äôt execute it, then it must have an output value and all its dependencies are consistent, so we just return its output value.</p>
<p>Change <code>pie/src/context/mod.rs</code> to implement this logic:</p>
<pre><code class="language-rust customdiff">     self.store.add_file_require_dependency(current_executing_task_node, &amp;node, dependency);
     Ok(file)
   }

   fn require_task_with_stamper(&amp;mut self, task: &amp;T, stamper: OutputStamper) -&gt; T::Output {
-    todo!()
+    let node = self.store.get_or_create_task_node(task);
+
+    // Get required task output by executing it if needed, or by getting the output from the store if not needed.
+    let output = if self.should_execute_task(&amp;node) {
+      self.store.reset_task(&amp;node);
+      let previous_executing_task = self.current_executing_task.replace(node);
+      let output = task.execute(self);
+      self.current_executing_task = previous_executing_task;
+      self.store.set_task_output(&amp;node, output.clone());
+      output
+    } else {
+      // Correctness: when `should_execute_task` returns `true`, the above block is executed. Otherwise this block is 
+      // executed and `should_execute_task` ensures that the task has an output.
+      self.store.get_task_output(&amp;node).clone()
+    };
+
+    output
   }
 }</code></pre>
<p>We first create or get an existing file node.
Then, we check whether the task should be executed with <code>should_execute_task</code> which we still need to implement.</p>
<p>If that returns true, we reset the task, set the current executing task, actually execute the task, restore the previous executing task, and set the task output.
Otherwise, we get the output of the task from the store, which cannot panic because <code>should_execute_task</code> ensures that the task has an output if it returns false.
Finally, we return the output.</p>
<p>We still need to create a task dependency. Change <code>pie/src/context/mod.rs</code> to add the dependency:</p>
<pre><code class="language-rust customdiff">       // Correctness: when `should_execute_task` returns `true`, the above block is executed. Otherwise this block is 
       // executed and `should_execute_task` ensures that the task has an output.
       self.store.get_task_output(&amp;node).clone()
     };

+    // Create task require dependency if a task is currently executing (i.e., we are not requiring the initial task).
+    if let Some(current_executing_task_node) = &amp;self.current_executing_task {
+      let dependency = TaskDependency::new(task.clone(), stamper, output.clone());
+      if self.store.add_task_require_dependency(current_executing_task_node, &amp;node, dependency).is_err() {
+        let current_executing_task = self.store.get_task(current_executing_task_node);
+        panic!(&quot;Cyclic task dependency; current executing task '{:?}' is requiring task '{:?}' which was already required&quot;, current_executing_task, task);
+      }
+    }
+
     output
   }
 }</code></pre>
<p>If there is no current executing task, which occurs when a user requires the initial task, we skip creating a dependency.
Otherwise, we create a dependency and add it to the store.
However, creating a task dependency can create cycles, and we need to handle that error.</p>
<p>At this point, we need to make a hard decision about the API of our library.
<code>require_task_with_stamper</code> returns the task output, with no opportunity to return an error.
If we want to propagate this error, we‚Äôd need to change the <code>Context::require_task</code> API to return <code>Result&lt;T::Output, CycleError&gt;</code>.
However, because tasks call these methods on <code>Context</code>, we‚Äôd also need to change <code>Task::execute</code> to return <code>Result&lt;T::Output, CycleError&gt;</code>.
That would require all tasks to propagate these cycle errors every time they require another task.</p>
<p>Furthermore, some tasks want to return their own kinds of errors, where <code>T::Output</code> will be <code>Result&lt;AnOutput, AnError&gt;</code>.
In that case, the concrete return type would be <code>Result&lt;Result&lt;AnOutput, AnError&gt;, CycleError&gt;</code>, which is annoying to deal with.</p>
<p>On the other hand, we can panic when a cycle is found, which requires no changes to the API.
We do end up in a mostly unrecoverable state, so a panic is a valid option.
However, this is not ideal, because it means the build system can panic due to invalid task dependencies created by the user of the system.
Panics will (most of the time) stop the program, which can be annoying to deal with.</p>
<p>This is a hard trade-off to make.
Either we propagate errors which will not end the program but will introduce a lot of boilerplate and annoyance in task implementations.
Or we panic which will end the program but introduces no boilerplate.</p>
<p>In this tutorial, we will go with panics on cycles, because it results in a much simpler system.</p>
<details id="admonition-recovering-from-panics" class="admonition info">
<summary class="admonition-title">
<p>Recovering from panics</p>
<p><a class="admonition-anchor-link" href="#admonition-recovering-from-panics"></a></p>
</summary>
<div>
<p>Panics either abort the program (when panics are set to abort in <code>Cargo.toml</code>), or unwind the call stack and then end the program.</p>
<p>When panics abort, there is nothing we can do about it. 
A panic will immediately abort the program.
When panics unwind, the call stack is unwound, which still runs all destructors (<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html" title="" target="_blank">
<code>Drop</code></a>), and this unwinding can be caught.</p>
<p>We can catch unwinding panics with <a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html" title="" target="_blank">
<code>catch_unwind</code></a>, which is a way to recover from panics.
This does require that the types used in the closure passed to <code>catch_unwind</code> are <a href="https://doc.rust-lang.org/std/panic/trait.UnwindSafe.html" title="" target="_blank">unwind safe</a>.
This is because panics exit a function early, which can mess up some invariants of your code.
For example, a call to set a task output can be skipped when a panic occurs, breaking a code invariant.
Therefore, types such as <code>&amp;mut T</code> are not unwind safe by default, because these invariants can break under panics.</p>
<p>Note that unwind safety is something different than the general safety guarantees provided by Rust: type-safe, memory-safe, thread-safe.
An unwind unsafe type is still type-safe, memory-safe, and thread-safe.</p>
<p>Unwind safety can be more easily achieved by using owned types which run destructors when the function call ends, which work under normal circumstances, but also when unwinding panics.</p>
<p>In the context of the PIE build system, if we panic on unrecoverable errors, but want to allow catching these panics, we need to think about unwind safety.
At any point we panic, we need to think about keeping the system in a valid state.</p>
<p>Another way to recover from panics is to run the panicking code on a different thread.
If the code panics, it will only end that thread, effectively allowing panic recovery.
However, this does require some form of thread-safety, beause you are moving a computation to a different thread.
Furthermore, some platforms do not have access to threads, such as WASM, where this approach would not work.</p>
<p>A final note is that care must be taken when <a href="https://doc.rust-lang.org/nomicon/ffi.html#ffi-and-unwinding" title="" target="_blank">unwiding panics across foreign function interfaces (FFI)</a>.</p>
</div>
</details>
<h2 id="checking-tasks"><a class="header" href="#checking-tasks">Checking tasks</a></h2>
<p>The final piece to our puzzle is the <code>should_execute_task</code> implementation.</p>
<p>Add the following code to <code>pie/src/context/mod.rs</code>:</p>
<pre><code class="language-rust customdiff ">     }

     output
   }
 }
+
+impl&lt;T: Task&gt; TopDownContext&lt;T, T::Output&gt; {
+  /// Checks whether given task should be executed, returning `true` if it should be executed. A task should be executed
+  /// if any of its dependencies are inconsistent, or when it has no output.
+  fn should_execute_task(&amp;mut self, node: &amp;TaskNode) -&gt; bool {
+    // Borrow: because we pass `self` (which is `&amp;mut self`) to `is_inconsistent` for recursive consistency checking, 
+    //         we need to clone and collect dependencies into a `Vec`. Otherwise we have an immutable borrow of `self`
+    //         through `self.store` while we create a mutable borrow of `self`, which is not allowed.
+    let dependencies: Vec&lt;_&gt; = self.store.get_dependencies_of_task(node).cloned().collect();
+    for dependency in dependencies {
+      match dependency.is_inconsistent(self) {
+        Ok(Some(_)) =&gt; return true,
+        _ =&gt; {} // Consistent: continue checking
+      }
+    }
+    // Task has no dependencies or all dependencies are consistent. Should only execute if it has no output, meaning
+    // that it has never been executed before.
+    return !self.store.task_has_output(node);
+  }
+}</code></pre>
<p>The premise of <code>should_execute_task</code> is simple: go over the dependencies of a task until <code>dependency.is_inconsistent</code> is true, at which we return true.
If all dependencies are consistent, then return true only if the task has no output.
Otherwise, return false.</p>
<p>However, there are some complications due to borrowing.
Checking if a task dependency is inconsistent requires recursive checking: <code>TaskDependency::is_inconsistent</code> requires a <code>&amp;mut Context</code> to call <code>Context::require_task</code>, which in turn can require this method again. 
To that end, we pass <code>self</code> to <code>is_inconsistent</code>, because <code>self</code> is an instance of <code>TopDownContext</code> which implements <code>Context</code>.</p>
<p>In this method, <code>self</code> is <code>&amp;mut self</code>, a mutable borrow.
Therefore, we cannot have <em>any other borrows</em> active while <code>is_inconsistent</code> is being called, because that would violate one of the safety mechanisms of Rust where mutable borrows are <em>exclusive</em>.
Getting the task‚Äôs dependencies from the store requires a borrow, so we cannot hold onto that borrow.
We get around that here by cloning the dependencies and collecting them into a <code>Vec</code>.</p>
<p>We also document this fact in a comment to explain to readers (us in the future) why we do this cloning, preventing refactorings only to hit that same borrowing issue again. </p>
<p>Cloning and collecting does have a performance overhead as we need to clone the dependencies and heap allocate a <code>Vec</code> to store them.
For this tutorial, that is fine, but in a real-world application we should minimize cloning if possible and look into reducing heap allocations.</p>
<details id="admonition-reference-counting" class="admonition info">
<summary class="admonition-title">
<p>Reference counting</p>
<p><a class="admonition-anchor-link" href="#admonition-reference-counting"></a></p>
</summary>
<div>
<p>Cloning a <code>Dependency</code> results in heap allocations, because cloning <code>FileDependency</code> clones a <code>PathBuf</code> which is a heap allocated string (basically a <code>Vec&lt;u8&gt;</code>), and cloning a <code>TaskDependency</code> clones the <code>Task</code>, which may require allocations as well.</p>
<p>One way to avoid heap allocations in both kinds of dependencies is to store the <code>PathBuf</code> and <code>Task</code> in a <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html" title="" target="_blank">reference-counting pointer <code>Rc</code></a>.
Then, there will only be one heap allocated <code>PathBuf</code> and <code>Task</code>, and cloning just increments the reference count.
The upside is that this approach is easy to implement and reduces allocations.
The downside is that clones require incrementing the reference count, which is a write operation that does have a tiny bit of overhead.
In many cases, this overhead is smaller than cloning data when the data is large enough or requires heap allocations.
In our case, it would probably be worth doing this, but benchmarking is required to confirm this.</p>
<p>Note that instead of always wrapping tasks in a <code>Rc</code>, task authors could implement <code>Task</code> on <code>Rc&lt;TheirTask&gt;</code> instead.
Since <code>Rc</code> implements <code>Clone</code>, any time we <code>task.clone()</code>, we would just increase the reference count instead.</p>
<p>When working in a multi-threaded situation, you would use the thread-safe <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html" title="" target="_blank">
<code>Arc</code></a> instead.</p>
</div>
</details>
<details id="admonition-string-optimizations" class="admonition info">
<summary class="admonition-title">
<p>String optimizations</p>
<p><a class="admonition-anchor-link" href="#admonition-string-optimizations"></a></p>
</summary>
<div>
<p>A technique for reducing allocations on strings (and string-like types such as <code>PathBuf</code>) is to apply <a href="https://fasterthanli.me/articles/small-strings-in-rust" title="" target="_blank">small string optimization</a>, where small strings are stored inline instead of requiring a heap allocation.
This only works if the strings are usually small enough to fit inline on the stack (for example, 32 bytes).</p>
<p>Another technique for strings is string interning, where equal strings are stored in a central place and then re-used everywhere.
This technique is great when we use the same string a lot of times.
That may be a good strategy for a build system, where we work with the same file paths over and over.</p>
<p>There are several crates implementing these techniques, but I have not used one myself yet, so I cannot recommend one.</p>
</div>
</details>
<details id="admonition-avoiding-heap-allocations-from-collecting-into-vecs" class="admonition info">
<summary class="admonition-title">
<p>Avoiding heap allocations from collecting into Vecs</p>
<p><a class="admonition-anchor-link" href="#admonition-avoiding-heap-allocations-from-collecting-into-vecs"></a></p>
</summary>
<div>
<p>Collecting the elements of an iterator into a <code>Vec</code> requires heap allocations as <code>Vec</code> is allocated on the heap.
We can avoid or at least reduce the number of heap allocations by re-using the same <code>Vec</code> instead of creating a new one.
Instead of collecting, you would store the <code>Vec</code> in the struct, clear it, and then <code>extend</code> it with the iterator.</p>
<p>When you <code>clear</code> a <code>Vec</code>, it removes all the elements, but keeps the heap allocated space.
Only if you would add more elements than it has space for, another heap allocation would be required, which will happen less and less frequently when you keep reusing the same <code>Vec</code>.
The downside is that you are keeping this heap allocated space for as long as you keep reusing the same <code>Vec</code>, which could waste some memory, but usually this is not a big problem.
You could of course call <code>vec.shrink_to_fit()</code> after not using it for a while to free up this space.</p>
<p>However, we cannot apply this technique here, because if we store the <code>Vec</code> in <code>TopDownContext</code>, we would run into the same borrowing problem again.
This technique also requires that you have mutable access to the <code>Vec</code> in order to mutate it.</p>
<p>Both of these limitations can be overcome by using a <a href="https://doc.rust-lang.org/std/cell/struct.Cell.html" title="" target="_blank">
<code>Cell</code></a>.
<code>Cell</code> allows mutation to its inner value in an immutable context.
The catch is that you <em>cannot get a reference to its inner value</em>, you can only <code>take</code> the value out, mutate it, and then <code>set</code> it back.
Unfortunately, even this technique cannot be fully applied to <code>should_execute_task</code>, because it is called recursively and therefore the <code>Cell</code> will be empty when we try to <code>take</code> the <code>Vec</code> out.</p>
<p>If we want to avoid heap allocations from collecting new <code>Vec</code>s in <code>should_execute_task</code>, we would need to come up with a creative solution.
But this is outside of the scope of even this extra information block, so we‚Äôll just leave it at that.</p>
</div>
</details>
<p>Finally, we need to do something with dependency checking failures.
We‚Äôve ignored the case where <code>dependency.is_inconsistent</code> returns <code>Err</code>.
When dependency checking result in an error, we should store the error for the user to investigate, and assume the dependency is inconsistent.</p>
<p>Change <code>pie/src/context/mod.rs</code> to store dependency check errors and give users access to it:</p>
<pre><code class="language-rust customdiff"> use crate::store::{Store, TaskNode};

 pub struct TopDownContext&lt;T, O&gt; {
   store: Store&lt;T, O&gt;,
   current_executing_task: Option&lt;TaskNode&gt;,
+  dependency_check_errors: Vec&lt;io::Error&gt;,
 }

 impl&lt;T: Task&gt; TopDownContext&lt;T, T::Output&gt; {
   pub fn new() -&gt; Self {
     Self {
       store: Store::default(),
       current_executing_task: None,
+      dependency_check_errors: Vec::default(),
     }
   }
+
+  pub fn get_dependency_check_errors(&amp;self) -&gt; impl Iterator&lt;Item=&amp;io::Error&gt; {
+    self.dependency_check_errors.iter()
+  }
 }

 impl&lt;T: Task&gt; Context&lt;T&gt; for TopDownContext&lt;T, T::Output&gt; {
   fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
     let Some(current_executing_task_node) = &amp;self.current_executing_task else {</code></pre>
<p>And then change <code>pie/src/context/mod.rs</code> to store these errors:</p>
<pre><code class="language-rust customdiff">   pub fn get_dependency_check_errors(&amp;self) -&gt; impl Iterator&lt;Item=&amp;io::Error&gt; {
     self.dependency_check_errors.iter()
   }
 }

+
 impl&lt;T: Task&gt; Context&lt;T&gt; for TopDownContext&lt;T, T::Output&gt; {
   fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
     let Some(current_executing_task_node) = &amp;self.current_executing_task else {
       return fs::open_if_file(path); // No current executing task, so no dependency needs to be made.
     };
@@ -78,10 +79,14 @@
     //         through `self.store` while we create a mutable borrow of `self`, which is not allowed.
     let dependencies: Vec&lt;_&gt; = self.store.get_dependencies_of_task(node).cloned().collect();
     for dependency in dependencies {
       match dependency.is_inconsistent(self) {
         Ok(Some(_)) =&gt; return true,
+        Err(e) =&gt; { // Error while checking: store error and assume inconsistent
+          self.dependency_check_errors.push(e);
+          return true;
+        }
         _ =&gt; {} // Consistent: continue checking
       }
     }
     // Task has no dependencies or all dependencies are consistent. Should only execute if it has no output, meaning
     // that it has never been executed before.</code></pre>
<p>It took us a while, but now we‚Äôve implemented an incremental build system with dynamic dependencies üéâ.
Let‚Äôs set up an example to see the fruits of our labour.</p>
<h2 id="incrementality-example"><a class="header" href="#incrementality-example">Incrementality Example</a></h2>
<p>In this example, we will show off incrementality using two tasks: a task that reads a string from a file, and a task that writes a string to a file.
The writing task gets the string by requiring another task.
Therefore, we will have a read task with a file dependency, and a write task with a task and file dependency.
Because we only support one type of task, we will wrap these tasks in an enum.</p>
<h3 id="filetask-enumeration"><a class="header" href="#filetask-enumeration">FileTask enumeration</a></h3>
<p>Create the <code>pie/examples</code> directory, and create the <code>pie/examples/incrementality.rs</code> file with the following contents:</p>
<pre><code class="language-rust ">#![allow(unused_imports, unused_variables)]

use std::fs::{File, read_to_string, remove_file, write};
use std::io::{self, Read, Write};
use std::path::{Path, PathBuf};

use dev_shared::{create_temp_dir, write_until_modified};
use pie::{Context, Task};
use pie::context::top_down::TopDownContext;
use pie::stamp::FileStamper;

/// Enumeration over file pseudo-tasks.
#[derive(Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]
enum FileTask {
  ReadStringFromFile(ReadStringFromFile),
  WriteStringToFile(WriteStringToFile),
}

/// [`Task`] implementation for [`FileTask`], forwarding execute to the execute functions of the pseudo-tasks.
impl Task for FileTask {
  type Output = Result&lt;String, io::ErrorKind&gt;;
  fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
    match self {
      FileTask::ReadStringFromFile(t) =&gt; t.execute(context),
      FileTask::WriteStringToFile(t) =&gt; t.execute(context).map(|_| String::new())
    }
  }
}
</code></pre>
<p><code>FileTask</code> is the enum over the <code>ReadStringFromFile</code> and <code>WriteStringToFile</code> ‚Äúpseudo-tasks‚Äù that we still need to define.
We call these types pseudo-tasks, because they behave like tasks, but do not actually implement <code>Task</code>.
We implement <code>Task</code> on <code>FileTask</code> instead, which forwards the <code>execute</code> method to the pseudo-tasks.</p>
<p>Both tasks can fail due to using filesystem operations, so the output is a <code>Result</code>.
We cannot use <code>std::io::Error</code> as the error in the <code>Result</code>, because it does not implement <code>Clone</code> nor <code>Eq</code>, which need to be implemented for task outputs.
Therefore, we use <code>std::io::ErrorKind</code> which does implement these traits.</p>
<p>On success, we return a <code>String</code>.
Because <code>WriteStringToFile</code> will not return a value (i.e., <code>()</code>) on success, we return an empty string with <code>String::new()</code>.
It would be cleaner to define an <code>FileOutput</code> enum that enumerates the possible outputs of file tasks, which would include a variant for <code>WriteStringToFile</code> returning <code>()</code>.
But to keep this example simple we don‚Äôt do that.</p>
<h3 id="readwrite-pseudo-tasks"><a class="header" href="#readwrite-pseudo-tasks">Read/write pseudo-tasks</a></h3>
<p>Now add <code>ReadStringFromFile</code> to <code>pie/examples/incrementality.rs</code>:</p>
<pre><code class="language-rust ">/// Pseudo-task that reads a string from a file.
#[derive(Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]
struct ReadStringFromFile(PathBuf, FileStamper);

impl ReadStringFromFile {
  fn new(path: impl AsRef&lt;Path&gt;, stamper: FileStamper) -&gt; FileTask {
    FileTask::ReadStringFromFile(Self(path.as_ref().to_path_buf(), stamper))
  }
  fn execute&lt;C: Context&lt;FileTask&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Result&lt;String, io::ErrorKind&gt; {
    println!(&quot;Reading from {} with {:?} stamper&quot;, self.0.file_name().unwrap().to_string_lossy(), self.1);
    let file = context.require_file_with_stamper(&amp;self.0, self.1).map_err(|e| e.kind())?;
    if let Some(mut file) = file {
      let mut string = String::new();
      file.read_to_string(&amp;mut string).map_err(|e| e.kind())?;
      Ok(string)
    } else {
      Err(io::ErrorKind::NotFound)
    }
  }
}
</code></pre>
<p>We‚Äôve already defined a task like this before, but now it accepts a <code>FileStamper</code>, prints something when it gets executed, and propagates errors.</p>
<p>Add <code>WriteStringToFile</code> to <code>pie/examples/incrementality.rs</code>:</p>
<pre><code class="language-rust ">/// Pseudo-task that writes a string to a file, where the string is provided by another task. The string provider is 
/// boxed to prevent a cyclic definition of infinite size, due to this type being used in [`FileTask`].
#[derive(Clone, Ord, PartialOrd, Eq, PartialEq, Hash, Debug)]
struct WriteStringToFile(Box&lt;FileTask&gt;, PathBuf, FileStamper);

impl WriteStringToFile {
  fn new(string_provider: impl Into&lt;Box&lt;FileTask&gt;&gt;, path: impl Into&lt;PathBuf&gt;, stamper: FileStamper) -&gt; FileTask {
    FileTask::WriteStringToFile(Self(string_provider.into(), path.into(), stamper))
  }
  fn execute&lt;C: Context&lt;FileTask&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Result&lt;(), io::ErrorKind&gt; {
    println!(&quot;Writing to {} with {:?} stamper&quot;, self.1.file_name().unwrap().to_string_lossy(), self.2);
    let string = context.require_task(&amp;self.0)?;
    let mut file = File::create(&amp;self.1).map_err(|e| e.kind())?;
    file.write_all(string.as_bytes()).map_err(|e| e.kind())?;
    context.require_file_with_stamper(&amp;self.1, self.2).map_err(|e| e.kind())?;
    Ok(())
  }
}
</code></pre>
<p>What is special about this task, is that it takes another task as input!
Tasks in a programmatic incremental build system are first-class, meaning that they are just values that can be passed around.</p>
<p>This is similar to closures in Rust and other programming languages, which are functions (with some values captured from the environment), but are also values that can be passed around.
Tasks can therefore be seen as a form of incremental closures, although they need to be executed under a <code>Context</code> for incrementality, whereas closures are more free-form.</p>
<p><code>WriteStringToFile</code> requires the task to (incrementally) get the string, creating a task dependency.
Then it writes that string to a file, and requires that file to create a file dependency.</p>
<details id="admonition-boxing-to-prevent-cyclic-definition" class="admonition info">
<summary class="admonition-title">
<p>Boxing to prevent cyclic definition</p>
<p><a class="admonition-anchor-link" href="#admonition-boxing-to-prevent-cyclic-definition"></a></p>
</summary>
<div>
<p>We store the task as <code>Box&lt;FileTask&gt;</code> in order to prevent a cyclic definition, which would cause <code>FileTask</code> to have an undetermined size.
This is due to several reasons:</p>
<ul>
<li>In Rust, values are stored on the stack by default. To store something on the stack, Rust needs to know its size <em>at compile-time</em>.</li>
<li>The size of an <code>enum</code> is the size of the largest variant.</li>
<li>The size of a struct is the sum of the size of the fields.</li>
</ul>
<p>If we don‚Äôt box the task, to calculate the size of <code>WriteStringToFile</code>, we need to calculate the size of <code>FileTask</code>, which would require calculating the size of <code>WriteStringToFile</code>, and so forth.
Therefore, we can‚Äôt calulate the size of <code>WriteStringToFile</code> and <code>FileTask</code>, which is an error.</p>
<p>Boxing solves this because <code>Box&lt;FileTask&gt;</code> allocates a <code>FileTask</code> on the heap, and then creates a pointer to it.
Therefore, the size of <code>Box&lt;FileTask&gt;</code> is the size of one pointer, breaking the cycle in the size calculations.</p>
<p>Note that this explanation <a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html" title="" target="_blank">simplifies many aspects of Rust‚Äôs size calculation</a>.</p>
</div>
</details>
<h3 id="exploring-incrementality"><a class="header" href="#exploring-incrementality">Exploring incrementality</a></h3>
<p>We‚Äôve implemented the tasks, now add a <code>main</code> function to <code>pie/examples/incrementality.rs</code>:</p>
<pre><code class="language-rust ">fn main() -&gt; Result&lt;(), io::Error&gt; {
  let temp_dir = create_temp_dir()?;
  let input_file = temp_dir.path().join(&quot;input.txt&quot;);
  write(&amp;input_file, &quot;Hi&quot;)?;
  let output_file = temp_dir.path().join(&quot;output.txt&quot;);

  let mut context = TopDownContext::new();
  let read_task = ReadStringFromFile::new(&amp;input_file, FileStamper::Modified);
  let write_task = WriteStringToFile::new(read_task.clone(), &amp;output_file, FileStamper::Modified);

  println!(&quot;A) New task: expect `read_task` to execute&quot;);
  // `read_task` is new, meaning that we have no cached output for it, thus it must be executed.
  let output = context.require_task(&amp;read_task)?;
  assert_eq!(&amp;output, &quot;Hi&quot;);

  Ok(())
}</code></pre>
<p>We create some temporary files, create our tasks, create a context, and require our first task.
Run this example with <code>cargo run --example incremental</code>.
You should see the <code>println!</code> in <code>ReadStringFromFile</code> appear in your console as the incremental context correctly determines that this task is new (i.e., has no output) and must be executed.
It should look something like:</p>
<pre><code>   Compiling pie v0.1.0 (/private/pie)
    Finished dev [unoptimized + debuginfo] target(s) in 1.28s
     Running `/private/pie/target/debug/examples/incremental`
A) New task: expect `read_task` to execute
Reading from input.txt with Modified stamper
</code></pre>
<h4 id="reuse"><a class="header" href="#reuse">Reuse</a></h4>
<p>If we require the task again, what should happen?</p>
<p>Insert the following code into the <code>main</code> method:</p>
<pre><code class="language-rust ">  println!(&quot;\nB) Reuse: expect no execution&quot;);
  // `read_task` is not new and its file dependency is still consistent. It is consistent because the modified time of 
  // `input_file` has not changed, thus the modified stamp is equal.
  let output = context.require_task(&amp;read_task)?;
  assert_eq!(&amp;output, &quot;Hi&quot;);
</code></pre>
<p>Running with <code>cargo run --example incremental</code> should produce output like:</p>
<pre><code>   Compiling pie v0.1.0 (/private/pie)
    Finished dev [unoptimized + debuginfo] target(s) in 0.64s
     Running `/private/pie/target/debug/examples/incremental`
A) New task: expect `read_task` to execute
Reading from input.txt with Modified stamper

B) Reuse: expect no execution
</code></pre>
<p>We don‚Äôt see the <code>println!</code> from <code>ReadStringFromFile</code>, so it was not executed, so our incremental build system has correctly reused its output!</p>
<p>Normally we would write a test to confirm that the task was executed the first time, and that it was not executed the second time.
However, this is not trivial.
How do we know if the task was executed?
We could track it with a global mutable boolean that <code>ReadStringFromFile</code> keeps track of, but this quickly becomes a mess.
Therefore, we will look into creating a proper testing infrastructure in the next chapter.</p>
<p>For now, we will continue this example with several more interesting cases.
The comments in the code explain in more detail why the build system behaves in this way.</p>
<h4 id="inconsistent-file-dependency"><a class="header" href="#inconsistent-file-dependency">Inconsistent file dependency</a></h4>
<p>Insert into the <code>main</code> method:</p>
<pre><code class="language-rust ">  write_until_modified(&amp;input_file, &quot;Hello&quot;)?;
  println!(&quot;\nC) Inconsistent file dependency: expect `read_task` to execute&quot;);
  // The file dependency of `read_task` is inconsistent due to the changed modified time of `input_file`.
  let output = context.require_task(&amp;read_task)?;
  assert_eq!(&amp;output, &quot;Hello&quot;);
</code></pre>
<p>If we change the file (using <code>write_until_modified</code> to ensure that the modified time changes to trigger the <code>Modified</code> file stamper) and require the task, it should execute, because the file dependency of the task is no longer consistent.</p>
<h4 id="new-write-task-reuse-read-task"><a class="header" href="#new-write-task-reuse-read-task">New write task, reuse read task</a></h4>
<p>Insert into the <code>main</code> method:</p>
<pre><code class="language-rust ">  println!(&quot;\nD) New task, reuse other: expect only `write_task` to execute&quot;);
  // write_task` is new, but `read_task` is not new and its file dependency is still consistent.
  context.require_task(&amp;write_task)?;
  assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello&quot;);
</code></pre>
<p>Now we require a new <code>WriteStringToFile</code> task, which requires the <code>ReadStringFromFile</code> task.
However, since the read task is still consistent (its file dependency is consistent), we only expect the write task to execute. 
We also assert that the write task wrote the correct string to the file.</p>
<h4 id="sound-incrementality-with-top-down-building"><a class="header" href="#sound-incrementality-with-top-down-building">Sound incrementality with top-down building</a></h4>
<p>Insert into the <code>main</code> method:</p>
<pre><code class="language-rust ">  write_until_modified(&amp;input_file, &quot;Hello, World!&quot;)?;
  println!(&quot;\nE) Inconsistent file and task dependency: expect both tasks to execute&quot;);
  // The file dependency of `read_task` is inconsistent. Then, the task dependency from `write_task` to `read_task` is 
  // inconsistent because `read_task` now returns `&quot;Hello, World!&quot;` as output instead of &quot;Hello&quot;, and thus its equals 
  // output stamp is different.
  context.require_task(&amp;write_task)?;
  assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello, World!&quot;);
</code></pre>
<p>We change the input file and expect both read and write tasks to execute.
We require the write task, which checks whether it should be executed by consistency checking its dependencies.
The write task has a task dependency to the read task, so we check that for consistency.
That recurses into requiring the read task, where we again check whether it should be executed.
There, we discover that its input file dependency is inconsistent, so we execute the read task, which now returns <code>&quot;Hello, World!&quot;</code> instead of <code>&quot;Hello&quot;</code>.</p>
<p>Now we are back to the consistency check for the task dependency from the write task to the read task.
The previous output stamp for that task dependency is <code>Equals(&quot;Hello&quot;)</code>, but the new stamp is <code>Equals(&quot;Hello, World!&quot;)</code>, so the task dependency is inconsistent!
Therefore, we execute the write task, which correctly writes the new string to the output file.</p>
<p>This example shows why we need top-down incremental building for sound incrementality.
To ensure that the write task writes the up-to-date string to the output file, we first need to check (and possibly execute) the read task, ensuring it returns the up-to-date string.</p>
<h4 id="early-cutoff"><a class="header" href="#early-cutoff">Early cutoff</a></h4>
<p>Insert into the <code>main</code> method:</p>
<pre><code class="language-rust ">  write_until_modified(&amp;input_file, &quot;Hello, World!&quot;)?; // Note: writing same file contents!
  println!(&quot;\nF) Early cutoff: expect only `read_task` to execute&quot;);
  // File dependency of `read_task` is inconsistent because the modified time changed, but it returns the same output 
  // `&quot;Hello, World!&quot;` because the contents of the file have not actually changed. Then, the task dependency from 
  // `write_task` to `read_task` is consistent because its output did not change, and thus the equality output stamp is 
  // the same.
  context.require_task(&amp;write_task)?;
  assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello, World!&quot;);
</code></pre>
<p>This is very similar to the last operation.
The subtle difference is that we <em>are</em> writing to the input file, but we <em>write the same contents</em>.
This results in a file with a new modified time, but the same contents.</p>
<p>We expect the read task to execute, because its file dependency is inconsistent.
However, the previous output stamp of the task dependency from write to read is <code>Equals(&quot;Hello, World!&quot;)</code>, but the new one is also <code>Equals(&quot;Hello, World!&quot;)</code> because the read task still returns <code>&quot;Hello, World!&quot;</code>.
Therefore, the task dependency is consistent, and we do not execute the write task.</p>
<p>We call this <em>early cutoff</em>, because we can cut off building a task early, if we figure out its task dependency is consistent <em>due to having the same output stamp</em>.
Early cutoff is possible due to the precise dependency tracking provided by dynamic dependencies.
This is one of the pieces that makes this build system incremental: we don‚Äôt execute the write task because it is not affected by a change.</p>
<details id="admonition-different-stampers" class="admonition info">
<summary class="admonition-title">
<p>Different stampers</p>
<p><a class="admonition-anchor-link" href="#admonition-different-stampers"></a></p>
</summary>
<div>
<p>If we want the write task to always write to the output file regardless of what the read task returns, we could implement an <code>Always</code> output stamp that is always inconsistent.</p>
<p>In general, output (and file) stamps can be used to finetune incrementality, ensuring that tasks are only executed when they are really affected by a change.</p>
</div>
</details>
<h4 id="regenerate-output-files"><a class="header" href="#regenerate-output-files">Regenerate output files</a></h4>
<p>Insert into the <code>main</code> method:</p>
<pre><code class="language-rust ">  write_until_modified(&amp;output_file, &quot;&quot;)?;
  println!(&quot;\nG) Regenerate changed output file: expect only `write_task` to execute&quot;);
  // The file dependency of `write_task` to `output_file` is inconsistent.
  context.require_task(&amp;write_task)?;
  assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello, World!&quot;);

  write_until_modified(&amp;output_file, &quot;&quot;)?;
  remove_file(&amp;output_file)?;
  println!(&quot;\nH) Regenerate deleted output file: expect only `write_task` to execute&quot;);
  // Same results when `output_file` is deleted.
  context.require_task(&amp;write_task)?;
  assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello, World!&quot;);
</code></pre>
<p>The write task writes to an output file and then creates a file dependency to it.
Therefore, if we modify or remove the output file, and require the write task, it will regenerate the output file because the file dependency is inconsistent.</p>
<p>Many build systems do not track this dependency to output files, which can result in incrementality bugs due to output files being deleted (for example, due to a <code>git clean</code>).
By tracking these output file dependencies, we ensure that the output files are in a consistent state after every build.</p>
<details id="admonition-dont-regenerate-ouput-files" class="admonition info">
<summary class="admonition-title">
<p>Don‚Äôt regenerate ouput files</p>
<p><a class="admonition-anchor-link" href="#admonition-dont-regenerate-ouput-files"></a></p>
</summary>
<div>
<p>We can omit the file dependency in the write task to not regenerate output files when they are changed or deleted, if desired.
However, this is not recommended due to the possibility of (incrementality) bugs.</p>
</div>
</details>
<h4 id="different-tasks"><a class="header" href="#different-tasks">Different tasks</a></h4>
<p>Insert into the <code>main</code> method:</p>
<pre><code class="language-rust ">  let input_file_b = temp_dir.path().join(&quot;input_b.txt&quot;);
  write(&amp;input_file_b, &quot;Test&quot;)?;
  let read_task_b_modified = ReadStringFromFile::new(&amp;input_file_b, FileStamper::Modified);
  let read_task_b_exists = ReadStringFromFile::new(&amp;input_file_b, FileStamper::Exists);
  println!(&quot;\nI) Different tasks: expect `read_task_b_modified` and `read_task_b_exists` to execute&quot;);
  // Task `read_task`, `read_task_b_modified` and `read_task_b_exists` are different, due to their `Eq` implementation 
  // determining that their paths and stampers are different. Therefore, `read_task_b_modified` and `read_task_b_exists`
  // are new tasks, and must be executed.
  let output = context.require_task(&amp;read_task_b_modified)?;
  assert_eq!(&amp;output, &quot;Test&quot;);
  let output = context.require_task(&amp;read_task_b_exists)?;
  assert_eq!(&amp;output, &quot;Test&quot;);
</code></pre>
<p>The identity of tasks is determined by their <code>Eq</code> and <code>Hash</code> implementations, which are typically derived to compare and hash all their fields.
Therefore, if we create read tasks for different input file <code>input_file_b</code> and different stamper <code>FileStamper::Exists</code>, these read tasks are not equal to the existing read task, and thus are <em>new</em> tasks with a different identity.
We require <code>read_task_b_modified</code> and <code>read_task_b_exists</code>, they are new, and are therefore executed.</p>
<h4 id="same-file-different-stampers"><a class="header" href="#same-file-different-stampers">Same file different stampers</a></h4>
<p>Insert into the <code>main</code> method:</p>
<pre><code class="language-rust ">  write_until_modified(&amp;input_file_b, &quot;Test Test&quot;)?;
  println!(&quot;\nJ) Different stampers: expect only `read_task_b_modified` to execute&quot;);
  // Both `read_task_b_modified` and `read_task_b_exists` read from the same file, but they use different stampers.
  // Therefore, `read_task_b_modified` must be executed because the modified time has changed, but `read_task_b_exists`
  // will not be executed because its file dependency stamper only checks for existence of the file, and the existence 
  // of the file has not changed.
  //
  // Note that using an `Exists` stamper for this task does not make a lot of sense, since it will only read the file 
  // on first execute and when it is recreated. But this is just to demonstrate different stampers.
  let output = context.require_task(&amp;read_task_b_modified)?;
  assert_eq!(&amp;output, &quot;Test Test&quot;);
  let output = context.require_task(&amp;read_task_b_exists)?;
  assert_eq!(&amp;output, &quot;Test&quot;);
</code></pre>
<p>Here we write to <code>input_file_b</code> and then require <code>read_task_b_modified</code> and <code>read_task_b_exists</code>.
We expect <code>read_task_b_modified</code> to be executed, but <code>read_task_b_exists</code> to be skipped, because its file dependency only checks for the existence of the input file, which has not changed.
This shows that tasks can depend on the same file with different stampers, which influences whether the tasks are affected by a file change individually.</p>
<p>Of course, using an <code>Exists</code> stamper for <code>ReadStringFromFile</code> does not make a lot of sense, but this is for demonstration purposes only.</p>
<p>Running <code>cargo run --example incremental</code> now should produce output like:</p>
<pre><code>   Compiling pie v0.1.0 (/private/pie)
    Finished dev [unoptimized + debuginfo] target(s) in 0.67s
     Running `/private/pie/target/debug/examples/incremental`
A) New task: expect `read_task` to execute
Reading from input.txt with Modified stamper

B) Reuse: expect no execution

C) Inconsistent file dependency: expect `read_task` to execute
Reading from input.txt with Modified stamper

D) New task, reuse other: expect only `write_task` to execute
Writing to output.txt with Modified stamper

E) Inconsistent file and task dependency: expect both tasks to execute
Reading from input.txt with Modified stamper
Writing to output.txt with Modified stamper

F) Early cutoff: expect only `read_task` to execute
Reading from input.txt with Modified stamper

G) Regenerate changed output file: expect only `write_task` to execute
Writing to output.txt with Modified stamper

H) Regenerate deleted output file: expect only `write_task` to execute
Writing to output.txt with Modified stamper

I) Different tasks: expect `read_task_b_modified` and `read_task_b_exists` to execute
Reading from input_b.txt with Modified stamper
Reading from input_b.txt with Exists stamper

J) Different stampers: expect only `read_task_b_modified` to execute
Reading from input_b.txt with Modified stamper
</code></pre>
<p>Feel free to experiment more with this example (or new example files) before continuing.
In the next chapter, we will define minimality and soundness, set up an infrastructure for testing those properties, and fix issues uncovered by testing.</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="../../gen/2_incrementality/5b_context_example/source.zip">download the source files up to this point</a>.</p>
</div>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../2_incrementality/4_store/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../3_min_sound/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../2_incrementality/4_store/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../3_min_sound/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../src/diff.js"></script>


    </div>
    </body>
</html>
