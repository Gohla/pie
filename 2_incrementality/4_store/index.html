<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dependency Graph Store - Build your own Programmatic Incremental Build System</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../.././diff2html.min.css">
        <link rel="stylesheet" href="../.././mdbook-admonish.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../0_intro/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../0_intro/1_setup/index.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li></ol></li><li class="chapter-item expanded "><a href="../../1_programmability/index.html"><strong aria-hidden="true">2.</strong> Programmability</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../1_programmability/1_api/index.html"><strong aria-hidden="true">2.1.</strong> Programmable Build System API</a></li><li class="chapter-item expanded "><a href="../../1_programmability/2_non_incremental/index.html"><strong aria-hidden="true">2.2.</strong> Non-Incremental Context</a></li></ol></li><li class="chapter-item expanded "><a href="../../2_incrementality/index.html"><strong aria-hidden="true">3.</strong> Incrementality</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../2_incrementality/1_require_file/index.html"><strong aria-hidden="true">3.1.</strong> Requiring Files</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/2_stamp/index.html"><strong aria-hidden="true">3.2.</strong> Stamps</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/3_dependency/index.html"><strong aria-hidden="true">3.3.</strong> Dynamic Dependencies</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/4_store/index.html" class="active"><strong aria-hidden="true">3.4.</strong> Dependency Graph Store</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/5_context/index.html"><strong aria-hidden="true">3.5.</strong> Incremental Top-Down Context</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/6_example/index.html"><strong aria-hidden="true">3.6.</strong> Incrementality Example</a></li></ol></li><li class="chapter-item expanded "><a href="../../3_min_sound/index.html"><strong aria-hidden="true">4.</strong> Testing Incrementality & Soundness</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../3_min_sound/1_session/index.html"><strong aria-hidden="true">4.1.</strong> Minimality with Sessions</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/2_tracker/index.html"><strong aria-hidden="true">4.2.</strong> Tracking Build Events</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/3_test/index.html"><strong aria-hidden="true">4.3.</strong> Integration Testing</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/4_fix_task_dep/index.html"><strong aria-hidden="true">4.4.</strong> Fix Superfluous Task Dependency</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/5_overlap/index.html"><strong aria-hidden="true">4.5.</strong> Prevent Overlapping File Writes</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/6_hidden_dep/index.html"><strong aria-hidden="true">4.6.</strong> Prevent Hidden Dependencies</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/7_cycle/index.html"><strong aria-hidden="true">4.7.</strong> Prevent Cycles</a></li></ol></li><li class="chapter-item expanded "><a href="../../4_next/index.html"><strong aria-hidden="true">5.</strong> What's Next?</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
<!-- CHANGE: removed all but light and ayu theme, and renamed ayu to dark -->                          
<!--                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>-->
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/edit/master/tutorial/src/2_incrementality/4_store/index.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dependency-graph-store"><a class="header" href="#dependency-graph-store">Dependency Graph Store</a></h1>
<p>To do incremental building, we need to keep track of all files, tasks, their dependencies, and task outputs, in a dependency graph.
This will be the responsibility of the <code>Store</code> data structure.
Context implementations will use methods on <code>Store</code> to query and mutate the dependency graph.
In other words, <code>Store</code> encapsulates the dependency graph.</p>
<p>However, writing a dependency graph data structure is outside of the scope of this tutorial, so we will be using the <code>pie_graph</code> library which we prepared exactly for this use case.
The graph from this library is a directed acyclic graph (DAG), meaning that edges are directed and there may be no cycles in edges, as that would prohibit topological orderings.</p>
<details id="admonition-graph-library" class="admonition admonish-tip">
<summary class="admonition-title">
<p>Graph Library</p>
<p><a class="admonition-anchor-link" href="#admonition-graph-library"></a></p>
</summary>
<div>
<p>The <code>pie_graph</code> library is a modified version of the great <a href="https://github.com/declanvk/incremental-topo/" title="" target="_blank">
<code>incremental-topo</code></a> library which implements incremental topological ordering: it keeps the topological ordering up-to-date incrementally while nodes and edges are added and removed.
That is exactly what we need, as dynamic dependencies prevents us from calculating the topological ordering in one go, and calculating the topological ordering after every task execution is prohibitively expensive.
The implementation in the <code>incremental-topo</code> library is based on a <a href="http://www.doc.ic.ac.uk/~phjk/Publications/DynamicTopoSortAlg-JEA-07.pdf" title="" target="_blank">paper by D. J. Pearce and P. H. J. Kelly</a> that describes several dynamic topological sort algorithms for directed acyclic graphs.</p>
</div>
</details>
<p>Add the <code>pie_graph</code> dependency to <code>pie/Cargo.toml</code>:</p>
<div class="diff2html" id="diff2html_0"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/Cargo.toml
+++ pie/Cargo.toml
@@ -3,6 +3,9 @@
 version = "0.1.0"
 edition = "2021"
 
+[dependencies]
+pie_graph = "0.0.1"
+
 [dev-dependencies]
 dev_shared = { path = "../dev_shared" }
 assert_matches = "1"
`;
    let target = document.getElementById('diff2html_0');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<h2 id="store-basics"><a class="header" href="#store-basics">Store basics</a></h2>
<p>Add the <code>store</code> module to <code>pie/src/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_1"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -10,6 +10,7 @@
 pub mod dependency;
 pub mod context;
 mod fs;
+mod store;
 
 /// A unit of computation in a programmatic incremental build system.
 pub trait Task: Clone + Eq + Hash + Debug {
`;
    let target = document.getElementById('diff2html_1');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>This module is private, as users of the library should not interact with the store.
Only <code>Context</code> implementations will use the store.</p>
<p>Create the <code>pie/src/store.rs</code> file and add the following to get started:</p>
<pre><code class="language-rust ">use std::path::{Path, PathBuf};

use pie_graph::{DAG, Node};

use crate::dependency::{Dependency, FileDependency, TaskDependency};
use crate::Task;

/// Stores files and tasks, and their dependencies, in a DAG (directed acyclic graph). Provides operations to mutate
/// and query this graph.
pub struct Store&lt;T, O&gt; {
  graph: DAG&lt;NodeData&lt;T, O&gt;, Dependency&lt;T, O&gt;&gt;,
}

#[derive(Debug)]
enum NodeData&lt;T, O&gt; {
  File(PathBuf),
  Task {
    task: T,
    output: Option&lt;O&gt;,
  },
}

impl&lt;T: Task&gt; Default for Store&lt;T, T::Output&gt; {
  fn default() -&gt; Self {
    Self {
      graph: DAG::default(),
    }
  }
}</code></pre>
<p>The <code>Store</code> is generic over tasks <code>T</code> and their outputs <code>O</code>, like we have done before with <code>Dependency</code>.</p>
<p>The <code>DAG</code> type from <code>pie_graph</code> represents a DAG with nodes and edges, and data attached to those nodes and edges.
The nodes in our graph are either files or tasks, and the edges are dependencies.</p>
<p>The first generic argument to <code>DAG</code> is the type of data to attach to nodes, which is <code>NodeData&lt;T, O&gt;</code> in our case.
Because nodes can be files or tasks, <code>NodeData&lt;T, O&gt;</code> enumerates these, storing the path for files, and the task along with its output for tasks.
We store file paths as <code>PathBuf</code>, which is the owned version of <code>Path</code> (similar to <code>String</code> being the owned version of <code>str</code>).
The task output is stored as <code>Option&lt;O&gt;</code> because we can add a task to the graph without having executed it, so we don’t have its output yet.</p>
<p>The second argument is the type of data to attach to edges, which is <code>Dependency&lt;T, O&gt;</code>, using the <code>Dependency</code> enum we defined earlier.</p>
<p>We implement <code>Default</code> for the store to initialize it.</p>
<details id="admonition-why-not-derive-default" class="admonition admonish-question">
<summary class="admonition-title">
<p>Why not Derive Default?</p>
<p><a class="admonition-anchor-link" href="#admonition-why-not-derive-default"></a></p>
</summary>
<div>
<p>We cannot derive this <code>Default</code> implementation even though it seems we should be able to, because the derived implementation will require <code>T</code> and <code>O</code> to be <code>Default</code>, and this is not always the case.
This is because the <code>Default</code> derive macro is conservative and adds a <code>: Default</code> bound to <em>every</em> generic argument in the <code>Default</code> trait implementation, and there is no way to disable this behaviour.
Therefore, we implement <code>Default</code> ourselves.</p>
<p>There are several crates that have more configurable derive macros for these things, but adding an extra dependency to generate a few lines of code is not worth the extra compilation time, so we just implement it manually here.</p>
</div>
</details>
<h2 id="graph-nodes"><a class="header" href="#graph-nodes">Graph nodes</a></h2>
<p>A node in <code>DAG</code> is represented by a <code>Node</code>, which is a transparent identifier (sometimes called a <a href="https://en.wikipedia.org/wiki/Handle_(computing)" title="" target="_blank">handle</a>) that points to the node and its data.
We can create nodes in the graph, and then query attached data (<code>NodeData</code>) given a node.
So <code>DAG</code> allows us to go from <code>Node</code> to a <code>PathBuf</code> and task <code>T</code> through attached <code>NodeData</code>.</p>
<p>However, we want each unique file and task to be represented by a single unique node in the graph.
We need this for incrementality so that if the build system encounters the same task twice, we can find the corresponding task node in the graph the second time, check if it is consistent, and return its output if it is.</p>
<p>To ensure unique nodes, we need to maintain the reverse mapping from <code>PathBuf</code> and <code>T</code> to <code>Node</code> ourselves, which we will do with <code>HashMap</code>s.
This is also the reason for the <code>Eq</code> and <code>Hash</code> trait bounds on the <code>Task</code> trait, so we can use them as keys in <code>HashMap</code>s.</p>
<p>Change <code>pie/src/store.rs</code> to add hash maps to map between these things:</p>
<div class="diff2html" id="diff2html_2"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/store.rs
+++ pie/src/store.rs
@@ -1,3 +1,4 @@
+use std::collections::HashMap;
 use std::path::{Path, PathBuf};
 
 use pie_graph::{DAG, Node};
@@ -9,6 +10,8 @@
 /// and query this graph.
 pub struct Store<T, O> {
   graph: DAG<NodeData<T, O>, Dependency<T, O>>,
+  file_to_node: HashMap<PathBuf, Node>,
+  task_to_node: HashMap<T, Node>,
 }
 
 #[derive(Debug)]
@@ -24,6 +27,8 @@
   fn default() -> Self {
     Self {
       graph: DAG::default(),
+      file_to_node: HashMap::default(),
+      task_to_node: HashMap::default(),
     }
   }
 }
`;
    let target = document.getElementById('diff2html_2');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>To prevent accidentally using a file node as a task node, and vice versa, change <code>pie/src/store.rs</code> to add specific types of nodes:</p>
<div class="diff2html" id="diff2html_3"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/store.rs
+++ pie/src/store.rs
@@ -1,3 +1,4 @@
+use std::borrow::Borrow;
 use std::collections::HashMap;
 use std::path::{Path, PathBuf};
 
@@ -10,8 +11,8 @@
 /// and query this graph.
 pub struct Store<T, O> {
   graph: DAG<NodeData<T, O>, Dependency<T, O>>,
-  file_to_node: HashMap<PathBuf, Node>,
-  task_to_node: HashMap<T, Node>,
+  file_to_node: HashMap<PathBuf, FileNode>,
+  task_to_node: HashMap<T, TaskNode>,
 }
 
 #[derive(Debug)]
@@ -23,6 +24,24 @@
   },
 }
 
+/// Newtype for file ${"`"}Node${"`"}s.
+#[repr(transparent)]
+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
+pub struct FileNode(Node);
+
+impl Borrow<Node> for &FileNode {
+  fn borrow(&self) -> &Node { &self.0 }
+}
+
+/// Newtype for task ${"`"}Node${"`"}s.
+#[repr(transparent)]
+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
+pub struct TaskNode(Node);
+
+impl Borrow<Node> for &TaskNode {
+  fn borrow(&self) -> &Node { &self.0 }
+}
+
 impl<T: Task> Default for Store<T, T::Output> {
   fn default() -> Self {
     Self {
`;
    let target = document.getElementById('diff2html_3');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>The <code>FileNode</code> and <code>TaskNode</code> types are <a href="https://rust-unofficial.github.io/patterns/patterns/behavioural/newtype.html" title="" target="_blank">newtypes</a> that wrap a <code>Node</code> into a specific type of node.
The <code>Borrow</code> implementations will make subsequent code a bit more concise by automatically converting <code>&amp;FileNode</code> and <code>&amp;TaskNode</code>s to <code>&amp;Node</code>s.</p>
<details id="admonition-do-these-newtypes-improve-type-safety" class="admonition admonish-question">
<summary class="admonition-title">
<p>Do these Newtypes Improve Type-Safety?</p>
<p><a class="admonition-anchor-link" href="#admonition-do-these-newtypes-improve-type-safety"></a></p>
</summary>
<div>
<p>Because the <code>Node</code>s inside the newtypes are not public, it is not possible to construct a <code>FileNode</code> or <code>TaskNode</code> outside of this module.
Therefore, if we only accept and create <code>FileNode</code> and <code>TaskNode</code> in the <code>Store</code> API, it is not possible to use the wrong kind of node, increasing type-safety.</p>
<p>The <code>Borrow</code> implementation does leak outside of this module, but not outside of this crate (library).
This is because the visibility of a trait implementation is the intersection of the visibilities of the trait and type it is implemented on.
<code>Borrow</code> is public, but <code>FileNode</code> and <code>TaskNode</code> are only public within this crate.
Thefore, modules of this crate can extract the <code>Node</code> out of <code>FileNode</code> and <code>TaskNode</code>.
However, that <code>Node</code> cannot be used to construct a <code>FileNode</code> or <code>TaskNode</code>, so it is not a problem.</p>
</div>
</details>
<p>Now we will add methods create nodes and to query their attached data.
Add the following code to <code>pie/src/store.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;T: Task&gt; Store&lt;T, T::Output&gt; {
  /// Gets the file node for `path`, or creates a file node by adding it to the dependency graph.
  pub fn get_or_create_file_node(&amp;mut self, path: impl AsRef&lt;Path&gt;) -&gt; FileNode {
    let path = path.as_ref();
    if let Some(file_node) = self.file_to_node.get(path) {
      *file_node
    } else {
      let node = self.graph.add_node(NodeData::File(path.to_path_buf()));
      let node = FileNode(node);
      self.file_to_node.insert(path.to_path_buf(), node);
      node
    }
  }
  /// Gets the path for `node`.
  ///
  /// # Panics
  ///
  /// Panics if `node` was not found in the dependency graph.
  #[allow(dead_code)]
  pub fn get_file_path(&amp;self, node: &amp;FileNode) -&gt; &amp;PathBuf {
    let Some(NodeData::File(path)) = self.graph.get_node_data(node) else {
      panic!(&quot;BUG: node {:?} was not found in the dependency graph&quot;, node);
    };
    path
  }

  /// Gets the task node for `task`, or creates a task node by adding it to the dependency graph.
  pub fn get_or_create_task_node(&amp;mut self, task: &amp;T) -&gt; TaskNode {
    if let Some(node) = self.task_to_node.get(task) {
      *node
    } else {
      let node = self.graph.add_node(NodeData::Task {
        task: task.clone(),
        output: None,
      });
      let node = TaskNode(node);
      self.task_to_node.insert(task.clone(), node);
      node
    }
  }
  /// Gets the task for `node`.
  ///
  /// # Panics
  ///
  /// Panics if `node` was not found in the dependency graph.
  pub fn get_task(&amp;self, node: &amp;TaskNode) -&gt; &amp;T {
    let Some(NodeData::Task { task, .. }) = self.graph.get_node_data(node) else {
      panic!(&quot;BUG: node {:?} was not found in the dependency graph&quot;, node);
    };
    task
  }
}</code></pre>
<p>The <code>get_or_create_file_node</code> method creates file nodes.
When we want to go from a file path (using <code>impl AsRef&lt;Path&gt;</code>) to a <code>FileNode</code>, either we have already added this file path to the graph and want to get the <code>FileNode</code> for it, or we have not yet added it to the graph yet and should add it.
The former is handled by the if branch in <code>get_or_create_file_node</code>, where we just retrieve the <code>FileNode</code> from the <code>file_to_node</code> hash map.
The latter is handled by the else branch where we add the node to the graph with <code>graph.add_node</code> which attaches the <code>NodeData::File</code> data to the node, and then returns a <code>FileNode</code> which we insert into the <code>file_to_node</code> map.</p>
<p>The <code>get_file_path</code> method does the inverse.
We get the attached data given a node, and extract the file path from it.</p>
<p>Note that we are using <code>panic!</code> here to indicate that invalid usage of this method is an <em>unrecoverable programming error</em> that should not occur.
Returning an <code>Option&lt;&amp;PathBuf&gt;</code> makes no sense here, as the caller of this method has no way to recover from this.
Because this is not an end-user-facing API (<code>store</code> module is private), we control all the calls to this method, and thus we are responsible for using these methods in a valid way. 
Therefore, when we call these methods, we should document why it is valid (if this is not immediately obvious), and we need to test whether we really use it in a valid way.</p>
<p>We’re also documenting the panics in a <code># Panics</code> section in the documentation comment, as is common practice in Rust.</p>
<details id="admonition-how-to-trigger-these-panics" class="admonition admonish-question">
<summary class="admonition-title">
<p>How to Trigger these Panics?</p>
<p><a class="admonition-anchor-link" href="#admonition-how-to-trigger-these-panics"></a></p>
</summary>
<div>
<p>Because only <code>Store</code> can create <code>FileNode</code>s and <code>TaskNode</code>s, and all methods only take these values as inputs, these panics will not happen under normal usage.
The only way to trigger these panics (in safe Rust) would be to create two stores, and use the nodes from one store in another.
However, since this is a private module, we just need to make sure that we don’t do that.</p>
<p>There are some tricks to prevent even this kind of invalid usage.
For example, the <a href="https://docs.rs/generativity/latest/generativity/" title="" target="_blank">generativity</a> crate generates unique identifiers based on lifetimes.
However, that is a bit overkill, especially for an internal API, so we won’t be using that.</p>
</div>
</details>
<p>We implement similar methods for task nodes in <code>get_or_create_task_node</code> and <code>get_task</code>.</p>
<h2 id="task-outputs"><a class="header" href="#task-outputs">Task outputs</a></h2>
<p>When we do not need to execute a task because it is consistent, we still need to return its output.
Therefore, we store the task output in <code>NodeData::Task</code> and add methods to query and manipulate task outputs.
Add the following code to <code>pie/src/store.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;T: Task&gt; Store&lt;T, T::Output&gt; {
  /// Checks whether task `node` has an output. Returns `false` if `node` does not have an output.
  ///
  /// # Panics
  ///
  /// Panics if `node` was not found in the dependency graph.
  pub fn task_has_output(&amp;self, node: &amp;TaskNode) -&gt; bool {
    let Some(NodeData::Task { output, .. }) = self.graph.get_node_data(node) else {
      panic!(&quot;BUG: node {:?} was not found in the dependency graph&quot;, node);
    };
    output.is_some()
  }
  /// Gets the output for task `node`.
  ///
  /// # Panics
  ///
  /// Panics if `node` was not found in the dependency graph, or if the task has no output.
  pub fn get_task_output(&amp;self, node: &amp;TaskNode) -&gt; &amp;T::Output {
    let Some(NodeData::Task { output: Some(output), .. }) = self.graph.get_node_data(node) else {
      panic!(&quot;BUG: node {:?} was not found in the dependency graph, or does not have an output&quot;, node);
    };
    output
  }
  /// Sets the output for task `node` to `new_output`.
  ///
  /// # Panics
  ///
  /// Panics if task `node` was not found in the dependency graph.
  pub fn set_task_output(&amp;mut self, node: &amp;TaskNode, new_output: T::Output) {
    let Some(NodeData::Task { output, .. }) = self.graph.get_node_data_mut(node) else {
      panic!(&quot;BUG: node {:?} was not found in the dependency graph&quot;, node);
    };
    output.replace(new_output);
  }
}</code></pre>
<p>The <code>task_has_output</code>, <code>get_task_output</code>, and <code>set_task_output</code> methods manipulate task outputs in <code>NodeData::Task</code>.</p>
<p>Again, we are using panics here to indicate unrecoverable programming errors.</p>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>Now we need methods to query and manipulate dependencies.
The edges in the graph are dependencies between tasks and files.
Tasks can depend on other tasks and files, but there are no dependencies between files.
An edge does not have its own dedicated representation, and is simply represented by two nodes: the source node and the destination node of the edge.</p>
<p>Add the following code to <code>pie/src/store.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;T: Task&gt; Store&lt;T, T::Output&gt; {
  /// Get all dependencies of task `src`.
  ///
  /// # Panics
  ///
  /// Panics in development builds if `src` was not found in the dependency graph.
  pub fn get_dependencies_of_task&lt;'a&gt;(&amp;'a self, src: &amp;'a TaskNode) -&gt; impl Iterator&lt;Item=&amp;'a Dependency&lt;T, T::Output&gt;&gt; + 'a {
    debug_assert!(self.graph.contains_node(src), &quot;BUG: node {:?} was not found in the dependency graph&quot;, src);
    self.graph.get_outgoing_edge_data(src)
  }
  /// Add a file require `dependency` from task `src` to file `dst`.
  ///
  /// # Panics
  ///
  /// Panics if `src` or `dst` were not found in the dependency graph, or if a cycle is created by adding this dependency.
  pub fn add_file_require_dependency(&amp;mut self, src: &amp;TaskNode, dst: &amp;FileNode, dependency: FileDependency) {
    match self.graph.add_edge(src, dst, Dependency::RequireFile(dependency)) {
      Err(pie_graph::Error::NodeMissing) =&gt; panic!(&quot;BUG: source node {:?} or destination node {:?} was not found in the dependency graph&quot;, src, dst),
      Err(pie_graph::Error::CycleDetected) =&gt; panic!(&quot;BUG: cycle detected when adding file dependency from {:?} to {:?}&quot;, src, dst),
      _ =&gt; {},
    }
  }
  /// Adds a task require `dependency` from task `src` to task `dst`.
  ///
  /// # Errors
  ///
  /// Returns `Err(())` if adding this dependency to the graph creates a cycle.
  ///
  /// # Panics
  ///
  /// Panics if `src` or `dst` were not found in the dependency graph.
  pub fn add_task_require_dependency(&amp;mut self, src: &amp;TaskNode, dst: &amp;TaskNode, dependency: TaskDependency&lt;T, T::Output&gt;) -&gt; Result&lt;(), ()&gt; {
    match self.graph.add_edge(src, dst, Dependency::RequireTask(dependency)) {
      Err(pie_graph::Error::NodeMissing) =&gt; panic!(&quot;BUG: source node {:?} or destination node {:?} was not found in the dependency graph&quot;, src, dst),
      Err(pie_graph::Error::CycleDetected) =&gt; Err(()),
      _ =&gt; Ok(()),
    }
  }
}</code></pre>
<p>The <code>get_dependencies_of_task</code> method gets the dependencies (edge data of outgoing edges) of a task, and returns it as an iterator (which is empty if task has no dependencies).
This method needs explicit lifetime annotations due to the signature of <code>get_outgoing_edge_data</code> and the way we return an iterator using <code>impl Iterator&lt;...</code>.
We’re using <code>debug_assert!</code> here to trigger a panic indicating an unrecoverable programming error only in development mode, because this check is too expensive to run in release (optimized) mode.</p>
<p>The <code>add_file_require_dependency</code> method adds a file dependency.
Adding an edge to the graph can result in cycles, which are not allowed in a directed <em>acyclic</em> graph (DAG).
Therefore, <code>graph.add_edge</code> can return an <code>Err</code> indicating that there is a cycle.
In case of files, this cannot happen because files do not have outgoing dependencies, and the API enforces this by never taking a <code>FileNode</code> as a source (<code>src</code>) of an edge.</p>
<p>Tasks can depend on other tasks, so they can create cycles.
In <code>add_task_require_dependency</code>, we propagate the cycle detected error (by returning <code>Err(())</code>) to the caller because the caller has more information to create an error message for the user that made a cyclic task dependency.</p>
<h2 id="resetting-tasks"><a class="header" href="#resetting-tasks">Resetting tasks</a></h2>
<p>Finally, when we determine that a task is inconsistent and needs to be executed, we first need to remove its output and remove its outgoing dependencies, as those will interfere with incrementality when not removed.
We do NOT want to remove incoming dependencies, as that would remove dependencies from other tasks to this task, which breaks incrementality, so we can’t just remove and re-add the task to the graph.
Add the <code>reset_task</code> method that does this to <code>pie/src/store.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;T: Task&gt; Store&lt;T, T::Output&gt; {
  /// Reset task `src`, removing its output and removing all its outgoing dependencies.
  ///
  /// # Panics
  ///
  /// Panics if task `src` was not found in the dependency graph.
  pub fn reset_task(&amp;mut self, src: &amp;TaskNode) {
    if let Some(NodeData::Task { output, .. }) = self.graph.get_node_data_mut(src) {
      *output = None;
    } else {
      panic!(&quot;BUG: node {:?} was not found in the dependency graph&quot;, src);
    }
    self.graph.remove_outgoing_edges_of_node(src);
  }
}</code></pre>
<p>This will reset the task output back to <code>None</code>, and remove all outgoing edges (dependencies).</p>
<h2 id="tests"><a class="header" href="#tests">Tests</a></h2>
<p>Now we’ve implemented everything we need for implementing the top-down context, but first we will write some tests.</p>
<h3 id="testing-file-mapping"><a class="header" href="#testing-file-mapping">Testing file mapping</a></h3>
<p>Add the following code to <code>pie/src/store.rs</code> for testing the file mapping:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use crate::Context;
  use crate::stamp::{FileStamper, OutputStamper};

  use super::*;

  /// Task that returns its owned string. Never executed, just used for testing the store.
  #[derive(Clone, PartialEq, Eq, Hash, Debug)]
  struct StringConstant(String);

  impl StringConstant {
    pub fn new(string: impl Into&lt;String&gt;) -&gt; Self { Self(string.into()) }
  }

  impl Task for StringConstant {
    type Output = String;
    fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, _context: &amp;mut C) -&gt; Self::Output {
      self.0.clone()
    }
  }

  #[test]
  fn test_file_mapping() {
    let mut store: Store&lt;StringConstant, String&gt; = Store::default();

    let path_a = PathBuf::from(&quot;hello.txt&quot;);
    let node_a = store.get_or_create_file_node(&amp;path_a);
    assert_eq!(node_a, store.get_or_create_file_node(&amp;path_a)); // Same node
    assert_eq!(&amp;path_a, store.get_file_path(&amp;node_a)); // Same file path

    let path_b = PathBuf::from(&quot;world.txt&quot;);
    let node_b = store.get_or_create_file_node(&amp;path_b);
    assert_eq!(node_b, store.get_or_create_file_node(&amp;path_b));
    assert_eq!(&amp;path_b, store.get_file_path(&amp;node_b));

    assert_ne!(node_a, node_b); // Different nodes
  }

  #[test]
  #[should_panic]
  fn test_file_mapping_panics() {
    let mut fake_store: Store&lt;StringConstant, String&gt; = Store::default();
    let fake_node = fake_store.get_or_create_file_node(&quot;hello.txt&quot;);
    let store: Store&lt;StringConstant, String&gt; = Store::default();
    store.get_file_path(&amp;fake_node);
  }
}</code></pre>
<p>We create a simple task <code>StringConstant</code> because we need a <code>Task</code> implementation to test <code>Store</code>, as <code>Store</code> is generic over a <code>Task</code> type.
We will never execute it because <code>Store</code> does not execute tasks.</p>
<p>Test <code>test_file_mapping</code> checks whether the file node mapping works as expected:</p>
<ul>
<li><code>get_or_create_file_node</code> calls with the same path should produce the same <code>FileNode</code>.</li>
<li><code>get_or_create_file_node</code> calls with different paths should produce different <code>FileNode</code>s.</li>
</ul>
<p>This works because <code>&quot;hello.txt&quot;</code> and <code>&quot;world.txt&quot;</code> are different paths, thus their <code>Eq</code> and <code>Hash</code> implementations ensure they get separate spots in the <code>file_to_node</code> hash map.</p>
<p>Test <code>test_file_mapping_panics</code> triggers the panic in <code>get_file_path</code> by creating a <code>FileNode</code> with a “fake store”, and then using that rogue file node in another store.
While it is unlikely that we will make this mistake when using <code>Store</code>, it is good to confirm that this panics.</p>
<details id="admonition-rust-help-testing-panics" class="admonition admonish-tip">
<summary class="admonition-title">
<p>Rust Help: Testing Panics</p>
<p><a class="admonition-anchor-link" href="#admonition-rust-help-testing-panics"></a></p>
</summary>
<div>
<p>The <code>#[should_panic]</code> attribute makes the test succeed if it panics, and fail if it does not panic.</p>
</div>
</details>
<h3 id="testing-task-mapping"><a class="header" href="#testing-task-mapping">Testing task mapping</a></h3>
<p>Test the task mapping by inserting the following code into the <code>test</code> module (before the last <code>}</code>):</p>
<pre><code class="language-rust ">  #[test]
  fn test_task_mapping() {
    let mut store = Store::default();

    let task_a = StringConstant::new(&quot;Hello&quot;);
    let node_a = store.get_or_create_task_node(&amp;task_a);
    assert_eq!(node_a, store.get_or_create_task_node(&amp;task_a)); // Same node
    assert_eq!(&amp;task_a, store.get_task(&amp;node_a)); // Same task

    let task_b = StringConstant::new(&quot;World&quot;);
    let node_b = store.get_or_create_task_node(&amp;task_b);
    assert_eq!(node_b, store.get_or_create_task_node(&amp;task_b));
    assert_eq!(&amp;task_b, store.get_task(&amp;node_b));

    assert_ne!(node_a, node_b); // Different nodes
  }

  #[test]
  #[should_panic]
  fn test_task_mapping_panics() {
    let mut fake_store = Store::default();
    let fake_node = fake_store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    let store: Store&lt;StringConstant, String&gt; = Store::default();
    store.get_task(&amp;fake_node);
  }</code></pre>
<p>We test this in the same way as the file mapping.
Again, this works because <code>StringConstant(&quot;Hello&quot;)</code> and <code>StringConstant(&quot;World&quot;)</code> are different due to their derived <code>Eq</code> and <code>Hash</code> implementations, which make them different due to the strings being different. 
Likewise, <code>StringConstant::new(&quot;Hello&quot;)</code> and <code>StringConstant::new(&quot;Hello&quot;)</code> are equal even if they are created with 2 separate invocations of <code>new</code>.</p>
<p>These (in)equalities might seem quite obvious, but it is important to keep in mind because incrementality can only work if we can identify equal tasks at a later time, so that we can check their dependencies and return their cached output when those dependencies are consistent.
Later on we will also see that this is important for soundness of the incremental build system.</p>
<h3 id="testing-task-outputs"><a class="header" href="#testing-task-outputs">Testing task outputs</a></h3>
<p>Test task outputs by inserting the following code into the <code>test</code> module:</p>
<pre><code class="language-rust ">  #[test]
  fn test_task_outputs() {
    let mut store = Store::default();
    let output_a = &quot;Hello&quot;.to_string();
    let task_a = StringConstant::new(&amp;output_a);
    let node_a = store.get_or_create_task_node(&amp;task_a);

    let output_b = &quot;World&quot;.to_string();
    let task_b = StringConstant::new(&amp;output_b);
    let node_b = store.get_or_create_task_node(&amp;task_b);

    // Assert that tasks have no output by default.
    assert!(!store.task_has_output(&amp;node_a));
    assert!(!store.task_has_output(&amp;node_b));

    // Set output for task A, assert that A has that output but B is unchanged.
    store.set_task_output(&amp;node_a, output_a.clone());
    assert!(store.task_has_output(&amp;node_a));
    assert_eq!(store.get_task_output(&amp;node_a), &amp;output_a);
    assert!(!store.task_has_output(&amp;node_b));

    // Set output for task B, assert that B has that output but A is unchanged.
    store.set_task_output(&amp;node_b, output_b.clone());
    assert!(store.task_has_output(&amp;node_a));
    assert_eq!(store.get_task_output(&amp;node_a), &amp;output_a);
    assert!(store.task_has_output(&amp;node_b));
    assert_eq!(store.get_task_output(&amp;node_b), &amp;output_b);
  }

  #[test]
  #[should_panic]
  fn test_task_has_output_panics() {
    let mut fake_store = Store::default();
    let fake_node = fake_store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    let store: Store&lt;StringConstant, String&gt; = Store::default();
    store.task_has_output(&amp;fake_node);
  }

  #[test]
  #[should_panic]
  fn test_get_task_output_panics() {
    let mut store = Store::default();
    let node = store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    store.get_task_output(&amp;node);
  }

  #[test]
  #[should_panic]
  fn test_set_task_output_panics() {
    let mut fake_store = Store::default();
    let fake_node = fake_store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    let mut store: Store&lt;StringConstant, String&gt; = Store::default();
    store.set_task_output(&amp;fake_node, &quot;Hello&quot;.to_string());
  }</code></pre>
<p>Test <code>test_task_outputs</code> ensures that:</p>
<ul>
<li><code>task_has_output</code> only returns true if given task has an output, </li>
<li>and that <code>get_task_output</code> returns the output set by <code>set_task_output</code> for given task.</li>
</ul>
<p>Test <code>test_get_task_output_panics</code> triggers a panic when we call <code>get_task_output</code> for a task that has no output, which is an invalid usage of <code>Store</code> that is more likely to happen than the other panics. </p>
<h3 id="testing-dependencies"><a class="header" href="#testing-dependencies">Testing dependencies</a></h3>
<p>Test dependencies by inserting the following code into the <code>test</code> module:</p>
<pre><code class="language-rust ">  #[test]
  fn test_dependencies() {
    let mut store = Store::default();
    let output_a = &quot;Hello&quot;.to_string();
    let task_a = StringConstant::new(output_a.clone());
    let node_a = store.get_or_create_task_node(&amp;task_a);
    let output_b = &quot;World&quot;.to_string();
    let task_b = StringConstant::new(output_b.clone());
    let node_b = store.get_or_create_task_node(&amp;task_b);
    let path_c = PathBuf::from(&quot;hello.txt&quot;);
    let node_c = store.get_or_create_file_node(&amp;path_c);

    assert_eq!(store.get_dependencies_of_task(&amp;node_a).next(), None);
    assert_eq!(store.get_dependencies_of_task(&amp;node_b).next(), None);

    // Add file dependency from task A to file C.
    let file_dependency_a2c = FileDependency::new(&amp;path_c, FileStamper::Exists).unwrap();
    store.add_file_require_dependency(&amp;node_a, &amp;node_c, file_dependency_a2c.clone());
    let deps_of_a: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;node_a).cloned().collect();
    assert_eq!(deps_of_a.get(0), Some(&amp;Dependency::RequireFile(file_dependency_a2c.clone())));
    assert_eq!(deps_of_a.get(1), None);
    assert_eq!(store.get_dependencies_of_task(&amp;node_b).next(), None);

    // Add task dependency from task B to task A.
    let task_dependency_b2a = TaskDependency::new(task_a.clone(), OutputStamper::Equals, output_a.clone());
    let result = store.add_task_require_dependency(&amp;node_b, &amp;node_a, task_dependency_b2a.clone());
    assert_eq!(result, Ok(()));
    let deps_of_a: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;node_a).cloned().collect();
    assert_eq!(deps_of_a.get(0), Some(&amp;Dependency::RequireFile(file_dependency_a2c.clone())));
    assert_eq!(deps_of_a.get(1), None);
    let deps_of_b: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;node_b).cloned().collect();
    assert_eq!(deps_of_b.get(0), Some(&amp;Dependency::RequireTask(task_dependency_b2a.clone())));
    assert_eq!(deps_of_b.get(1), None);

    // Add file dependency from task B to file C.
    let file_dependency_b2c = FileDependency::new(&amp;path_c, FileStamper::Exists).unwrap();
    store.add_file_require_dependency(&amp;node_b, &amp;node_c, file_dependency_b2c.clone());
    let deps_of_a: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;node_a).cloned().collect();
    assert_eq!(deps_of_a.get(0), Some(&amp;Dependency::RequireFile(file_dependency_a2c.clone())));
    assert_eq!(deps_of_a.get(1), None);
    let deps_of_b: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;node_b).cloned().collect();
    assert_eq!(deps_of_b.get(0), Some(&amp;Dependency::RequireTask(task_dependency_b2a.clone())));
    assert_eq!(deps_of_b.get(1), Some(&amp;Dependency::RequireFile(file_dependency_b2c.clone())));
    assert_eq!(deps_of_b.get(2), None);

    // Add task dependency from task A to task B, creating a cycle.
    let task_dependency_a2b = TaskDependency::new(task_a.clone(), OutputStamper::Equals, output_a.clone());
    let result = store.add_task_require_dependency(&amp;node_a, &amp;node_b, task_dependency_a2b);
    assert_eq!(result, Err(())); // Creates a cycle: error
  }

  #[test]
  #[should_panic]
  fn test_get_dependencies_of_task_panics() {
    let mut fake_store = Store::default();
    let fake_node = fake_store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    let store: Store&lt;StringConstant, String&gt; = Store::default();
    let _ = store.get_dependencies_of_task(&amp;fake_node);
  }

  #[test]
  #[should_panic]
  fn test_add_file_require_dependency_panics() {
    let mut fake_store = Store::default();
    let fake_file_node = fake_store.get_or_create_file_node(&quot;hello.txt&quot;);
    let fake_task_node = fake_store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    let mut store: Store&lt;StringConstant, String&gt; = Store::default();
    let dependency = FileDependency::new(&quot;hello.txt&quot;, FileStamper::Exists).unwrap();
    store.add_file_require_dependency(&amp;fake_task_node, &amp;fake_file_node, dependency);
  }

  #[test]
  #[should_panic]
  fn test_add_task_require_dependency_panics() {
    let mut fake_store = Store::default();
    let output = &quot;Hello&quot;.to_string();
    let task = StringConstant::new(&amp;output);
    let fake_task_node = fake_store.get_or_create_task_node(&amp;task);
    let mut store: Store&lt;StringConstant, String&gt; = Store::default();
    let dependency = TaskDependency::new(task, OutputStamper::Equals, output);
    let _ = store.add_task_require_dependency(&amp;fake_task_node, &amp;fake_task_node, dependency);
  }</code></pre>
<p>The <code>test_dependencies</code> test is a bit more involved because it ensures that:</p>
<ul>
<li><code>get_dependencies_of_task</code> returns the dependencies of given task. If the task has no dependencies, the iterator is empty. We test if an iterator is empty by getting the first element of the iterator with <code>.next()</code> and assert that it is <code>None</code>.</li>
<li><code>get_dependencies_of_task</code> returns the dependencies of given task in the order in which they were added, which will be important for soundness later. The graph library returns dependencies in insertion order.</li>
<li><code>add_task_require_dependency</code> adds a dependency to the correct task.</li>
<li>creating a cycle with <code>add_task_require_dependency</code> results in it returning <code>Err(())</code>.</li>
</ul>
<p>Note that the <code>StringConstant</code> task does not actually create file or task dependencies, but since <code>Store</code> never executes a task, we can pretend that it does in tests. </p>
<h3 id="testing-task-reset"><a class="header" href="#testing-task-reset">Testing task reset</a></h3>
<p>Finally, test task reset by inserting the following code into the <code>test</code> module:</p>
<pre><code class="language-rust ">  #[test]
  fn test_reset() {
    let mut store = Store::default();
    let output_a = &quot;Hello&quot;.to_string();
    let task_a = StringConstant::new(output_a.clone());
    let task_a_node = store.get_or_create_task_node(&amp;task_a);
    let output_b = &quot;World&quot;.to_string();
    let task_b = StringConstant::new(output_b.clone());
    let task_b_node = store.get_or_create_task_node(&amp;task_b);
    let path = PathBuf::from(&quot;hello.txt&quot;);
    let file_node = store.get_or_create_file_node(&amp;path);

    // Set outputs for task A and B.
    store.set_task_output(&amp;task_a_node, output_a.clone());
    assert!(store.task_has_output(&amp;task_a_node));
    assert_eq!(store.get_task_output(&amp;task_a_node), &amp;output_a);
    store.set_task_output(&amp;task_b_node, output_b.clone());
    assert!(store.task_has_output(&amp;task_b_node));
    assert_eq!(store.get_task_output(&amp;task_b_node), &amp;output_b);

    // Add file dependency for task A and B.
    let file_dependency = FileDependency::new(&amp;path, FileStamper::Exists).unwrap();
    store.add_file_require_dependency(&amp;task_a_node, &amp;file_node, file_dependency.clone());
    let deps_of_a: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;task_a_node).cloned().collect();
    assert_eq!(deps_of_a.get(0), Some(&amp;Dependency::RequireFile(file_dependency.clone())));
    assert_eq!(deps_of_a.get(1), None);
    store.add_file_require_dependency(&amp;task_b_node, &amp;file_node, file_dependency.clone());
    let deps_of_b: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;task_b_node).cloned().collect();
    assert_eq!(deps_of_b.get(0), Some(&amp;Dependency::RequireFile(file_dependency.clone())));
    assert_eq!(deps_of_b.get(1), None);

    // Reset only task A.
    store.reset_task(&amp;task_a_node);
    // Assert that task A is reset.
    assert!(!store.task_has_output(&amp;task_a_node));
    assert_eq!(store.get_dependencies_of_task(&amp;task_a_node).next(), None);
    // Assert that task B is unchanged.
    assert!(store.task_has_output(&amp;task_b_node));
    assert_eq!(store.get_task_output(&amp;task_b_node), &amp;output_b);
    let deps_of_b: Vec&lt;_&gt; = store.get_dependencies_of_task(&amp;task_b_node).cloned().collect();
    assert_eq!(deps_of_b.get(0), Some(&amp;Dependency::RequireFile(file_dependency.clone())));
    assert_eq!(deps_of_b.get(1), None);
  }

  #[test]
  #[should_panic]
  fn test_reset_task_panics() {
    let mut fake_store = Store::default();
    let fake_node = fake_store.get_or_create_task_node(&amp;StringConstant::new(&quot;Hello&quot;));
    let mut store: Store&lt;StringConstant, String&gt; = Store::default();
    store.reset_task(&amp;fake_node);
  }</code></pre>
<p>Here, we ensure that a task with an output and dependencies, does not have an output and dependencies after a reset, while leaving another task untouched.</p>
<p>Confirm that the store implementation works with <code>cargo test</code>.</p>
<details id="admonition-download-source-code" class="admonition admonish-example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="../../gen/2_incrementality/4_store/source.zip">download the source files up to this point</a>.</p>
</div>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../2_incrementality/3_dependency/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../2_incrementality/5_context/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../2_incrementality/3_dependency/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../2_incrementality/5_context/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../.././diff2html-ui-base.min.js"></script>


    </div>
    </body>
</html>
