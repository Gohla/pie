<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Stamps - Build your own Programmatic Incremental Build System</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../src/custom.css">
        <link rel="stylesheet" href="../../src/mdbook-admonish.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><div>Introduction</div></li><li class="chapter-item expanded affix "><li class="part-title">Programmability</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Setup</div></li><li class="chapter-item expanded "><a href="../../1_programmability/1_api/index.html"><strong aria-hidden="true">2.</strong> Programmable Build System API</a></li><li class="chapter-item expanded "><a href="../../1_programmability/2_non_incremental/index.html"><strong aria-hidden="true">3.</strong> Non-Incremental Context</a></li><li class="chapter-item expanded affix "><li class="part-title">Incrementality</li><li class="chapter-item expanded "><a href="../../2_incrementality/0_introduction/index.html"><strong aria-hidden="true">4.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/1_require_file/index.html"><strong aria-hidden="true">5.</strong> Requiring Files</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/2_stamp/index.html" class="active"><strong aria-hidden="true">6.</strong> Stamps</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/3_dependency/index.html"><strong aria-hidden="true">7.</strong> Dynamic Dependencies</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/4_store/index.html"><strong aria-hidden="true">8.</strong> Dependency Graph Store</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/5_context/index.html"><strong aria-hidden="true">9.</strong> Incremental Top-Down Context</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Minimality</div></li><li class="chapter-item expanded affix "><li class="part-title">Soundness</li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Prevent Overlapping File Writes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Prevent Hidden Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Prevent Cycles</div></li><li class="chapter-item expanded affix "><li class="part-title">Improvements</li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Serialization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> More Stampers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Configurable Hashing</div></li><li class="chapter-item expanded affix "><li class="part-title">Efficiency</li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> Incremental Bottom-Up Context</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> Observability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> Deferred Tasks</div></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.</strong> Multiple Task Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.</strong> On Static Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.</strong> On Declarativity</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><div>Related Work</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="stamps"><a class="header" href="#stamps">Stamps</a></h1>
<p>To check whether we need to execute a task, we need to check the dependencies of that task to see if any of them are inconsistent.
To make this consistency checking configurable, we will use stamps.
A dependency is inconsistent if after stamping, the new stamp is different from the old stamp.
Therefore, we will implement a <code>FileStamper</code> that stamps files and produces a <code>FileStamp</code>, and an <code>OutputStamper</code> that stamps task outputs and produces an <code>OutputStamp</code>.</p>
<p>Add the <code>stamp</code> module to <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::fs::File;
 use std::hash::Hash;
 use std::io;
 use std::path::Path;

+pub mod stamp;
 pub mod context;
 mod fs;

 /// A unit of computation in a programmatic incremental build system.
 pub trait Task: Clone + Eq + Hash + Debug {
@@ -22,8 +23,9 @@
   /// so that the dependency corresponds to the data that you are reading. Returns:
   /// - `Ok(Some(file))` if a file exists at given `path`, 
   /// - `Ok(None)` if no file exists at given `path` (but a directory could exist at given `path`),
   /// - `Err(e)` if there was an error getting the metadata for given `path`, or if there was an error opening the file. 
   fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt;;
+
   /// Requires given `task`, recording a dependency and selectively executing it. Returns its up-to-date output.
   fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
 }</code></pre>
<p>This module is public as users of the library will construct stampers.</p>
<h2 id="file-stamps"><a class="header" href="#file-stamps">File stamps</a></h2>
<p>Create the <code>pie/src/stamp.rs</code> file and add:</p>
<pre><code class="language-rust ">use std::fmt::Debug;
use std::io;
use std::path::Path;
use std::time::SystemTime;

use crate::fs::metadata;

#[derive(Clone, Eq, PartialEq, Debug)]
pub enum FileStamper {
  Exists,
  Modified,
}

impl FileStamper {
  pub fn stamp(&amp;self, path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;FileStamp, io::Error&gt; {
    match self {
      FileStamper::Exists =&gt; {
        Ok(FileStamp::Exists(path.as_ref().try_exists()?))
      }
      FileStamper::Modified =&gt; {
        let Some(metadata) = metadata(path)? else {
          return Ok(FileStamp::Modified(None));
        };
        Ok(FileStamp::Modified(Some(metadata.modified()?)))
      }
    }
  }
}

#[derive(Clone, Eq, PartialEq, Debug)]
pub enum FileStamp {
  Exists(bool),
  Modified(Option&lt;SystemTime&gt;),
}</code></pre>
<p>We're implementing <code>FileStamper</code> as an enum for simplicity.</p>
<p>A <code>FileStamper</code> has a single method <code>stamp</code> which takes something that can be dereferenced to a path, and produces a <code>FileStamp</code> or an error if creating the stamp failed.
For now, we implement only two kinds of file stampers: <code>Exists</code> and <code>Modified</code>.
The <code>Exists</code> stamper just returns a boolean indicating whether a file exists.
It can be used to create a file dependency where a task behaves differently based on whether a file exists or not.
The <code>Modified</code> stamper returns the last modification date if the file exists, or <code>None</code> if the file does not exist.</p>
<p>We derive <code>Eq</code> for stamps so that we can compare them.
Equal stamps indicate a consistent dependency, unequal indicates inconsistent.
We also derive <code>Eq</code> for stampers, because the stamper of a dependency could change, making the dependency inconsistent.</p>
<h2 id="task-output-stamps"><a class="header" href="#task-output-stamps">Task output stamps</a></h2>
<p>We implement task output stampers in a similar way.
Add to <code>pie/src/stamp.rs</code>:</p>
<pre><code class="language-rust ">#[derive(Clone, Eq, PartialEq, Debug)]
pub enum OutputStamper {
  Inconsequential,
  Equals,
}

impl OutputStamper {
  pub fn stamp&lt;O&gt;(&amp;self, output: O) -&gt; OutputStamp&lt;O&gt; {
    match self {
      OutputStamper::Inconsequential =&gt; OutputStamp::Inconsequential,
      OutputStamper::Equals =&gt; OutputStamp::Equals(output),
    }
  }
}

#[derive(Clone, Eq, PartialEq, Debug)]
pub enum OutputStamp&lt;O&gt; {
  Inconsequential,
  Equals(O),
}

impl&lt;O&gt; OutputStamp&lt;O&gt; {
  pub fn as_ref(&amp;self) -&gt; OutputStamp&lt;&amp;O&gt; {
    match self {
      OutputStamp::Inconsequential =&gt; OutputStamp::Inconsequential,
      OutputStamp::Equals(o) =&gt; OutputStamp::Equals(o),
    }
  }
}</code></pre>
<p>The <code>Inconsequential</code> stamper simply ignores the output and always returns the same stamp (thus is always equal).
It can be used to create a task dependency where we are interested in some side effect of a task, but don't care about its output.
The <code>Equals</code> stamper simply wraps the output of a task, so the stamp is equal when the output is equal.</p>
<p>Output stamps are generic over the task output type <code>O</code>.</p>
<details id="admonition-trait-bounds-and-derive-macros" class="admonition info">
<summary class="admonition-title">
<p>Trait bounds and derive macros</p>
<p><a class="admonition-anchor-link" href="#admonition-trait-bounds-and-derive-macros"></a></p>
</summary>
<div>
<p>Because <code>O</code> is used in the enum, the <code>derive</code> attributes on <code>OutputStamp</code> create bounds over <code>O</code>.
Thus, <code>OutputStamp</code> is only <code>Clone</code> when <code>O</code> is <code>Clone</code>, <code>OutputStamp</code> is only <code>Clone</code> when <code>O</code> is <code>Clone</code>, and so forth.
Because we declared <code>Task::Output</code> with bound <code>Clone + Eq + Debug</code>, we can be sure that <code>OutputStamp</code> is always <code>Clone</code>, <code>Eq</code>, and <code>Debug</code>.</p>
</div>
</details>
<details id="admonition-user-defined-stamps" class="admonition info">
<summary class="admonition-title">
<p>User-defined stamps</p>
<p><a class="admonition-anchor-link" href="#admonition-user-defined-stamps"></a></p>
</summary>
<div>
<p><code>FileStamper</code> and <code>OutputStamper</code> could also be a trait which would allow users of the library to implement their own stampers.
For simplicity, we do not explore that option in this tutorial.
If you feel adventurous, you could try to implement this after you've finished the tutorial.
Do note that this introduces a lot of extra generics and trait bounds everywhere, which can be a bit cumbersome.</p>
</div>
</details>
<h2 id="tests"><a class="header" href="#tests">Tests</a></h2>
<p>Finally, we write some tests.
Add to <code>pie/src/stamp.rs</code>:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use std::fs;

  use dev_shared::create_temp_file;

  use super::*;

  #[test]
  fn test_exists_file_stamper() {
    let stamper = FileStamper::Exists;
    let temp_file = create_temp_file();
    let stamp = stamper.stamp(&amp;temp_file).expect(&quot;failed to stamp&quot;);
    assert_eq!(stamp, stamper.stamp(&amp;temp_file).expect(&quot;failed to stamp&quot;));

    fs::remove_file(&amp;temp_file).expect(&quot;failed to delete temporary file&quot;);
    assert_ne!(stamp, stamper.stamp(&amp;temp_file).expect(&quot;failed to stamp&quot;));
  }

  #[test]
  fn test_modified_file_stamper() {
    let stamper = FileStamper::Modified;
    let temp_file = create_temp_file();
    let stamp = stamper.stamp(&amp;temp_file).expect(&quot;failed to stamp&quot;);
    assert_eq!(stamp, stamper.stamp(&amp;temp_file).expect(&quot;failed to stamp&quot;));

    fs::write(&amp;temp_file, format!(&quot;{:?}&quot;, stamp)).expect(&quot;failed to write to temporary file&quot;);
    assert_ne!(stamp, stamper.stamp(&amp;temp_file).expect(&quot;failed to stamp&quot;), &quot;modified stamp is equal after modifying file&quot;);

    fs::remove_file(&amp;temp_file).expect(&quot;failed to delete temporary file&quot;);
    assert_ne!(stamp, stamper.stamp(&amp;temp_file).expect(&quot;failed to stamp&quot;), &quot;modified stamp is equal after removing file&quot;);
  }

  #[test]
  fn test_inconsequential_output_stamper() {
    let stamper = OutputStamper::Inconsequential;
    let stamp = stamper.stamp(&amp;1);
    assert_eq!(stamp, stamper.stamp(&amp;1));
    assert_eq!(stamp, stamper.stamp(&amp;2));
  }

  #[test]
  fn test_equals_output_stamper() {
    let stamper = OutputStamper::Equals;
    let stamp = stamper.stamp(&amp;1);
    assert_eq!(stamp, stamper.stamp(&amp;1));
    assert_ne!(stamp, stamper.stamp(&amp;2));
  }
}</code></pre>
<p>We test file stamps by creating a stamp, changing the file, creating a new stamp, and then compare the stamps.
We test task output stamps by just passing a different output value to the <code>stamp</code> function, and then compare the stamps.</p>
<p>Run <code>cargo test</code> to confirm the stamp implementation.</p>
<h2 id="stamps-in-context"><a class="header" href="#stamps-in-context">Stamps in Context</a></h2>
<p>We now have a module dedicated to stamps.
However, stampers are constructed by users of the library that author tasks, and they need to pass in these stampers when creating dependencies.
Therefore, we need to update the <code>Context</code> trait to allow passing in these stampers.</p>
<p>Change <code>Context</code> in <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::fmt::Debug;
 use std::fs::File;
 use std::hash::Hash;
 use std::io;
 use std::path::Path;

+use stamp::{FileStamper, OutputStamper};
+
 pub mod stamp;
 pub mod context;
 mod fs;

 /// A unit of computation in a programmatic incremental build system.
 pub trait Task: Clone + Eq + Hash + Debug {
   /// Type of output this task returns when executed.
   type Output: Clone + Eq + Debug;
   /// Execute the task, using `context` to specify dynamic dependencies, returning `Self::Output`.
   fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
 }

 /// Programmatic incremental build context, enabling tasks to create dynamic dependencies that context implementations 
 /// use for incremental execution.
 pub trait Context&lt;T: Task&gt; {
-  /// Requires file at given `path`, recording a dependency to it. Call this method *just before reading from the file*, 
-  /// so that the dependency corresponds to the data that you are reading. Returns:
+  /// Requires file at given `path`, recording a dependency to it (using the default require file stamper). Call this 
+  /// method *just before reading from the file*, so that the dependency corresponds to the data that you are reading. 
+  /// Returns:
   /// - `Ok(Some(file))` if a file exists at given `path`, 
   /// - `Ok(None)` if no file exists at given `path` (but a directory could exist at given `path`),
-  /// - `Err(e)` if there was an error getting the metadata for given `path`, or if there was an error opening the file. 
-  fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt;;
+  /// - `Err(e)` if there was an error getting the metadata for given `path`, if there was an error opening the file, or 
+  ///   if there was an error stamping the file.
+  fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
+    self.require_file_with_stamper(path, self.default_require_file_stamper())
+  }
+  /// Requires file at given `path`, recording a dependency to it (using given `stamper`). Call this method 
+  /// *just before reading from the file*, so that the dependency corresponds to the data that you are reading. Returns:
+  /// - `Ok(Some(file))` if a file exists at given `path`, 
+  /// - `Ok(None)` if no file exists at given `path` (but a directory could exist at given `path`),
+  /// - `Err(e)` if there was an error getting the metadata for given `path`, if there was an error opening the file, or 
+  ///   if there was an error stamping the file.
+  fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt;;
+  /// Returns the default require file stamper.
+  fn default_require_file_stamper(&amp;self) -&gt; FileStamper { FileStamper::Modified }

   /// Requires given `task`, recording a dependency and selectively executing it. Returns its up-to-date output.
   fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
 }</code></pre>
<p>We add the <code>require_file_with_stamper</code> method which allow passing in a stamper.
We add a default implementation for <code>require_file</code> that passes in a default stamper.
The default is provided by <code>default_require_file_stamper</code> which can be overridden by context implementations.</p>
<p>Now apply the same to tasks, changing <code>Context</code> again in <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff">   ///   if there was an error stamping the file.
   fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt;;
   /// Returns the default require file stamper.
   fn default_require_file_stamper(&amp;self) -&gt; FileStamper { FileStamper::Modified }

-  /// Requires given `task`, recording a dependency and selectively executing it. Returns its up-to-date output.
-  fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
+  /// Requires given `task`, recording a dependency (using the default output stamper) and selectively executing it. 
+  /// Returns its up-to-date output.
+  fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output {
+    self.require_task_with_stamper(task, self.default_output_stamper())
+  }
+  /// Requires given `task`, recording a dependency (using given `stamper`) and selectively executing it. Returns its
+  /// up-to-date output.
+  fn require_task_with_stamper(&amp;mut self, task: &amp;T, stamper: OutputStamper) -&gt; T::Output;
+  /// Returns the default output stamper.
+  fn default_output_stamper(&amp;self) -&gt; OutputStamper { OutputStamper::Equals }
 }</code></pre>
<p>Update <code>NonIncrementalContext</code> in <code>src/context/non_incremental.rs</code> to implement the new methods:</p>
<pre><code class="language-rust customdiff"> use std::io;
 use std::path::Path;

 use crate::{Context, Task};
 use crate::fs::open_if_file;
+use crate::stamp::{FileStamper, OutputStamper};

 pub struct NonIncrementalContext;

 impl&lt;T: Task&gt; Context&lt;T&gt; for NonIncrementalContext {
-  fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
+  fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, _stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
     let file = open_if_file(&amp;path)?;
     Ok(file)
   }

-  fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output {
+  fn require_task_with_stamper(&amp;mut self, task: &amp;T, _stamper: OutputStamper) -&gt; T::Output {
     task.execute(self)
   }
 }</code></pre>
<p>We just ignore the stampers in <code>NonIncrementalContext</code>, as they are only needed for incrementality.</p>
<p>Run <code>cargo test</code> to confirm everything still works.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../2_incrementality/1_require_file/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../2_incrementality/3_dependency/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../2_incrementality/1_require_file/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../2_incrementality/3_dependency/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../src/diff.js"></script>


    </div>
    </body>
</html>
