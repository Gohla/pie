<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Requiring Files - Build your own Programmatic Incremental Build System</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../src/custom.css">
        <link rel="stylesheet" href="../../src/mdbook-admonish.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Introduction</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Programmability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../1_programmability/0_setup/index.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../../1_programmability/1_api/index.html"><strong aria-hidden="true">2.2.</strong> Programmable Build System API</a></li><li class="chapter-item expanded "><a href="../../1_programmability/2_non_incremental/index.html"><strong aria-hidden="true">2.3.</strong> Non-Incremental Context</a></li></ol></li><li class="chapter-item expanded "><a href="../../2_incrementality/index.html"><strong aria-hidden="true">3.</strong> Incrementality</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../2_incrementality/1_require_file/index.html" class="active"><strong aria-hidden="true">3.1.</strong> Requiring Files</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/2_stamp/index.html"><strong aria-hidden="true">3.2.</strong> Stamps</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/3_dependency/index.html"><strong aria-hidden="true">3.3.</strong> Dynamic Dependencies</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/4_store/index.html"><strong aria-hidden="true">3.4.</strong> Dependency Graph Store</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/5_context/index.html"><strong aria-hidden="true">3.5.</strong> Incremental Top-Down Context</a></li></ol></li><li class="chapter-item expanded "><a href="../../3_min_sound/index.html"><strong aria-hidden="true">4.</strong> Minimality and Soundness</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Minimality with Sessions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Tracking Build Events</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Prevent Overlapping File Writes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> Prevent Hidden Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> Prevent Cycles</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Improvements</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Serialization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> More Stampers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Configurable Hashing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Efficiency</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Incremental Bottom-Up Context</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Observability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Deferred Tasks</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Multiple Task Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> On Static Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> On Declarativity</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Related Work</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="requiring-files"><a class="header" href="#requiring-files">Requiring Files</a></h1>
<p>Since build systems frequently interact with files, and changes to files can affect tasks, we need to keep track of file dependencies.
Therefore, we will extend the <code>Context</code> API with methods to <em>require files</em>, enabling tasks to specify dynamic dependencies to files.</p>
<p>Add a method to the <code>Context</code> trait in <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::fmt::Debug;
+use std::fs::File;
 use std::hash::Hash;
+use std::io;
+use std::path::Path;

 pub mod context;

 /// A unit of computation in a programmatic incremental build system.
 pub trait Task: Clone + Eq + Hash + Debug {
   /// Type of output this task returns when executed.
   type Output: Clone + Eq + Debug;
   /// Execute the task, using `context` to specify dynamic dependencies, returning `Self::Output`.
   fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
 }

 /// Programmatic incremental build context, enabling tasks to create dynamic dependencies that context implementations 
 /// use for incremental execution.
 pub trait Context&lt;T: Task&gt; {
+  /// Requires file at given `path`, recording a dependency to it. Call this method *just before reading from the file*, 
+  /// so that the dependency corresponds to the data that you are reading. Returns:
+  /// - `Ok(Some(file))` if a file exists at given `path`, 
+  /// - `Ok(None)` if no file exists at given `path` (but a directory could exist at given `path`),
+  /// - `Err(e)` if there was an error getting the metadata for given `path`, or if there was an error opening the file. 
+  fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt;;
+
   /// Requires given `task`, recording a dependency and selectively executing it. Returns its up-to-date output.
   fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
 }</code></pre>
<p><code>require_file</code> is similar to requiring a task, but instead takes a <code>path</code> to a file or directory on the filesystem as input.
We use <code>AsRef&lt;Path&gt;</code> as the type for the path, so that we can pass anything in that can dereference to a path.
For example, <code>str</code> has an <code>AsRef&lt;Path&gt;</code> implementation, so we can just use <code>&quot;test.txt&quot;</code> as a path.</p>
<p>As an output, we return <code>Result&lt;Option&lt;File&gt;, io::Error&gt;</code>, with <code>File</code> being a handle to an open file.
The reason for this complicated type is:</p>
<ul>
<li>An incremental context will want to read the metadata (such as the last modified date) of the file, or create a hash over the file, to be able to detect changes. Because getting metadata or reading the file can fail, and we want to propagate this error, we return a <code>Result</code> with <code>io::Error</code> as the error type.</li>
<li>Tasks can create a dependency to a file that does not exist, and the existence of that file affects the task. For example, a task that prints true or false based on if a file exists. If the file does not exist (or it is a directory), we cannot open it, so we cannot return a <code>File</code>, hence we use <code>Option&lt;File&gt;</code> to return <code>None</code>.</li>
<li>Otherwise, we return <code>Ok(Some(file))</code> so that the task can read the opened file.</li>
</ul>
<details id="admonition-rust-help" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="#admonition-rust-help"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html" title="" target="_blank">Recoverable error handling</a> in Rust is done with the <code>Result&lt;T, E&gt;</code> type, which can either be <code>Ok(t)</code> or <code>Err(e)</code>.
In contrast to many languages which use exceptions, throwing, and exception handling; Rust treats recoverable errors just as regular values.</p>
<p>Similarly, <a href="https://doc.rust-lang.org/std/option/" title="" target="_blank">optional values</a> in Rust are defined using the <code>Option&lt;T&gt;</code> type, which can either be <code>Some(t)</code> or <code>None</code>.</p>
<p>Rust has many traits for converting values or references into others, which provides a lot of convenience in what would otherwise require a lot of explicit conversions.
<a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html" title="" target="_blank">
<code>AsRef&lt;T&gt;</code></a> is such a conversion trait, that can convert itself into <code>&amp;T</code>. 
Here, we use <code>AsRef&lt;Path&gt;</code> as a generic with a trait bound to support many different kinds of values to the <code>path</code> argument in <code>require_file</code>.
For example, we can call <code>context.require_file(&quot;test.txt&quot;)</code> because <code>str</code>, which is the type of string constants, <a href="https://doc.rust-lang.org/src/std/path.rs.html#3136-3141" title="" target="_blank">implements <code>AsRef&lt;Path&gt;</code></a>.
You can also see this as a kind of method overloading, without having to provide concrete overloads for all supported types.</p>
</div>
</details>
<p>Now we need to implement this method for <code>NonIncrementalContext</code>.
However, because we will be performing similar file system operations in the incremental context as well, we will create some utility functions for this first.</p>
<p>Add the <code>fs</code> module to <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::hash::Hash;
 use std::io;
 use std::path::Path;

 pub mod context;
+mod fs;

 /// A unit of computation in a programmatic incremental build system.
 pub trait Task: Clone + Eq + Hash + Debug {
   /// Type of output this task returns when executed.
   type Output: Clone + Eq + Debug;
@@ -21,9 +22,8 @@
   /// so that the dependency corresponds to the data that you are reading. Returns:
   /// - `Ok(Some(file))` if a file exists at given `path`, 
   /// - `Ok(None)` if no file exists at given `path` (but a directory could exist at given `path`),
   /// - `Err(e)` if there was an error getting the metadata for given `path`, or if there was an error opening the file. 
   fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt;;
-
   /// Requires given `task`, recording a dependency and selectively executing it. Returns its up-to-date output.
   fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
 }</code></pre>
<p>Create file <code>pie/src/fs.rs</code> with:</p>
<pre><code class="language-rust ">use std::{fs, io};
use std::fs::{File, Metadata};
use std::path::Path;

/// Gets the metadata for given `path`, returning:
/// - `Ok(Some(metadata))` if a file or directory exists at given path,
/// - `Ok(None)` if no file or directory exists at given path,
/// - `Err(e)` if there was an error getting the metadata for given path.
pub fn metadata(path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Option&lt;Metadata&gt;, io::Error&gt; {
  match fs::metadata(path) {
    Err(e) if e.kind() == io::ErrorKind::NotFound =&gt; Ok(None),
    Err(e) =&gt; Err(e),
    Ok(m) =&gt; Ok(Some(m))
  }
}

/// Attempt to open file at given `path`, returning:
/// - `Ok(Some(file))` if the file exists at given path, 
/// - `Ok(None)` if no file exists at given path (but a directory could exist at given path),
/// - `Err(e)` if there was an error getting the metadata for given path, or if there was an error opening the file.
///
/// This function is necessary due to Windows returning an error when attempting to open a directory.
pub fn open_if_file(path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
  let file = match metadata(&amp;path)? {
    Some(metadata) if metadata.is_file() =&gt; Some(File::open(&amp;path)?),
    _ =&gt; None,
  };
  Ok(file)
}</code></pre>
<p>The <code>metadata</code> function gets the filesystem metadata given a path, and <code>open_if_file</code> opens the file for given path.
The reason for these functions is that the standard library function <code>std::fs::metadata</code> treats non-existent files as an error, whereas we don't want to treat it as an error and just return <code>None</code>.
Furthermore, <code>open_if_file</code> works around an issue where opening a directory on Windows (and possibly other operating systems) is an error, where we want to treat it as <code>None</code> again.
The documentation comments explain the exact behaviour.</p>
<details id="admonition-rust-help-1" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="#admonition-rust-help-1"></a></p>
</summary>
<div>
<p>The <code>?</code> operator makes it easy to <a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator" title="" target="_blank">propgate errors</a>.
Because errors are just values in Rust, to propgate an error, you'd normally have to match each result and manually propagate the error.
The <code>r?</code> operator applied to a <code>Result</code> <code>r</code> does this for you, it basically desugars to something like <code>match r { Err(e) =&gt; return Err(e), _ =&gt; {} }</code>.</p>
<p>Comments with three forward slashes <code>///</code> are <a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments" title="" target="_blank">documentation comments</a> that document the function/struct/enum/trait/etc. they are applied to.</p>
</div>
</details>
<p>We will write some tests to confirm the behaviour, but for that we need utilities to create temporary files and directories.
Furthermore, we will be writing more unit tests, integration tests, and even benchmarks in this tutorial, so we will set up these utilities in such a way that they are reachable by all these use cases.
The only way to do that in Rust right now, is to create a separate crate and have the <code>pie</code> crate depend on it.</p>
<p>And yes, we went from adding file dependencies, to creating file system utilities, to testing those file system utilities, to creating testing utilities, and now to making a crate for those testing utilities.
Sorry about that ðŸ˜…, we will start unwinding this stack soon!</p>
<p>Next to the <code>pie</code> directory, create a directory named <code>dev_shared</code>.
Create the <code>dev_shared/Cargo.toml</code> file with the following contents:</p>
<pre><code class="language-toml ">[package]
name = &quot;dev_shared&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
tempfile = &quot;3&quot;
</code></pre>
<p>We've added the <code>tempfile</code> dependency here already, which is a crate that creates and automatically cleans up temporary files and directories.</p>
<details id="admonition-rust-help-2" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="#admonition-rust-help-2"></a></p>
</summary>
<div>
<p>We use other libraries (crates) by <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html" title="" target="_blank">specifying dependencies</a>.
Because basically every Rust library adheres to <a href="https://semver.org/" title="" target="_blank">semantic versioning</a>, we can use <code>&quot;3&quot;</code> as a version requirement which indicates that we will use the most up-to-date <code>3.x.x</code> version.</p>
</div>
</details>
<p>Create the main library file <code>dev_shared/src/lib.rs</code>, with functions for creating temporary files and directories:</p>
<pre><code class="language-rust ">use std::io;

use tempfile::{NamedTempFile, TempDir};

/// Creates a new temporary file that gets cleaned up when dropped.
pub fn create_temp_file() -&gt; Result&lt;NamedTempFile, io::Error&gt; { NamedTempFile::new() }

/// Creates a new temporary directory that gets cleaned up when dropped.
pub fn create_temp_dir() -&gt; Result&lt;TempDir, io::Error&gt; { TempDir::new() }</code></pre>
<p>Your directory structure should now look like this:</p>
<pre><code>â”œâ”€â”€ pie
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”œâ”€â”€ target
â”‚   â”œâ”€â”€ Cargo.lock
â”‚   â””â”€â”€ src
â”‚       â”œâ”€â”€ context
â”‚       â”‚   â”œâ”€â”€ non_incremental.rs
â”‚       â”‚   â””â”€â”€ mod.rs
â”‚       â”œâ”€â”€ lib.rs
â”‚       â””â”€â”€ fs.rs
â””â”€â”€ dev_shared
    â”œâ”€â”€ Cargo.toml
    â””â”€â”€ src
        â””â”€â”€ lib.rs
</code></pre>
<p>To access these utility functions in the <code>pie</code> crate, add a dependency to <code>dev_shared</code> in <code>pie/Cargo.toml</code> along with another create that will help testing:</p>
<pre><code class="language-toml customdiff "> [package]
 name = &quot;pie&quot;
 version = &quot;0.1.0&quot;
 edition = &quot;2021&quot;
+
+[dev-dependencies]
+dev_shared = { path = &quot;../dev_shared&quot; }
+assert_matches = &quot;1&quot;
</code></pre>
<p>We've also added the <a href="https://crates.io/crates/assert_matches" title="" target="_blank">assert_matches</a> crate, which is a handy library for asserting that a value matches a pattern.
Note that these dependencies are added under <code>dev-dependencies</code>, indicating that these dependencies are only available when running tests, benchmarks, and examples.
Therefore, users of our library will not depend on these crates, which is good, because temporary file management and assertions are not necessary to users of the library.</p>
<p>Back to testing our filesystem utilities.
Add the following tests to <code>pie/src/fs.rs</code>:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use std::fs::remove_file;
  use std::io;

  use assert_matches::assert_matches;

  use dev_shared::{create_temp_dir, create_temp_file};

  use super::*;

  #[test]
  fn test_metadata_ok() -&gt; Result&lt;(), io::Error&gt; {
    let temp_file = create_temp_file()?;
    let metadata = metadata(temp_file)?;
    assert_matches!(metadata, Some(metadata) =&gt; {
      assert!(metadata.is_file());  
    });
    Ok(())
  }

  #[test]
  fn test_metadata_none() -&gt; Result&lt;(), io::Error&gt; {
    let temp_file = create_temp_file()?;
    remove_file(&amp;temp_file)?;
    let metadata = metadata(&amp;temp_file)?;
    assert!(metadata.is_none());
    Ok(())
  }

  #[test]
  fn test_open_if_file() -&gt; Result&lt;(), io::Error&gt; {
    let temp_file = create_temp_file()?;
    let file = open_if_file(&amp;temp_file)?;
    assert!(file.is_some());
    Ok(())
  }

  #[test]
  fn test_open_if_file_non_existent() -&gt; Result&lt;(), io::Error&gt; {
    let temp_file = create_temp_file()?;
    remove_file(&amp;temp_file)?;
    let file = open_if_file(&amp;temp_file)?;
    assert!(file.is_none());
    Ok(())
  }

  #[test]
  fn test_open_if_file_on_directory() -&gt; Result&lt;(), io::Error&gt; {
    let temp_dir = create_temp_dir()?;
    let file = open_if_file(temp_dir)?;
    assert!(file.is_none());
    Ok(())
  }
}</code></pre>
<p>We test whether the functions conform to the specified behaviour.
Unfortunately, we can't easily test when <code>metadata</code> and <code>open_if_file</code> should return an error, because we cannot disable read permissions on files via the Rust standard library.</p>
<p>We use our <code>create_temp_file</code> and <code>create_temp_dir</code> utility functions to create temporary files and directories.
The <code>tempfile</code> library takes care of deleting temporary files when they go out of scope (at the end of the test).</p>
<p>We use <code>assert_matches!</code> to assert that <code>metadata</code> is <code>Some(metadata)</code>, binding <code>metadata</code> in the <code> =&gt; { ... }</code> block in which we assert that the metadata describes a file.
We will use this macro more in future integration tests.</p>
<details id="admonition-rust-help-3" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="#admonition-rust-help-3"></a></p>
</summary>
<div>
<p>Tests can <a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html#using-resultt-e-in-tests" title="" target="_blank">return <code>Result</code></a>.
When a test returns an <code>Err</code>, the test fails.
This allows us to write more concise tests using error propagation.</p>
</div>
</details>
<p>Now we are done unwinding our stack and have filesystem and testing utilities.
Make the non-incremental context compatible by changing <code>pie/src/context/non_incremental.rs</code>:</p>
<pre><code class="language-rust customdiff">+use std::fs::File;
+use std::io;
+use std::path::Path;
+
 use crate::{Context, Task};
+use crate::fs::open_if_file;

 pub struct NonIncrementalContext;

 impl&lt;T: Task&gt; Context&lt;T&gt; for NonIncrementalContext {
+  fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
+    open_if_file(&amp;path)
+  }
+
   fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output {
     task.execute(self)
   }
 }</code></pre>
<p>Since the non-incremental context does not track anything, we only try to open the file and return it, matching the contract in the documentation comment of the <code>Context::require_file</code> trait method.</p>
<p>Confirm everything works with <code>cargo test</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../2_incrementality/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../2_incrementality/2_stamp/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../2_incrementality/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../2_incrementality/2_stamp/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../src/diff.js"></script>


    </div>
    </body>
</html>
