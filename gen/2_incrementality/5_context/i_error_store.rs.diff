--- original
+++ modified
@@ -25,10 +25,11 @@
   pub fn get_dependency_check_errors(&self) -> impl Iterator<Item=&io::Error> {
     self.dependency_check_errors.iter()
   }
 }

+
 impl<T: Task> Context<T> for TopDownContext<T, T::Output> {
   fn require_file_with_stamper<P: AsRef<Path>>(&mut self, path: P, stamper: FileStamper) -> Result<Option<File>, io::Error> {
     let Some(current_executing_task_node) = &self.current_executing_task else {
       return fs::open_if_file(path); // No current executing task, so no dependency needs to be made.
     };
@@ -78,10 +79,14 @@
     //         through `self.store` while we create a mutable borrow of `self`, which is not allowed.
     let dependencies: Vec<_> = self.store.get_dependencies_of_task(node).cloned().collect();
     for dependency in dependencies {
       match dependency.is_inconsistent(self) {
         Ok(Some(_)) => return true,
+        Err(e) => { // Error while checking: store error and assume inconsistent
+          self.dependency_check_errors.push(e);
+          return true;
+        }
         _ => {} // Consistent: continue checking
       }
     }
     // Task has no dependencies or all dependencies are consistent. Should only execute if it has no output, meaning
     // that it has never been executed before.
