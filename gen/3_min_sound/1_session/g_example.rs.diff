--- pie/examples/incremental.rs
+++ pie/examples/incremental.rs
@@ -1,11 +1,8 @@
-#![allow(unused_imports, unused_variables)]
-
 use std::io::{self, Read};
 use std::path::{Path, PathBuf};
 
 use dev_shared::{create_temp_dir, write_until_modified};
-use pie::{Context, Task};
-use pie::context::top_down::TopDownContext;
+use pie::{Context, Pie, Task};
 use pie::stamp::FileStamper;
 
 /// Task that reads a string from a file.
@@ -38,24 +35,24 @@
   let input_file = temp_dir.path().join("input.txt");
   write_until_modified(&input_file, "Hi")?;
 
-  let mut context = TopDownContext::new();
+  let mut pie = Pie::default();
   let read_task = ReadStringFromFile::new(&input_file, FileStamper::Modified);
 
   println!("A) New task: expect `read_task` to execute");
   // `read_task` is new, meaning that we have no cached output for it, thus it must be executed.
-  let output = context.require_task(&read_task)?;
+  let output = pie.new_session().require(&read_task)?;
   assert_eq!(&output, "Hi");
 
   println!("\nB) Reuse: expect no execution");
   // `read_task` is not new and its file dependency is still consistent. It is consistent because the modified time of
   // `input_file` has not changed, thus the modified stamp is equal.
-  let output = context.require_task(&read_task)?;
+  let output = pie.new_session().require(&read_task)?;
   assert_eq!(&output, "Hi");
 
   write_until_modified(&input_file, "Hello")?;
   println!("\nC) Inconsistent file dependency: expect `read_task` to execute");
   // The file dependency of `read_task` is inconsistent due to the changed modified time of `input_file`.
-  let output = context.require_task(&read_task)?;
+  let output = pie.new_session().require(&read_task)?;
   assert_eq!(&output, "Hello");
 
   let input_file_b = temp_dir.path().join("input_b.txt");
@@ -66,9 +63,10 @@
   // Task `read_task`, `read_task_b_modified` and `read_task_b_exists` are different, due to their `Eq` implementation
   // determining that their paths and stampers are different. Therefore, `read_task_b_modified` and `read_task_b_exists`
   // are new tasks, and must be executed.
-  let output = context.require_task(&read_task_b_modified)?;
+  let mut session = pie.new_session();
+  let output = session.require(&read_task_b_modified)?;
   assert_eq!(&output, "Test");
-  let output = context.require_task(&read_task_b_exists)?;
+  let output = session.require(&read_task_b_exists)?;
   assert_eq!(&output, "Test");
 
   write_until_modified(&input_file_b, "Test Test")?;
@@ -80,9 +78,10 @@
   //
   // Note that using an `Exists` stamper for this task does not make a lot of sense, since it will only read the file
   // on first execute and when it is recreated. But this is just to demonstrate different stampers.
-  let output = context.require_task(&read_task_b_modified)?;
+  let mut session = pie.new_session();
+  let output = session.require(&read_task_b_modified)?;
   assert_eq!(&output, "Test Test");
-  let output = context.require_task(&read_task_b_exists)?;
+  let output = session.require(&read_task_b_exists)?;
   assert_eq!(&output, "Test");
 
   Ok(())
