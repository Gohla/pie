--- original
+++ modified
@@ -1,20 +1,21 @@
 use std::fmt::Debug;
 use std::fs::File;
 use std::hash::Hash;
 use std::io;
 use std::path::Path;

 use stamp::{FileStamper, OutputStamper};

 use crate::context::top_down::TopDownContext;
 use crate::store::{Store, TaskNode};
+use crate::tracker::{NoopTracker, Tracker};

 pub mod stamp;
 pub mod tracker;
 mod context;
 mod fs;
 mod dependency;
 mod store;

 /// A unit of computation in a programmatic incremental build system.
 pub trait Task: Clone + Eq + Hash + Debug {
@@ -53,53 +54,68 @@
     self.require_task_with_stamper(task, self.default_output_stamper())
   }
   /// Requires given `task`, recording a dependency (using given `stamper`) and selectively executing it. Returns its
   /// up-to-date output.
   fn require_task_with_stamper(&mut self, task: &T, stamper: OutputStamper) -> T::Output;
   /// Returns the default output stamper.
   fn default_output_stamper(&self) -> OutputStamper { OutputStamper::Equals }
 }

 /// Main entry point into PIE, a sound and incremental programmatic build system.
-pub struct Pie<T, O> {
+pub struct Pie<T, O, A = NoopTracker> {
   store: Store<T, O>,
+  tracker: A,
 }

 impl<T: Task> Default for Pie<T, T::Output> {
-  fn default() -> Self { Self { store: Store::default() } }
+  fn default() -> Self { Self::with_tracker(NoopTracker) }
 }

-impl<T: Task> Pie<T, T::Output> {
+impl<T: Task, A: Tracker<T>> Pie<T, T::Output, A> {
+  /// Creates a new [`Pie`] instance with given `tracker`.
+  pub fn with_tracker(tracker: A) -> Self { Self { store: Store::default(), tracker } }
+  
   /// Creates a new build session. Only one session may be active at once, enforced via mutable (exclusive) borrow.
-  pub fn new_session(&mut self) -> Session<T, T::Output> { Session::new(self) }
+  pub fn new_session(&mut self) -> Session<T, T::Output, A> { Session::new(self) }
   /// Runs `f` inside a new build session.
-  pub fn run_in_session<R>(&mut self, f: impl FnOnce(Session<T, T::Output>) -> R) -> R {
+  pub fn run_in_session<R>(&mut self, f: impl FnOnce(Session<T, T::Output, A>) -> R) -> R {
     let session = self.new_session();
     f(session)
   }
+
+  /// Gets the [`Tracker`] instance.
+  pub fn tracker(&self) -> &A { &self.tracker }
+  /// Gets the mutable [`Tracker`] instance.
+  pub fn tracker_mut(&mut self) -> &mut A { &mut self.tracker }
 }

 /// A session in which builds are executed.
-pub struct Session<'p, T, O> {
+pub struct Session<'p, T, O, A> {
   store: &'p mut Store<T, O>,
+  tracker: &'p mut A,
   current_executing_task: Option<TaskNode>,
   dependency_check_errors: Vec<io::Error>,
 }

-impl<'p, T: Task> Session<'p, T, T::Output> {
-  fn new(pie: &'p mut Pie<T, T::Output>) -> Self {
+impl<'p, T: Task, A: Tracker<T>> Session<'p, T, T::Output, A> {
+  fn new(pie: &'p mut Pie<T, T::Output, A>) -> Self {
     Self {
       store: &mut pie.store,
+      tracker: &mut pie.tracker,
       current_executing_task: None,
       dependency_check_errors: Vec::default(),
     }
   }

   /// Requires `task`, returning its up-to-date output.
   pub fn require(&mut self, task: &T) -> T::Output {
     self.current_executing_task = None;
     TopDownContext::new(self).require_initial(task)
   }

+  /// Gets the [`Tracker`] instance.
+  pub fn tracker(&self) -> &A { &self.tracker }
+  /// Gets the mutable [`Tracker`] instance.
+  pub fn tracker_mut(&mut self) -> &mut A { &mut self.tracker }
   /// Gets all errors produced during dependency checks.
   pub fn dependency_check_errors(&self) -> impl Iterator<Item=&io::Error> { self.dependency_check_errors.iter() }
 }
