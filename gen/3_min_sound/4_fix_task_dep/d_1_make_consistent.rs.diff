--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -38,9 +38,28 @@
 
   fn require_task_with_stamper(&mut self, task: &T, stamper: OutputStamper) -> T::Output {
     self.session.tracker.require_task_start(task, &stamper);
+
     let node = self.session.store.get_or_create_task_node(task);
+    let (output, was_executed) = self.make_task_consistent(task, node);
+
+    let dependency = TaskDependency::new(task.clone(), stamper, output.clone());
+    self.session.tracker.require_task_end(&dependency, &output, was_executed);
+
+    // Create task require dependency if a task is currently executing (i.e., we are not requiring the initial task).
+    if let Some(current_executing_task_node) = &self.session.current_executing_task {
+      if self.session.store.add_task_require_dependency(current_executing_task_node, &node, dependency).is_err() {
+        let current_executing_task = self.session.store.get_task(current_executing_task_node);
+        panic!("Cyclic task dependency; current executing task '{:?}' is requiring task '{:?}' which was already required", current_executing_task, task);
+      }
+    }
 
-    // Get required task output by executing it if needed, or by getting the output from the store if not needed.
+    output
+  }
+}
+
+impl<'p, 's, T: Task, A: Tracker<T>> TopDownContext<'p, 's, T, T::Output, A> {
+  // Get required task output by executing it if needed, or by getting the output from the store if not needed.
+  fn make_task_consistent(&mut self, task: &T, node: TaskNode) -> (T::Output, bool) {
     let already_consistent = self.session.consistent.contains(&node);
     let should_execute = !already_consistent && self.should_execute_task(&node);
     let output = if should_execute {
@@ -57,24 +76,11 @@
       // executed and `should_execute_task` ensures that the task has an output.
       self.session.store.get_task_output(&node).clone()
     };
-
-    let dependency = TaskDependency::new(task.clone(), stamper, output.clone());
-    self.session.tracker.require_task_end(&dependency, &output, should_execute);
-
-    // Create task require dependency if a task is currently executing (i.e., we are not requiring the initial task).
-    if let Some(current_executing_task_node) = &self.session.current_executing_task {
-      if self.session.store.add_task_require_dependency(current_executing_task_node, &node, dependency).is_err() {
-        let current_executing_task = self.session.store.get_task(current_executing_task_node);
-        panic!("Cyclic task dependency; current executing task '{:?}' is requiring task '{:?}' which was already required", current_executing_task, task);
-      }
-    }
 
     self.session.consistent.insert(node);
-    output
+    (output, should_execute)
   }
-}
 
-impl<'p, 's, T: Task, A: Tracker<T>> TopDownContext<'p, 's, T, T::Output, A> {
   /// Checks whether given task should be executed, returning `true` if it should be executed. A task should be executed
   /// if any of its dependencies are inconsistent, or when it has no output.
   fn should_execute_task(&mut self, node: &TaskNode) -> bool {
