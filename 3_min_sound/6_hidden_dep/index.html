<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Prevent Hidden Dependencies - Build your own Programmatic Incremental Build System</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../.././diff2html.min.css">
        <link rel="stylesheet" href="../.././mdbook-admonish.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../0_intro/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../0_intro/1_setup/index.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li></ol></li><li class="chapter-item expanded "><a href="../../1_programmability/index.html"><strong aria-hidden="true">2.</strong> Programmability</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../1_programmability/1_api/index.html"><strong aria-hidden="true">2.1.</strong> Programmable Build System API</a></li><li class="chapter-item expanded "><a href="../../1_programmability/2_non_incremental/index.html"><strong aria-hidden="true">2.2.</strong> Non-Incremental Context</a></li></ol></li><li class="chapter-item expanded "><a href="../../2_incrementality/index.html"><strong aria-hidden="true">3.</strong> Incrementality</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../2_incrementality/1_require_file/index.html"><strong aria-hidden="true">3.1.</strong> Requiring Files</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/2_stamp/index.html"><strong aria-hidden="true">3.2.</strong> Stamps</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/3_dependency/index.html"><strong aria-hidden="true">3.3.</strong> Dynamic Dependencies</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/4_store/index.html"><strong aria-hidden="true">3.4.</strong> Dependency Graph Store</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/5_context/index.html"><strong aria-hidden="true">3.5.</strong> Incremental Top-Down Context</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/6_example/index.html"><strong aria-hidden="true">3.6.</strong> Incrementality Example</a></li></ol></li><li class="chapter-item expanded "><a href="../../3_min_sound/index.html"><strong aria-hidden="true">4.</strong> Testing Incrementality & Soundness</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../3_min_sound/1_session/index.html"><strong aria-hidden="true">4.1.</strong> Minimality with Sessions</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/2_tracker/index.html"><strong aria-hidden="true">4.2.</strong> Tracking Build Events</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/3_test/index.html"><strong aria-hidden="true">4.3.</strong> Integration Testing</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/4_fix_task_dep/index.html"><strong aria-hidden="true">4.4.</strong> Fix Superfluous Task Dependency</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/5_overlap/index.html"><strong aria-hidden="true">4.5.</strong> Prevent Overlapping File Writes</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/6_hidden_dep/index.html" class="active"><strong aria-hidden="true">4.6.</strong> Prevent Hidden Dependencies</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/7_cycle/index.html"><strong aria-hidden="true">4.7.</strong> Prevent Cycles</a></li></ol></li><li class="chapter-item expanded "><a href="../../4_next/index.html"><strong aria-hidden="true">5.</strong> What's Next?</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
<!-- CHANGE: removed all but light and ayu theme, and renamed ayu to dark -->                          
<!--                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>-->
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/edit/master/tutorial/src/3_min_sound/6_hidden_dep/index.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="prevent-hidden-dependencies"><a class="header" href="#prevent-hidden-dependencies">Prevent Hidden Dependencies</a></h1>
<p>There is one more file-based inconsistency in our incremental build system that we need to prevent: hidden dependencies.
A hidden dependency occurs when a task R requires file F that is provided by another task P, without task R requiring task P.</p>
<p>Hidden dependencies are problematic for the same reason as overlapping provided files: we can require tasks in a specific order that causes an inconsistency.
For example, we could first require task R, which reads file F, and then we could require task P, which writes to and changes file F in such a way that R’s dependency to it becomes inconsistent.
This is incorrect, because we made task R consistent while its file dependency to F is inconsistent, so R should be inconsistent!</p>
<p>To prevent this problem, task R needs to require task P.
Then, when task R is required, task P will always first be made consistent, first writing its changes to file F, before task R reads file F.</p>
<p>This is all a bit abstract so let’s do the same as the previous section: write tests to show the problem.
In this section, we will:</p>
<ol>
<li>Create tests to showcase the hidden dependency problem.</li>
<li>Prevent hidden dependencies by checking for them at runtime, fixing the issue.</li>
<li>Improve and add additional tests.</li>
</ol>
<h2 id="test-to-showcase-the-issue"><a class="header" href="#test-to-showcase-the-issue">Test to showcase the issue</a></h2>
<p>Add the following test to <code>pie/tests/top_down.rs</code>:</p>
<pre><code class="language-rust ">// Hidden dependency tests

#[test]
fn test_hidden_dependency() -&gt; Result&lt;(), io::Error&gt; {
  let mut pie = test_pie();
  let temp_dir = create_temp_dir()?;

  let file = temp_dir.path().join(&quot;in_out.txt&quot;);
  write(&amp;file, &quot;Hello, World!&quot;)?;

  let read = ReadFile(file.clone(), FileStamper::Modified);

  let input_file = temp_dir.path().join(&quot;in.txt&quot;);
  write(&amp;input_file, &quot;Hi there&quot;)?;
  let read_for_write = ReadFile(input_file.clone(), FileStamper::Modified);
  let write = WriteFile(Box::new(read_for_write.clone()), file.clone(), FileStamper::Modified);

  // Require `write` and `read`, assert they are executed because they are new.
  pie.require_then_assert_one_execute(&amp;write)?;
  assert_eq!(read_to_string(&amp;file)?, &quot;Hi there&quot;);
  let output = pie.require_then_assert_one_execute(&amp;read)?;
  assert_eq!(output.as_str(), &quot;Hi there&quot;);

  // Although there is a hidden dependency here (`read` doesn't require `write`), we happened to have required `write`
  // and `read` in the correct order, so there is no inconsistency yet. The output of `read` is `&quot;Hi there&quot;` which is
  // correct.

  Ok(())
}</code></pre>
<p>In this test, task <code>read</code> reads from <code>file</code>, and task <code>write</code> writes to <code>file</code>.
Task <code>write</code> gets the string to write through <code>read_for_write</code> which reads it from <code>input_file</code>.
There is a hidden dependency here, because <code>read</code> reads <code>file</code>, which is provided by <code>write</code>, without <code>read</code> actually requiring <code>write</code>.
We can say that the dependency from <code>read</code> to <code>write</code> is hidden by <code>file</code>.</p>
<p>We first require <code>write</code>, assert that it is executed, and assert that <code>file</code> now contains <code>&quot;Hi there&quot;</code> which is what <code>write</code> wrote into <code>file</code>.
Then we require <code>read</code> and assert that it is executed and returns <code>&quot;Hi there&quot;</code>.
Even though there is a hidden dependency, we have not observed an inconsistency yet, because we’ve required the tasks in the correct order.</p>
<p>Now extend this test in <code>pie/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_0"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -27,5 +27,23 @@
   // and ${"`"}read${"`"} in the correct order, so there is no inconsistency yet. The output of ${"`"}read${"`"} is ${"`"}"Hi there"${"`"} which is
   // correct.
 
+  // Change ${"`"}input_file${"`"} such that ${"`"}read_for_write${"`"} becomes inconsistent, making ${"`"}write${"`"} inconsistent.
+  write_until_modified(&input_file, "Hello There!")?;
+
+  // Require ${"`"}read${"`"} and assert that it has not been executed, because all its dependencies are still consistent.
+  let output = pie.require_then_assert_no_execute(&read)?;
+  assert_eq!(output.as_str(), "Hi there");
+  // Require ${"`"}write${"`"} and assert that it is executed, because its dependency to ${"`"}read_for_write${"`"} is inconsistent.
+  pie.require_then_assert_one_execute(&write)?;
+  assert_eq!(read_to_string(&file)?, "Hello There!");
+
+  // This is incorrect, as ${"`"}read${"`"} was deemed consistent with output ${"`"}"Hi there"${"`"}, even though ${"`"}write${"`"} was inconsistent
+  // and needed to first write ${"`"}"Hello There!"${"`"} to ${"`"}file${"`"}. This inconsistency occurs because the dependency from ${"`"}read${"`"}
+  // to ${"`"}write${"`"} was hidden by ${"`"}file${"`"}! This inconsistent behaviour is undesirable.
+
+  // Note: this is asserting the current behaviour, not the desired behaviour, which is to disallow this!
+  // Note: we required the tasks in separate sessions (${"`"}require_then_assert_one_execute${"`"} starts a new session), but
+  //       requiring these tasks in a single session will have the same outcome.
+
   Ok(())
 }
`;
    let target = document.getElementById('diff2html_0');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We change <code>input_file</code> such that <code>read_for_write</code> becomes inconsistent, making <code>write</code> inconsistent.
Basically, <code>write</code> now wants to write <code>&quot;Hello There!&quot;</code> to <code>file</code>.</p>
<p>We then require the tasks in the opposite order, first <code>read</code> and then <code>write</code>, but the result is incorrect.
Requiring <code>read</code> still returns <code>&quot;Hi there&quot;</code>, even though <code>write</code> is inconsistent and needs to first write <code>&quot;Hello There!&quot;</code> to <code>file</code> before <code>read</code> reads it!
Requiring <code>read</code> should really return <code>&quot;Hello There!&quot;</code>.</p>
<p>Similarly to overlapping provided files, this inconsistent behaviour is caused by the ability to require individual tasks, and our build system (incrementally and correctly) making only the required task (and its dependencies) consistent.
This inconsistent behaviour is undesirable, and should be prevented.</p>
<p>Before continuing, confirm the test succeeds with <code>cargo test</code>.
We will modify this test to assert the desired behaviour later.</p>
<h2 id="prevent-hidden-dependencies-1"><a class="header" href="#prevent-hidden-dependencies-1">Prevent hidden dependencies</a></h2>
<p>There are two ways in which a hidden dependency can be manifested:</p>
<ol>
<li>When a task R requires file F: if F is provided by task P, and R does not require P, there is a hidden dependency.</li>
<li>When a task P provides file F: if F is required by tasks R*, and one or more tasks from R* does not require P, there is a hidden dependency.</li>
</ol>
<p>We already saw an example of the first case in the test.
The second case occurs when a task first requires a file that is not yet provided by a task, but then later on a task provides it.
In both cases, the hidden dependency can result in tasks reading from a file that will later be written to (provided) by another task, which leaves those reading tasks in an inconsistent state.</p>
<p>We will need to check for both cases.
The first case can be checked in the <code>require_file_with_stamper</code> method, and the second one in <code>provide_file_with_stamper</code>.</p>
<p>Both checks need some way to query whether a task depends on another task.
We could query whether task R depends on P directly, and that would work fine.
However, sometimes task R will not require P directly, but require it through some other task(s) that require P eventually.
This is still correct, because P <em>will</em> be made consistent <em>before</em> R.
Therefore, we need to add a method to <code>Store</code> to query whether a task directly or indirectly (also called transitively) depends on another.</p>
<p>Furthermore, in the second check we need to get all tasks that require a file, for which we will also need a <code>Store</code> method.</p>
<h3 id="add-store-methods"><a class="header" href="#add-store-methods">Add <code>Store</code> methods</a></h3>
<p>Let’s add those methods to <code>Store</code>.
Modify <code>pie/src/store.rs</code>:</p>
<div class="diff2html" id="diff2html_1"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/store.rs
+++ pie/src/store.rs
@@ -167,6 +167,31 @@
       }
     ).next()
   }
+  /// Get all task nodes for tasks that require file ${"`"}dst${"`"}.
+  ///
+  /// # Panics
+  ///
+  /// Panics in development builds if ${"`"}dst${"`"} was not found in the dependency graph.
+  pub fn get_tasks_requiring_file<'a>(&'a self, dst: &'a FileNode) -> impl Iterator<Item=TaskNode> + '_ {
+    debug_assert!(self.graph.contains_node(dst), "BUG: node {:?} was not found in the dependency graph", dst);
+    self.graph.get_incoming_edges(dst).filter_map(|(n, d)|
+      if matches!(d, Dependency::RequireFile(_)) {
+        Some(TaskNode(*n))
+      } else {
+        None
+      }
+    )
+  }
+  /// Checks whether there is a direct or indirect (transitive) dependency from task ${"`"}src${"`"} to task ${"`"}dst${"`"}.
+  ///
+  /// # Panics
+  ///
+  /// Panics in development builds if ${"`"}src${"`"} or ${"`"}dst${"`"} were not found in the dependency graph.
+  pub fn contains_transitive_task_dependency(&self, src: &TaskNode, dst: &TaskNode) -> bool {
+    debug_assert!(self.graph.contains_node(src), "BUG: src node {:?} was not found in the dependency graph", src);
+    debug_assert!(self.graph.contains_node(dst), "BUG: dst node {:?} was not found in the dependency graph", dst);
+    self.graph.contains_transitive_edge(src, dst)
+  }
 
   /// Add a file require ${"`"}dependency${"`"} from task ${"`"}src${"`"} to file ${"`"}dst${"`"}.
   ///
`;
    let target = document.getElementById('diff2html_1');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We add the <code>get_tasks_requiring_file</code> method that does what it says on the tin.
It is almost identical to <code>get_task_providing_file</code>, but returns an <code>Iterator</code> because multiple tasks can require a single file.
We also have to make the lifetimes more explicit, to explain to Rust that the lifetimes on <code>self</code> and <code>dst</code> are not related to the implicit <code>'_</code> lifetime of the iterator.
This works because we are not borrowing anything in the iterator, because our <code>filter_map</code> copies nodes with <code>TaskNode(*n)</code>.</p>
<p>The <code>contains_transitive_task_dependency</code> method also does what it says.
Luckily, the graph library takes care of this query.</p>
<p>Per usual, add some tests for these methods in <code>pie/src/store.rs</code>:</p>
<div class="diff2html" id="diff2html_2"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/store.rs
+++ pie/src/store.rs
@@ -399,6 +399,11 @@
     assert_eq!(store.get_dependencies_of_task(&node_a).next(), None);
     assert_eq!(store.get_dependencies_of_task(&node_b).next(), None);
     assert_eq!(store.get_task_providing_file(&node_c), None);
+    assert_eq!(store.get_tasks_requiring_file(&node_c).next(), None);
+    assert!(!store.contains_transitive_task_dependency(&node_a, &node_a));
+    assert!(!store.contains_transitive_task_dependency(&node_b, &node_b));
+    assert!(!store.contains_transitive_task_dependency(&node_a, &node_b));
+    assert!(!store.contains_transitive_task_dependency(&node_b, &node_a));
 
     // Add file dependency from task A to file C.
     let file_dependency_a2c = FileDependency::new(&path_c, FileStamper::Exists).unwrap();
@@ -408,6 +413,11 @@
     assert_eq!(deps_of_a.get(1), None);
     assert_eq!(store.get_dependencies_of_task(&node_b).next(), None);
     assert_eq!(store.get_task_providing_file(&node_c), None);
+    let reqs_to_c: Vec<_> = store.get_tasks_requiring_file(&node_c).collect();
+    assert_eq!(reqs_to_c.get(0), Some(&node_a));
+    assert_eq!(reqs_to_c.get(1), None);
+    assert!(!store.contains_transitive_task_dependency(&node_a, &node_b));
+    assert!(!store.contains_transitive_task_dependency(&node_b, &node_a));
 
     // Add task dependency from task B to task A.
     let task_dependency_b2a = TaskDependency::new(task_a.clone(), OutputStamper::Equals, output_a.clone());
@@ -420,6 +430,11 @@
     assert_eq!(deps_of_b.get(0), Some(&Dependency::RequireTask(task_dependency_b2a.clone())));
     assert_eq!(deps_of_b.get(1), None);
     assert_eq!(store.get_task_providing_file(&node_c), None);
+    let reqs_to_c: Vec<_> = store.get_tasks_requiring_file(&node_c).collect();
+    assert_eq!(reqs_to_c.get(0), Some(&node_a));
+    assert_eq!(reqs_to_c.get(1), None);
+    assert!(!store.contains_transitive_task_dependency(&node_a, &node_b));
+    assert!(store.contains_transitive_task_dependency(&node_b, &node_a));
 
     // Add file dependency from task B to file C.
     let file_dependency_b2c = FileDependency::new(&path_c, FileStamper::Exists).unwrap();
@@ -432,6 +447,11 @@
     assert_eq!(deps_of_b.get(1), Some(&Dependency::ProvideFile(file_dependency_b2c.clone())));
     assert_eq!(deps_of_b.get(2), None);
     assert_eq!(store.get_task_providing_file(&node_c), Some(node_b));
+    let reqs_to_c: Vec<_> = store.get_tasks_requiring_file(&node_c).collect();
+    assert_eq!(reqs_to_c.get(0), Some(&node_a));
+    assert_eq!(reqs_to_c.get(1), None);
+    assert!(!store.contains_transitive_task_dependency(&node_a, &node_b));
+    assert!(store.contains_transitive_task_dependency(&node_b, &node_a));
 
     // Add task dependency from task A to task B, creating a cycle.
     let task_dependency_a2b = TaskDependency::new(task_a.clone(), OutputStamper::Equals, output_a.clone());
@@ -459,6 +479,24 @@
 
   #[test]
   #[should_panic]
+  fn get_tasks_requiring_file_panics() {
+    let mut fake_store: Store<StringConstant, String> = Store::default();
+    let fake_node = fake_store.get_or_create_file_node("hello.txt");
+    let store: Store<StringConstant, String> = Store::default();
+    let _ = store.get_tasks_requiring_file(&fake_node);
+  }
+
+  #[test]
+  #[should_panic]
+  fn test_contains_transitive_task_dependency_panics() {
+    let mut fake_store = Store::default();
+    let fake_node = fake_store.get_or_create_task_node(&StringConstant::new("Hello"));
+    let store: Store<StringConstant, String> = Store::default();
+    let _ = store.contains_transitive_task_dependency(&fake_node, &fake_node);
+  }
+
+  #[test]
+  #[should_panic]
   fn test_add_file_require_dependency_panics() {
     let mut fake_store = Store::default();
     let fake_file_node = fake_store.get_or_create_file_node("hello.txt");
`;
    let target = document.getElementById('diff2html_2');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We assert that the new methods return what is expected in <code>test_dependencies</code>, and add tests confirming panics when used on non-existent nodes.</p>
<h3 id="add-checks-to-topdowncontext"><a class="header" href="#add-checks-to-topdowncontext">Add checks to <code>TopDownContext</code></a></h3>
<p>Now we can add hidden dependency checks to <code>TopDownContext</code>.
Add the checks to <code>pie/src/context/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_3"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -30,6 +30,16 @@
     };
     let path = path.as_ref();
     let node = self.session.store.get_or_create_file_node(path);
+
+    if let Some(providing_task_node) = self.session.store.get_task_providing_file(&node) {
+      if !self.session.store.contains_transitive_task_dependency(current_executing_task_node, &providing_task_node) {
+        let current_executing_task = self.session.store.get_task(current_executing_task_node);
+        let providing_task = self.session.store.get_task(&providing_task_node);
+        panic!("Hidden dependency; file '{}' is required by the current executing task '{:?}' without a dependency to \
+                providing task: {:?}", path.display(), current_executing_task, providing_task);
+      }
+    }
+
     let (dependency, file) = FileDependency::new_with_file(path, stamper)?;
     self.session.tracker.require_file_end(&dependency);
     self.session.store.add_file_require_dependency(current_executing_task_node, &node, dependency);
@@ -50,6 +60,15 @@
               previously provided by task: {:?}", path.display(), current_executing_task, previous_providing_task);
     }
 
+    for requiring_task_node in self.session.store.get_tasks_requiring_file(&node) {
+      if !self.session.store.contains_transitive_task_dependency(&requiring_task_node, current_executing_task_node) {
+        let current_executing_task = self.session.store.get_task(current_executing_task_node);
+        let requiring_task = self.session.store.get_task(&requiring_task_node);
+        panic!("Hidden dependency; file '{}' is provided by the current executing task '{:?}' without a dependency \
+                from requiring task '{:?}' to the current executing task", path.display(), current_executing_task, requiring_task);
+      }
+    }
+
     let dependency = FileDependency::new(path, stamper)?;
     self.session.tracker.provide_file_end(&dependency);
     self.session.store.add_file_provide_dependency(current_executing_task_node, &node, dependency);
`;
    let target = document.getElementById('diff2html_3');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We add the first check to <code>require_file_with_stamper</code>, where the current executing task is requiring a file.
We check whether a task provides the file being required, and (inside the <code>if let</code>) check that the current executing task requires the providing task.
If not, we panic with a hidden dependency error.</p>
<p>Similarly, in <code>provide_file_with_stamper</code>, we perform the second check.
Because multiple task can require a file, we perform the check for every requiring task with a <code>for</code> loop.
If any requiring task fails the check, there is a hidden dependency, and panic with an error.</p>
<p>That’s it!
Test your changes with <code>cargo test</code>, which should make the <code>test_hidden_dependency</code> test fail as expected!</p>
<div id="admonition-expected-test-failure" class="admonition admonish-failure">
<div class="admonition-title">
<p>Expected Test Failure</p>
<p><a class="admonition-anchor-link" href="#admonition-expected-test-failure"></a></p>
</div>
<div>
<p>Test <code>test_hidden_dependency</code> will fail as expected, which we will now fix!</p>
</div>
</div>
<h2 id="fixing-and-improving-the-tests"><a class="header" href="#fixing-and-improving-the-tests">Fixing and improving the tests</a></h2>
<p>Like with the overlapping provided file test, we’ll heavily simplify our test to only test that it panics.
Modify <code>pie/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_4"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -3,47 +3,22 @@
 // Hidden dependency tests
 
 #[test]
-fn test_hidden_dependency() -> Result<(), io::Error> {
-  let mut pie = test_pie();
-  let temp_dir = create_temp_dir()?;
-
-  let file = temp_dir.path().join("in_out.txt");
-  write(&file, "Hello, World!")?;
-
-  let read = ReadFile(file.clone(), FileStamper::Modified);
-
-  let input_file = temp_dir.path().join("in.txt");
-  write(&input_file, "Hi there")?;
-  let read_for_write = ReadFile(input_file.clone(), FileStamper::Modified);
-  let write = WriteFile(Box::new(read_for_write.clone()), file.clone(), FileStamper::Modified);
-
-  // Require ${"`"}write${"`"} and ${"`"}read${"`"}, assert they are executed because they are new.
-  pie.require_then_assert_one_execute(&write)?;
-  assert_eq!(read_to_string(&file)?, "Hi there");
-  let output = pie.require_then_assert_one_execute(&read)?;
-  assert_eq!(output.as_str(), "Hi there");
-
-  // Although there is a hidden dependency here (${"`"}read${"`"} doesn't require ${"`"}write${"`"}), we happened to have required ${"`"}write${"`"}
-  // and ${"`"}read${"`"} in the correct order, so there is no inconsistency yet. The output of ${"`"}read${"`"} is ${"`"}"Hi there"${"`"} which is
-  // correct.
-
-  // Change ${"`"}input_file${"`"} such that ${"`"}read_for_write${"`"} becomes inconsistent, making ${"`"}write${"`"} inconsistent.
-  write_until_modified(&input_file, "Hello There!")?;
+#[should_panic(expected = "Hidden dependency")]
+fn test_require_hidden_dependency_panics() {
+  fn run() -> Result<(), io::Error> {
+    let mut pie = test_pie();
+    let temp_dir = create_temp_dir()?;
 
-  // Require ${"`"}read${"`"} and assert that it has not been executed, because all its dependencies are still consistent.
-  let output = pie.require_then_assert_no_execute(&read)?;
-  assert_eq!(output.as_str(), "Hi there");
-  // Require ${"`"}write${"`"} and assert that it is executed, because its dependency to ${"`"}read_for_write${"`"} is inconsistent.
-  pie.require_then_assert_one_execute(&write)?;
-  assert_eq!(read_to_string(&file)?, "Hello There!");
+    let file = temp_dir.path().join("in_out.txt");
+    write(&file, "Hello, World!")?;
 
-  // This is incorrect, as ${"`"}read${"`"} was deemed consistent with output ${"`"}"Hi there"${"`"}, even though ${"`"}write${"`"} was inconsistent
-  // and needed to first write ${"`"}"Hello There!"${"`"} to ${"`"}file${"`"}. This inconsistency occurs because the dependency from ${"`"}read${"`"}
-  // to ${"`"}write${"`"} was hidden by ${"`"}file${"`"}! This inconsistent behaviour is undesirable.
+    let read = ReadFile(file.clone(), FileStamper::Modified);
+    let write = WriteFile(Box::new(Return("Hi there")), file.clone(), FileStamper::Modified);
 
-  // Note: this is asserting the current behaviour, not the desired behaviour, which is to disallow this!
-  // Note: we required the tasks in separate sessions (${"`"}require_then_assert_one_execute${"`"} starts a new session), but
-  //       requiring these tasks in a single session will have the same outcome.
+    pie.require_then_assert_one_execute(&write)?;
+    pie.require_then_assert_one_execute(&read)?;
 
-  Ok(())
+    Ok(())
+  }
+  run().unwrap();
 }
`;
    let target = document.getElementById('diff2html_4');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We check for a <code>&quot;Hidden dependency&quot;</code> panic, rename the test, wrap it in a nested <code>run</code> function to support <code>Result</code>, and simplify it.
The second call to <code>require_then_assert_one_execute</code> will panic due to a hidden dependency: <code>read</code> requires <code>file</code> without a task dependency to <code>write</code>.</p>
<p>Now add a test for the second case to <code>pie/tests/top_down.rs</code>:</p>
<pre><code class="language-rust ">#[test]
#[should_panic(expected = &quot;Hidden dependency&quot;)]
fn test_provide_hidden_dependency_panics() {
  fn run() -&gt; Result&lt;(), io::Error&gt; {
    let mut pie = test_pie();
    let temp_dir = create_temp_dir()?;

    let file = temp_dir.path().join(&quot;in_out.txt&quot;);
    write(&amp;file, &quot;Hello, World!&quot;)?;

    let read = ReadFile(file.clone(), FileStamper::Modified);
    let write = WriteFile(Box::new(Return(&quot;Hi there&quot;)), file.clone(), FileStamper::Modified);

    pie.require_then_assert_one_execute(&amp;read)?;
    pie.require_then_assert_one_execute(&amp;write)?;

    Ok(())
  }
  run().unwrap();
}</code></pre>
<p>Here, the second call to <code>require_then_assert_one_execute</code> will panic due to a hidden dependency: <code>write</code> provides <code>file</code> which is required by <code>read</code> which does not have a task dependency to <code>write</code>.</p>
<p>Confirm both tests succeed with <code>cargo test</code>.
All tests are succeeding again 🎉.</p>
<div id="admonition-fixed-tests" class="admonition admonish-success">
<div class="admonition-title">
<p>Fixed Tests</p>
<p><a class="admonition-anchor-link" href="#admonition-fixed-tests"></a></p>
</div>
<div>
<p>Test <code>test_require_hidden_dependency_panics</code> (was: <code>test_hidden_dependency</code>) should now succeed.</p>
</div>
</div>
<p>We should also write some tests that show that non-hidden (visible?) dependencies do actually work.
However, our <code>ReadFile</code> task is not capable of making task dependencies at all, so we will need to fix that first (and refactor all uses of <code>ReadFile</code> unfortunately).</p>
<p>Modify <code>pie/tests/common/mod.rs</code>:</p>
<div class="diff2html" id="diff2html_5"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/common/mod.rs
+++ pie/tests/common/mod.rs
@@ -63,7 +63,7 @@
 #[derive(Clone, Eq, PartialEq, Hash, Debug)]
 pub enum TestTask {
   Return(&'static str),
-  ReadFile(PathBuf, FileStamper),
+  ReadFile(PathBuf, FileStamper, Option<Box<TestTask>>),
   WriteFile(Box<TestTask>, PathBuf, FileStamper),
   ToLower(Box<TestTask>),
   ToUpper(Box<TestTask>),
@@ -74,7 +74,10 @@
   fn execute<C: Context<Self>>(&self, context: &mut C) -> Self::Output {
     match self {
       TestTask::Return(string) => Ok(string.to_string().into()),
-      TestTask::ReadFile(path, stamper) => {
+      TestTask::ReadFile(path, stamper, origin) => {
+        if let Some(origin) = origin {
+          context.require_task(origin)?;
+        }
         let mut string = String::new();
         if let Some(mut file) = context.require_file_with_stamper(path, *stamper).map_err(|e| e.kind())? {
           file.read_to_string(&mut string).map_err(|e| e.kind())?;
`;
    let target = document.getElementById('diff2html_5');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We add an optional task argument to <code>ReadFile</code>, which we require when the read task is executed.
We call this optional task argument an <code>origin</code>, a shorthand for “originating task”.
This is a pattern that appears in programmatic build systems, where a task requires certain files, but those files could be provided by another task.
Instead of <code>Option&lt;Box&lt;TestTask&gt;&gt;</code>, we can also use <code>Vec&lt;TestTask&gt;</code> if multiple originating tasks are required.</p>
<div id="admonition-explicit-dependencies" class="admonition admonish-info">
<div class="admonition-title">
<p>Explicit Dependencies</p>
<p><a class="admonition-anchor-link" href="#admonition-explicit-dependencies"></a></p>
</div>
<div>
<p>Due to disallowing hidden dependencies, we need to make these originating tasks explicit, which unfortunately requires some additional work when authoring tasks.
However, the reward is that the build system will incrementalize running our tasks for free, and also ensure that the incremental build is correct.
Also, I think it is not such a bad idea to be explicit about these dependencies, because these really are dependencies that exist in the build!</p>
</div>
</div>
<details id="admonition-returning-paths" class="admonition admonish-tip">
<summary class="admonition-title">
<p>Returning Paths</p>
<p><a class="admonition-anchor-link" href="#admonition-returning-paths"></a></p>
</summary>
<div>
<p>A slightly cleaner approach would be to make <code>WriteFile</code> return the path it wrote to, and change <code>ReadFile</code> to accept a task in place of its <code>PathBuf</code> argument.
Then we could pass a <code>WriteFile</code> task as the path argument for <code>ReadFile</code>.
We already hinted to this approach in the “Reduce Programming Errors by Returning Paths” block from the previous section.</p>
<p>However, that change would require a bigger refactoring, so we’ll go with the simpler (but also more flexible) approach in this tutorial.</p>
</div>
</details>
<p>Now we need to refactor the tests to provide <code>None</code> as the origin task for every <code>ReadFile</code> task we create.
Modify <code>pie/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_6"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -46,7 +46,7 @@
 
   let file = temp_dir.path().join("in.txt");
   write(&file, "HELLO WORLD!")?;
-  let task = ReadFile(file.clone(), FileStamper::Modified);
+  let task = ReadFile(file.clone(), FileStamper::Modified, None);
 
   // 1) Require task and assert that it is executed because it is new.
   let output = pie.require_then_assert_one_execute(&task)?;
@@ -62,7 +62,7 @@
 
   // Repeat the test with ${"`"}FileStamper::Exists${"`"}, which results in a different outcome.
   write(&file, "HELLO WORLD!")?;
-  let task = ReadFile(file.clone(), FileStamper::Exists);
+  let task = ReadFile(file.clone(), FileStamper::Exists, None);
 
   // 1) Require task and assert that it is executed because it is new.
   let output = pie.require_then_assert_one_execute(&task)?;
@@ -86,7 +86,7 @@
 
   let file = temp_dir.path().join("in.txt");
   write(&file, "HELLO WORLD!")?;
-  let read = ReadFile(file.clone(), FileStamper::Modified);
+  let read = ReadFile(file.clone(), FileStamper::Modified, None);
   let lower = ToLower(Box::new(read.clone()));
 
   // 1) Require ${"`"}ToLower${"`"} and assert that both tasks are executed in dependency order, because both tasks are new:
@@ -207,7 +207,7 @@
 
   let file = temp_dir.path().join("in.txt");
   write(&file, "Hello, World!")?;
-  let read = ReadFile(file.clone(), FileStamper::Modified);
+  let read = ReadFile(file.clone(), FileStamper::Modified, None);
   let lower = ToLower(Box::new(read.clone()));
   let upper = ToUpper(Box::new(lower.clone()));
 
@@ -262,7 +262,7 @@
 
     let seq = Sequence(vec![
       WriteFile(Box::new(Return("Hi there")), output_file.clone(), FileStamper::Modified),
-      WriteFile(Box::new(ReadFile(input_file.clone(), FileStamper::Modified)), output_file.clone(), FileStamper::Modified),
+      WriteFile(Box::new(ReadFile(input_file.clone(), FileStamper::Modified, None)), output_file.clone(), FileStamper::Modified),
     ]);
     // Require ${"`"}seq${"`"}, resulting in overlapping provided files between the two different write tasks.
     pie.require(&seq)?;
@@ -302,7 +302,7 @@
   let input_file = temp_dir.path().join("in.txt");
   write(&input_file, "Hello, World!")?;
 
-  let read = ReadFile(input_file.clone(), FileStamper::Modified);
+  let read = ReadFile(input_file.clone(), FileStamper::Modified, None);
   let write = WriteFile(Box::new(read), output_file.clone(), FileStamper::Modified);
 
   pie.require_then_assert_one_execute(&write)?;
@@ -327,7 +327,7 @@
 
   let input_file = temp_dir.path().join("in.txt");
   write(&input_file, "Hello, World!")?;
-  let read = ReadFile(input_file.clone(), FileStamper::Modified);
+  let read = ReadFile(input_file.clone(), FileStamper::Modified, None);
   let output_file_2 = temp_dir.path().join("out_2.txt");
   let write_2 = WriteFile(Box::new(read.clone()), output_file_2.clone(), FileStamper::Modified);
 
@@ -362,7 +362,7 @@
     let file = temp_dir.path().join("in_out.txt");
     write(&file, "Hello, World!")?;
 
-    let read = ReadFile(file.clone(), FileStamper::Modified);
+    let read = ReadFile(file.clone(), FileStamper::Modified, None);
     let write = WriteFile(Box::new(Return("Hi there")), file.clone(), FileStamper::Modified);
 
     pie.require_then_assert_one_execute(&write)?;
@@ -383,7 +383,7 @@
     let file = temp_dir.path().join("in_out.txt");
     write(&file, "Hello, World!")?;
 
-    let read = ReadFile(file.clone(), FileStamper::Modified);
+    let read = ReadFile(file.clone(), FileStamper::Modified, None);
     let write = WriteFile(Box::new(Return("Hi there")), file.clone(), FileStamper::Modified);
 
     pie.require_then_assert_one_execute(&read)?;
`;
    let target = document.getElementById('diff2html_6');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Confirm your changes are correct with <code>cargo test</code>.</p>
<p>Now add the following test to <code>pie/tests/top_down.rs</code>:</p>
<pre><code class="language-rust ">#[test]
fn test_non_hidden_dependency() -&gt; Result&lt;(), io::Error&gt; {
  let mut pie = test_pie();
  let temp_dir = create_temp_dir()?;

  let file = temp_dir.path().join(&quot;in_out.txt&quot;);
  write(&amp;file, &quot;Hello, World!&quot;)?;

  let input_file = temp_dir.path().join(&quot;in.txt&quot;);
  write(&amp;input_file, &quot;Hi There!&quot;)?;
  let read_input = ReadFile(input_file.clone(), FileStamper::Modified, None);
  let write = WriteFile(Box::new(read_input.clone()), file.clone(), FileStamper::Modified);
  let read = ReadFile(file.clone(), FileStamper::Modified, Some(Box::new(write.clone())));

  // Require `read`, which requires `write` to update the provided file. All tasks are executed because they are new.
  let output = pie.require_then_assert(&amp;read, |tracker| {
    assert!(tracker.one_execute_of(&amp;read));
    assert!(tracker.one_execute_of(&amp;write));
    assert!(tracker.one_execute_of(&amp;read_input));
  })?;
  // `read` should output what `write` wrote, which is what `read_input` read from `input_file`.
  assert_eq!(output.as_str(), &quot;Hi There!&quot;);

  Ok(())
}</code></pre>
<p>This is similar to earlier tests, but now we create an explicit dependency from <code>read</code> to <code>write</code> by passing in the <code>write</code> task as the last argument to <code>ReadFile</code>.
When we require <code>read</code>, it will first require its origin task <code>write</code> to make <code>file</code> up-to-date, and then require <code>file</code> and read from it.
This is not a hidden dependency: <code>file</code> is provided by <code>write</code>, but <code>read</code> has a dependency to <code>write</code>!</p>
<p>Now let’s test what happens if we remove <code>file</code>.
Modify the test in <code>pie/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_7"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -22,5 +22,23 @@
   // ${"`"}read${"`"} should output what ${"`"}write${"`"} wrote, which is what ${"`"}read_input${"`"} read from ${"`"}input_file${"`"}.
   assert_eq!(output.as_str(), "Hi There!");
 
+  // First ensure the modified date of ${"`"}file${"`"} has changed, then remove ${"`"}file${"`"}.
+  write_until_modified(&file, "Hi There!")?;
+  std::fs::remove_file(&file)?;
+  assert!(!file.exists());
+
+  // Confirm the provided file is re-generated.
+  let output = pie.require_then_assert(&read, |tracker| {
+    // ${"`"}write${"`"} should execute to re-generate the provided file.
+    assert!(tracker.one_execute_of(&write));
+    // ${"`"}read_input${"`"} is not executed because its file dependency to ${"`"}input_file${"`"} is consistent.
+    assert!(!tracker.any_execute_of(&read_input));
+    // ${"`"}read${"`"} is executed because its ${"`"}file${"`"} dependency is inconsistent, due to it having a new modified date. If we use
+    // a file hash stamper, we can prevent this re-execution.
+    assert!(tracker.one_execute_of(&read));
+  })?;
+  assert!(file.exists());
+  assert_eq!(output.as_str(), "Hi There!");
+
   Ok(())
 }
`;
    let target = document.getElementById('diff2html_7');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>When we remove <code>file</code> and require <code>read</code>, <code>read</code> will check its task dependency to <code>write</code>.
<code>write</code> is inconsistent due to the file being removed (modified stamp becomes <code>None</code>), so it will re-execute and re-generate the provided file!</p>
<div id="admonition-benefits-of-precise-dynamic-dependencies" class="admonition admonish-info">
<div class="admonition-title">
<p>Benefits of Precise Dynamic Dependencies</p>
<p><a class="admonition-anchor-link" href="#admonition-benefits-of-precise-dynamic-dependencies"></a></p>
</div>
<div>
<p>This is another great benefit of the precise dynamic dependencies in programmatic builds: removing an intermediate or output file does not break the build.
Instead, the file is just re-generated as needed, and the build is brought into a consistent state again.
Similarly, modifying <code>file</code> would result in the same behaviour: the provided file is re-generated and does not break the build.</p>
</div>
</div>
<div id="admonition-file-contents-hash-stamper" class="admonition admonish-info">
<div class="admonition-title">
<p>File Contents Hash Stamper</p>
<p><a class="admonition-anchor-link" href="#admonition-file-contents-hash-stamper"></a></p>
</div>
<div>
<p>Unfortunately, <code>read</code> is re-executed because its <code>file</code> dependency is inconsistent due to the changed modified date of <code>file</code>.
If we implement a file contents hash stamper and use that as the stamper for <code>file</code>, we can prevent this re-execution because the file contents is still the same.
This of course is not free, as hashing file contents has an I/O and processing (CPU) overhead.</p>
<p>In this case, <code>read</code> is so simple that the overhead from a hash stamper would be larger than the gains of not executing <code>read</code>.
But for expensive tasks with lots of I/O operations and/or processing, a file contents hash stamper makes a lot of sense.</p>
</div>
</div>
<p>As the last test, we will modify <code>input_file</code> and confirm that changes to that file propagate to <code>read</code>.
Modify the test in <code>pie/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_8"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -40,5 +40,10 @@
   assert!(file.exists());
   assert_eq!(output.as_str(), "Hi There!");
 
+  // Change ${"`"}read_input${"`"} and confirm the change is propagated to ${"`"}read${"`"}.
+  write_until_modified(&input_file, "Hello There!")?;
+  let output = pie.require(&read)?;
+  assert_eq!(output.as_str(), "Hello There!");
+
   Ok(())
 }
`;
    let target = document.getElementById('diff2html_8');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Confirm the test succeeds with <code>cargo test</code>.</p>
<p>We’ve now fixed the last file dependency inconsistency in the build system.
Absence of overlapping provided files ensures that provided files always end up in a consistent state, even in a programmatic incremental setting.
Absence of hidden dependencies ensures that when a task requires a file, that file is always in a consistent (up-to-date) state.</p>
<p>We needed to prevent these issues in order to make the builds correct under incrementality.
However, we can also use these properties in alternative context implementations to reason about whether certain states can occur.
For example, the actual PIE library contains a bottom-up incremental build context that instead performs incremental builds from the bottom up.
There we can use the absence of overlapping provided files and hidden dependencies to reason that a bottom-up build can correctly skip checking tasks in certain situations, increasing incrementality.
We do not (currently) cover bottom-up builds in this tutorial, but I found it important to highlight that these are fundamental properties.</p>
<details id="admonition-can-we-infer-hidden-dependencies" class="admonition admonish-question">
<summary class="admonition-title">
<p>Can we Infer Hidden Dependencies?</p>
<p><a class="admonition-anchor-link" href="#admonition-can-we-infer-hidden-dependencies"></a></p>
</summary>
<div>
<p>Currently, when we encounter a hidden dependency, we panic to stop the build.
Can we instead infer the hidden dependency and continue building?
Unfortunately, not really.</p>
<p>We could infer the first hidden dependency case: task R requires file F, provided by task P, without R requiring P.
In that case, we could require P before creating a dependency to F, and that could work rather well.</p>
<p>Unfortunately, we cannot infer the second hidden dependency case: task P provides file F, required by tasks R*, with one or more tasks from R* not requiring P.
At this point, it can already be too late to end up in a consistent state: a task from R* could have already been required/executed and have already read inconsistent file F.
We could infer the dependency but the task has already read inconsistent state, which is not correct.</p>
<p>We could choose to only infer the first hidden dependency case, but this can be very error-prone and inconsistent.
Without these explicit dependencies, we would rely on the build system to infer these for us.
But it could still occur that a task first requires file F before a task provides it, which would still panic due to the second case.
Whether this happens or not relies on which tasks are required by the user, which tasks are executed by the build system, and the order in which that happens.
Therefore, it is unfortunately a bad idea to infer hidden dependencies in a programmatic incremental build system.</p>
</div>
</details>
<div id="admonition-symbolic-links-an-incremental-build-systems-nightmare" class="admonition admonish-warning">
<div class="admonition-title">
<p>Symbolic Links: An Incremental Build System’s Nightmare</p>
<p><a class="admonition-anchor-link" href="#admonition-symbolic-links-an-incremental-build-systems-nightmare"></a></p>
</div>
<div>
<p>A file or directory can be a <a href="https://en.wikipedia.org/wiki/Symbolic_link" title="" target="_blank">symbolic link</a> to another file or directory. 
In this tutorial we do not deal with symbol links at all, and this is a threat to correctness.
For example, a task could circumvent a hidden dependency by creating a new symbolic link that links to the file it wants to read, where the linked-to file is provided by a task.
An overlapping provided file can be made in a similar way.</p>
<p>Therefore, we should resolve symbolic links, right… right?
Surely this should be easy.</p>
<p>One does not simply resolve a symbolic link in an incremental system.
The problem is that creating a dependency to a symbolic link, is actually creating two dependencies:</p>
<ul>
<li>a dependency to the symbolic link file/directory, with the stamper working on the <em>link</em>,</li>
<li>a dependency to the linked-to file/directory, with the stamper working on the linked-to file/directory.</li>
</ul>
<p>But wait, there’s more.
A symbolic link can point to a file with another symbolic link!
Therefore, any file dependency could become many file dependencies.
We have to recursively traverse the symbolic link tree.</p>
<p>What if I told you that there can even be cycles in symbolic links?
In that case, creating a file dependency actually creates infinite file dependencies!</p>
<p>We chose not to deal with this in the tutorial for simplicity.
In fact, I would almost refuse to support symbolic links, as they are the root of all evil from an incremental build systems’s perspective.</p>
</div>
</div>
<details id="admonition-performance-impact-of-symbolic-links" class="admonition admonish-warning">
<summary class="admonition-title">
<p>Performance Impact of Symbolic Links</p>
<p><a class="admonition-anchor-link" href="#admonition-performance-impact-of-symbolic-links"></a></p>
</summary>
<div>
<p>Symbolic links can be a performance problem, because resolving a symbolic link requires a system call, and we need to resolve every path.
We need to resolve every path because any path could point to a file or directory that again points to a different file or directory (and this can be recursive even!)
Therefore, the presence of symbolic links turn simple and cheap path operations into complex and expensive system calls.</p>
</div>
</details>
<div id="admonition-non-canonical-paths" class="admonition admonish-warning">
<div class="admonition-title">
<p>Non-Canonical Paths</p>
<p><a class="admonition-anchor-link" href="#admonition-non-canonical-paths"></a></p>
</div>
<div>
<p>There is an even simpler way than symbolic links to circumvent our checks: just create different paths that point to the same file.
For example, <code>in_out.txt</code> and <code>./in_out.txt</code> both point to the same file, but are different paths (i.e., comparing them with <code>Eq</code> will return <code>false</code>).</p>
<p>The issue is that we use non-canonical paths in the dependency graph, and thus also to check for overlapping provided files and hidden dependencies.
Instead, we should first canonicalize a path, converting relative paths to absolute ones, removing excess <code>..</code> <code>.</code> parts, and more.</p>
<p>We could use Rust’s <a href="https://doc.rust-lang.org/std/fs/fn.canonicalize.html" title="" target="_blank">
<code>canonicalize</code></a> function, but on Windows this returns paths that many tools do not support.
The <a href="https://docs.rs/dunce/latest/dunce/" title="" target="_blank">dunce</a> library can resolve this issue by canonicalizing to more compatible paths on Windows.</p>
<p>However, canonicalizing a path also resolves symbolic links.
If we resolve symbolic links but do not create separate dependencies to link files and linked-to files, we are breaking incrementality and correctness there.</p>
<p>We have four options:</p>
<ol>
<li>Write our own path canonicalization function that does not resolve symbolic links. Document that a dependency to a symbolic link only results in a dependency to the symbolic link file, which breaks incrementality and correctness when the linked-to file changes.</li>
<li>Write our own path canonicalization function that also correctly resolves symbolic links by creating dependencies to both link files and linked-to files, handle recursion, and handle cycles.</li>
<li>Canonicalize the path. Document that a dependency to a symbolic link only results in a dependency to the pointed-to file, which breaks incrementality and correctness when the link changes.</li>
<li>Don’t care about any of this.</li>
</ol>
<p>In this tutorial, we go for option 4 for simplicity.
Personally, I would choose for option 3 unless it is critical that symbolic links are handled in a correct way (then I’d have to choose option 2 and be grumpy).</p>
</div>
</div>
<div id="admonition-circumventing-checks" class="admonition admonish-warning">
<div class="admonition-title">
<p>Circumventing Checks</p>
<p><a class="admonition-anchor-link" href="#admonition-circumventing-checks"></a></p>
</div>
<div>
<p>There are many other ways to circumvent the hidden dependency check.
A simple one is to just not create a dependency!</p>
<p>We cannot fully waterproof our system, just like you can circumvent Rust’s safety with <code>unsafe</code> or by sharing mutable state via files. 
That is fine.
We should at least try our best to catch accidents, such as accidentally using different non-canonical paths for the same file.</p>
</div>
</div>
<p>In the next section, we will fix the remaining correctness issue related to cyclic tasks.</p>
<details id="admonition-download-source-code" class="admonition admonish-example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="../../gen/3_min_sound/6_hidden_dep/source.zip">download the source files up to this point</a>.</p>
</div>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../3_min_sound/5_overlap/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../3_min_sound/7_cycle/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../3_min_sound/5_overlap/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../3_min_sound/7_cycle/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../.././diff2html-ui-base.min.js"></script>


    </div>
    </body>
</html>
