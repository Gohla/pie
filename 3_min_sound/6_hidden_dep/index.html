<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Prevent Hidden Dependencies - Build your own Programmatic Incremental Build System</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../.././diff2html.min.css">
        <link rel="stylesheet" href="../.././mdbook-admonish.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Introduction</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Programmability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../1_programmability/0_setup/index.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../../1_programmability/1_api/index.html"><strong aria-hidden="true">2.2.</strong> Programmable Build System API</a></li><li class="chapter-item expanded "><a href="../../1_programmability/2_non_incremental/index.html"><strong aria-hidden="true">2.3.</strong> Non-Incremental Context</a></li></ol></li><li class="chapter-item expanded "><a href="../../2_incrementality/index.html"><strong aria-hidden="true">3.</strong> Incrementality</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../2_incrementality/1_require_file/index.html"><strong aria-hidden="true">3.1.</strong> Requiring Files</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/2_stamp/index.html"><strong aria-hidden="true">3.2.</strong> Stamps</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/3_dependency/index.html"><strong aria-hidden="true">3.3.</strong> Dynamic Dependencies</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/4_store/index.html"><strong aria-hidden="true">3.4.</strong> Dependency Graph Store</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/5_context/index.html"><strong aria-hidden="true">3.5.</strong> Incremental Top-Down Context</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/6_example/index.html"><strong aria-hidden="true">3.6.</strong> Incrementality Example</a></li></ol></li><li class="chapter-item expanded "><a href="../../3_min_sound/index.html"><strong aria-hidden="true">4.</strong> Testing Incrementality & Soundness</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../3_min_sound/1_session/index.html"><strong aria-hidden="true">4.1.</strong> Minimality with Sessions</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/2_tracker/index.html"><strong aria-hidden="true">4.2.</strong> Tracking Build Events</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/3_test/index.html"><strong aria-hidden="true">4.3.</strong> Integration Testing</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/4_fix_task_dep/index.html"><strong aria-hidden="true">4.4.</strong> Fix Superfluous Task Dependency</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/5_overlap/index.html"><strong aria-hidden="true">4.5.</strong> Prevent Overlapping File Writes</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/6_hidden_dep/index.html" class="active"><strong aria-hidden="true">4.6.</strong> Prevent Hidden Dependencies</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.7.</strong> Prevent Cycles</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Improvements</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Serialization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> More Stampers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Configurable Hashing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Efficiency</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Incremental Bottom-Up Context</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Observability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Deferred Tasks</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Multiple Task Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> On Static Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> On Declarativity</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Related Work</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
<!-- CHANGE: removed all but light and ayu theme, and renamed ayu to dark -->                          
<!--                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>-->
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/edit/master/tutorial/src/3_min_sound/6_hidden_dep/index.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="prevent-hidden-dependencies"><a class="header" href="#prevent-hidden-dependencies">Prevent Hidden Dependencies</a></h1>
<div id="admonition-under-construction" class="admonition admonish-warning">
<div class="admonition-title">
<p>Under Construction</p>
<p><a class="admonition-anchor-link" href="#admonition-under-construction"></a></p>
</div>
<div>
<p>This page is under construction</p>
</div>
</div>
<p>There is one more file-based inconsistency in our incremental build system that we need to prevent: hidden dependencies.
A hidden dependency occurs when a task R requires file F that is provided by another task P, without task R requiring task P.</p>
<p>Hidden dependencies are problematic for the same reason as overlapping provided files: we can require tasks in a specific order that causes an inconsistency.
For example, we could first require task R, which reads file F, and then we could require task P, which writes to and changes file F in such a way that R’s dependency to it becomes inconsistent.
This is incorrect, because we made task R consistent while its file dependency to F is inconsistent, so R should be inconsistent!</p>
<p>To prevent this problem, task R needs to require task P.
Then, when task R is required, task P will always first be made consistent, first writing its changes to file F, before task R reads file F.</p>
<p>This is all a bit abstract so let’s do the same as the previous section: write tests to show the problem.
In this section, we will:</p>
<ol>
<li>Create tests to showcase the hidden dependency problem.</li>
<li>Prevent hidden dependencies by checking for them at runtime, fixing the issue.</li>
<li>Improve and add additional tests</li>
</ol>
<h2 id="test-to-showcase-the-issue"><a class="header" href="#test-to-showcase-the-issue">Test to showcase the issue</a></h2>
<p>Add the following test to <code>pie/tests/top_down.rs</code>:</p>
<pre><code class="language-rust ">// Hidden dependency tests

#[test]
fn test_hidden_dependency() -&gt; Result&lt;(), io::Error&gt; {
  let mut pie = test_pie();
  let temp_dir = create_temp_dir()?;

  let file = temp_dir.path().join(&quot;in_out.txt&quot;);
  write(&amp;file, &quot;Hello, World!&quot;)?;

  let read = ReadFile(file.clone(), FileStamper::Modified);

  let input_file = temp_dir.path().join(&quot;in.txt&quot;);
  write(&amp;input_file, &quot;Hi there&quot;)?;
  let read_for_write = ReadFile(input_file.clone(), FileStamper::Modified);
  let write = WriteFile(Box::new(read_for_write.clone()), file.clone(), FileStamper::Modified);

  // Require `write` and `read`, assert they are executed because they are new.
  pie.require_then_assert_one_execute(&amp;write)?;
  assert_eq!(read_to_string(&amp;file)?, &quot;Hi there&quot;);
  let output = pie.require_then_assert_one_execute(&amp;read)?;
  assert_eq!(output.as_str(), &quot;Hi there&quot;);

  // Although there is a hidden dependency here (`read` doesn't require `write`), we happened to have required `write`
  // and `read` in the correct order, so there is no inconsistency yet. The output of `read` is `&quot;Hi there&quot;` which is
  // correct.

  Ok(())
}</code></pre>
<p>In this test, task <code>read</code> reads from <code>file</code>, and task <code>write</code> writes to <code>file</code>.
Task <code>write</code> gets the string to write through <code>read_for_write</code> which reads it from <code>input_file</code>.
There is a hidden dependency here, because <code>read</code> reads <code>file</code>, which is provided by <code>write</code>, without <code>read</code> actually requiring <code>write</code>.
We can say that the dependency from <code>read</code> to <code>write</code> is hidden by <code>file</code>.</p>
<p>We first require <code>write</code>, assert that it is executed, and assert that <code>file</code> now contains <code>&quot;Hi there&quot;</code> which is what <code>write</code> wrote into <code>file</code>.
Then we require <code>read</code> and assert that it is executed and returns <code>&quot;Hi there&quot;</code>.
Even though there is a hidden dependency, we have not observed an inconsistency yet, because we’ve required the tasks in the correct order.</p>
<p>Now extend this test in <code>pie/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_0"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -27,5 +27,23 @@
   // and ${"`"}read${"`"} in the correct order, so there is no inconsistency yet. The output of ${"`"}read${"`"} is ${"`"}"Hi there"${"`"} which is
   // correct.
 
+  // Change ${"`"}input_file${"`"} such that ${"`"}read_for_write${"`"} becomes inconsistent, making ${"`"}write${"`"} inconsistent.
+  write_until_modified(&input_file, "Hello There!")?;
+
+  // Require ${"`"}read${"`"} and assert that it has not been executed, because all its dependencies are still consistent.
+  let output = pie.require_then_assert_no_execute(&read)?;
+  assert_eq!(output.as_str(), "Hi there");
+  // Require ${"`"}write${"`"} and assert that it is executed, because its dependency to ${"`"}read_for_write${"`"} is inconsistent.
+  pie.require_then_assert_one_execute(&write)?;
+  assert_eq!(read_to_string(&file)?, "Hello There!");
+
+  // This is incorrect, as ${"`"}read${"`"} was deemed consistent with output ${"`"}"Hi there"${"`"}, even though ${"`"}write${"`"} was inconsistent
+  // and needed to first write ${"`"}"Hello There!"${"`"} to ${"`"}file${"`"}. This inconsistency occurs because the dependency from ${"`"}read${"`"}
+  // to ${"`"}write${"`"} was hidden by ${"`"}file${"`"}! This inconsistent behaviour is undesirable.
+
+  // Note: this is asserting the current behaviour, not the desired behaviour, which is to disallow this!
+  // Note: we required the tasks in separate sessions (${"`"}require_then_assert_one_execute${"`"} starts a new session), but
+  //       requiring these tasks in a single session will have the same outcome.
+
   Ok(())
 }
`;
    let target = document.getElementById('diff2html_0');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We change <code>input_file</code> such that <code>read_for_write</code> becomes inconsistent, making <code>write</code> inconsistent.
Basically, <code>write</code> now wants to write <code>&quot;Hello There!&quot;</code> to <code>file</code>.</p>
<p>We then require the tasks in the opposite order, first <code>read</code> and then <code>write</code>, but the result is incorrect.
Requiring <code>read</code> still returns <code>&quot;Hi there&quot;</code>, even though <code>write</code> is inconsistent and needs to first write <code>&quot;Hello There!&quot;</code> to <code>file</code> before <code>read</code> reads it!
Requiring <code>read</code> should really return <code>&quot;Hello There!&quot;</code>.</p>
<p>Similarly to overlapping provided files, this inconsistent behaviour is caused by the ability to require individual tasks, and our build system (incrementally and correctly) making only the required task (and its dependencies) consistent.
This inconsistent behaviour is undesirable, and should be prevented.</p>
<p>Before continuing, confirm the test succeeds with <code>cargo test</code>.
We will modify this test to assert the desired behaviour later.</p>
<h2 id="prevent-hidden-dependencies-1"><a class="header" href="#prevent-hidden-dependencies-1">Prevent hidden dependencies</a></h2>
<p>There are two ways in which a hidden dependency can be manifested:</p>
<ol>
<li>When a task R requires file F: if F is provided by task P, and R does not require P, there is a hidden dependency.</li>
<li>When a task P provides file F: if F is required by tasks R*, and one or more tasks from R* does not require P, there is a hidden dependency.</li>
</ol>
<p>We already saw an example of the first case in the test.
The second case occurs when a task first requires a file that is not yet provided by a task, but then later on a task provides it.
In both cases, the hidden dependency can result in tasks reading from a file that will later be written to (provided) by another task, which leaves those reading tasks in an inconsistent state.</p>
<p>We will need to check for both cases.
The first case can be checked in the <code>require_file_with_stamper</code> method, and the second one in <code>provide_file_with_stamper</code>.</p>
<p>Both checks need some way to query whether a task depends on another task.
We could query whether task R depends on P directly, and that would work fine.
However, sometimes task R will not require P directly, but require it through some other task(s) that require P eventually.
This is still correct, because P <em>will</em> be made consistent <em>before</em> R.
Therefore, we need to add a method to <code>Store</code> to query whether a task directly or indirectly (also called transitively) depends on another.</p>
<p>Furthermore, in the second check we need to get all tasks that require a file, for which we will also need a <code>Store</code> method.</p>
<h3 id="add-store-methods"><a class="header" href="#add-store-methods">Add <code>Store</code> methods</a></h3>
<p>Let’s add those methods to <code>Store</code>.
Modify <code>pie/src/store.rs</code>:</p>
<div class="diff2html" id="diff2html_1"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/store.rs
+++ pie/src/store.rs
@@ -167,6 +167,31 @@
       }
     ).next()
   }
+  /// Get all task nodes for tasks that require file ${"`"}dst${"`"}.
+  ///
+  /// # Panics
+  ///
+  /// Panics in development builds if ${"`"}dst${"`"} was not found in the dependency graph.
+  pub fn get_tasks_requiring_file<'a>(&'a self, dst: &'a FileNode) -> impl Iterator<Item=TaskNode> + '_ {
+    debug_assert!(self.graph.contains_node(dst), "BUG: node {:?} was not found in the dependency graph", dst);
+    self.graph.get_incoming_edges(dst).filter_map(|(n, d)|
+      if matches!(d, Dependency::RequireFile(_)) {
+        Some(TaskNode(*n))
+      } else {
+        None
+      }
+    )
+  }
+  /// Checks whether there is a direct or indirect (transitive) dependency from task ${"`"}src${"`"} to task ${"`"}dst${"`"}.
+  ///
+  /// # Panics
+  ///
+  /// Panics in development builds if ${"`"}src${"`"} or ${"`"}dst${"`"} were not found in the dependency graph.
+  pub fn contains_transitive_task_dependency(&self, src: &TaskNode, dst: &TaskNode) -> bool {
+    debug_assert!(self.graph.contains_node(src), "BUG: src node {:?} was not found in the dependency graph", src);
+    debug_assert!(self.graph.contains_node(dst), "BUG: dst node {:?} was not found in the dependency graph", dst);
+    self.graph.contains_transitive_edge(src, dst)
+  }
 
   /// Add a file require ${"`"}dependency${"`"} from task ${"`"}src${"`"} to file ${"`"}dst${"`"}.
   ///
`;
    let target = document.getElementById('diff2html_1');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We add the <code>get_tasks_requiring_file</code> method that does what it says on the tin.
It is almost identical to <code>get_task_providing_file</code>, but returns an <code>Iterator</code> because multiple tasks can require a single file.
We also have to make the lifetimes more explicit, to explain to Rust that the lifetimes on <code>self</code> and <code>dst</code> are not related to the implicit <code>'_</code> lifetime of the iterator.
This works because we are not borrowing anything in the iterator, because our <code>filter_map</code> copies nodes with <code>TaskNode(*n)</code>.</p>
<p>The <code>contains_transitive_task_dependency</code> method also does what it says.
Luckily, the graph library takes care of this query.</p>
<p>Per usual, add some tests for these methods in <code>pie/src/store.rs</code>:</p>
<div class="diff2html" id="diff2html_2"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/store.rs
+++ pie/src/store.rs
@@ -399,6 +399,11 @@
     assert_eq!(store.get_dependencies_of_task(&node_a).next(), None);
     assert_eq!(store.get_dependencies_of_task(&node_b).next(), None);
     assert_eq!(store.get_task_providing_file(&node_c), None);
+    assert_eq!(store.get_tasks_requiring_file(&node_c).next(), None);
+    assert!(!store.contains_transitive_task_dependency(&node_a, &node_a));
+    assert!(!store.contains_transitive_task_dependency(&node_b, &node_b));
+    assert!(!store.contains_transitive_task_dependency(&node_a, &node_b));
+    assert!(!store.contains_transitive_task_dependency(&node_b, &node_a));
 
     // Add file dependency from task A to file C.
     let file_dependency_a2c = FileDependency::new(&path_c, FileStamper::Exists).unwrap();
@@ -408,6 +413,11 @@
     assert_eq!(deps_of_a.get(1), None);
     assert_eq!(store.get_dependencies_of_task(&node_b).next(), None);
     assert_eq!(store.get_task_providing_file(&node_c), None);
+    let reqs_to_c: Vec<_> = store.get_tasks_requiring_file(&node_c).collect();
+    assert_eq!(reqs_to_c.get(0), Some(&node_a));
+    assert_eq!(reqs_to_c.get(1), None);
+    assert!(!store.contains_transitive_task_dependency(&node_a, &node_b));
+    assert!(!store.contains_transitive_task_dependency(&node_b, &node_a));
 
     // Add task dependency from task B to task A.
     let task_dependency_b2a = TaskDependency::new(task_a.clone(), OutputStamper::Equals, output_a.clone());
@@ -420,6 +430,11 @@
     assert_eq!(deps_of_b.get(0), Some(&Dependency::RequireTask(task_dependency_b2a.clone())));
     assert_eq!(deps_of_b.get(1), None);
     assert_eq!(store.get_task_providing_file(&node_c), None);
+    let reqs_to_c: Vec<_> = store.get_tasks_requiring_file(&node_c).collect();
+    assert_eq!(reqs_to_c.get(0), Some(&node_a));
+    assert_eq!(reqs_to_c.get(1), None);
+    assert!(!store.contains_transitive_task_dependency(&node_a, &node_b));
+    assert!(store.contains_transitive_task_dependency(&node_b, &node_a));
 
     // Add file dependency from task B to file C.
     let file_dependency_b2c = FileDependency::new(&path_c, FileStamper::Exists).unwrap();
@@ -432,6 +447,11 @@
     assert_eq!(deps_of_b.get(1), Some(&Dependency::ProvideFile(file_dependency_b2c.clone())));
     assert_eq!(deps_of_b.get(2), None);
     assert_eq!(store.get_task_providing_file(&node_c), Some(node_b));
+    let reqs_to_c: Vec<_> = store.get_tasks_requiring_file(&node_c).collect();
+    assert_eq!(reqs_to_c.get(0), Some(&node_a));
+    assert_eq!(reqs_to_c.get(1), None);
+    assert!(!store.contains_transitive_task_dependency(&node_a, &node_b));
+    assert!(store.contains_transitive_task_dependency(&node_b, &node_a));
 
     // Add task dependency from task A to task B, creating a cycle.
     let task_dependency_a2b = TaskDependency::new(task_a.clone(), OutputStamper::Equals, output_a.clone());
@@ -459,6 +479,24 @@
 
   #[test]
   #[should_panic]
+  fn get_tasks_requiring_file_panics() {
+    let mut fake_store: Store<StringConstant, String> = Store::default();
+    let fake_node = fake_store.get_or_create_file_node("hello.txt");
+    let store: Store<StringConstant, String> = Store::default();
+    let _ = store.get_tasks_requiring_file(&fake_node);
+  }
+
+  #[test]
+  #[should_panic]
+  fn test_contains_transitive_task_dependency_panics() {
+    let mut fake_store = Store::default();
+    let fake_node = fake_store.get_or_create_task_node(&StringConstant::new("Hello"));
+    let store: Store<StringConstant, String> = Store::default();
+    let _ = store.contains_transitive_task_dependency(&fake_node, &fake_node);
+  }
+
+  #[test]
+  #[should_panic]
   fn test_add_file_require_dependency_panics() {
     let mut fake_store = Store::default();
     let fake_file_node = fake_store.get_or_create_file_node("hello.txt");
`;
    let target = document.getElementById('diff2html_2');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We assert that the new methods return what is expected in <code>test_dependencies</code>, and add tests confirming panics when used on non-existent nodes.</p>
<h3 id="add-checks-to-topdowncontext"><a class="header" href="#add-checks-to-topdowncontext">Add checks to <code>TopDownContext</code></a></h3>
<p>Now we can add hidden dependency checks to <code>TopDownContext</code>.
Add the checks to <code>pie/src/context/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_3"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -30,6 +30,16 @@
     };
     let path = path.as_ref();
     let node = self.session.store.get_or_create_file_node(path);
+
+    if let Some(providing_task_node) = self.session.store.get_task_providing_file(&node) {
+      if !self.session.store.contains_transitive_task_dependency(current_executing_task_node, &providing_task_node) {
+        let current_executing_task = self.session.store.get_task(current_executing_task_node);
+        let providing_task = self.session.store.get_task(&providing_task_node);
+        panic!("Hidden dependency; file '{}' is required by the current executing task '{:?}' without a dependency to \
+                providing task: {:?}", path.display(), current_executing_task, providing_task);
+      }
+    }
+
     let (dependency, file) = FileDependency::new_with_file(path, stamper)?;
     self.session.tracker.require_file_end(&dependency);
     self.session.store.add_file_require_dependency(current_executing_task_node, &node, dependency);
@@ -50,6 +60,15 @@
               previously provided by task: {:?}", path.display(), current_executing_task, previous_providing_task);
     }
 
+    for requiring_task_node in self.session.store.get_tasks_requiring_file(&node) {
+      if !self.session.store.contains_transitive_task_dependency(&requiring_task_node, current_executing_task_node) {
+        let current_executing_task = self.session.store.get_task(current_executing_task_node);
+        let requiring_task = self.session.store.get_task(&requiring_task_node);
+        panic!("Hidden dependency; file '{}' is provided by the current executing task '{:?}' without a dependency \
+                from requiring task '{:?}' to the current executing task", path.display(), current_executing_task, requiring_task);
+      }
+    }
+
     let dependency = FileDependency::new(path, stamper)?;
     self.session.tracker.provide_file_end(&dependency);
     self.session.store.add_file_provide_dependency(current_executing_task_node, &node, dependency);
`;
    let target = document.getElementById('diff2html_3');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We add the first check to <code>require_file_with_stamper</code>, where the current executing task is requiring a file.
We check whether a task provides the file being required, and (inside the <code>if let</code>) check that the current executing task requires the providing task.
If not, we panic with a hidden dependency error.</p>
<p>Similarly, in <code>provide_file_with_stamper</code>, we perform the second check.
Because multiple task can require a file, we perform the check for every requiring task with a <code>for</code> loop.
If any requiring task fails the check, there is a hidden dependency, and panic with an error.</p>
<p>That’s it!
Test your changes with <code>cargo test</code>, which should make the <code>test_hidden_dependency</code> test fail as expected!</p>
<div id="admonition-expected-test-failure" class="admonition admonish-failure">
<div class="admonition-title">
<p>Expected Test Failure</p>
<p><a class="admonition-anchor-link" href="#admonition-expected-test-failure"></a></p>
</div>
<div>
<p>Test <code>test_hidden_dependency</code> will fail as expected, which we will now fix!</p>
</div>
</div>
<h2 id="fixing-and-improving-the-tests"><a class="header" href="#fixing-and-improving-the-tests">Fixing and improving the tests</a></h2>
<p>Like with the overlapping provided file test, we’ll heavily simplify our test to only test that it panics.
Modify <code>pie/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_4"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -2,48 +2,23 @@
 
 // Hidden dependency tests
 
+#[should_panic(expected = "Hidden dependency")]
 #[test]
-fn test_hidden_dependency() -> Result<(), io::Error> {
-  let mut pie = test_pie();
-  let temp_dir = create_temp_dir()?;
-
-  let file = temp_dir.path().join("in_out.txt");
-  write(&file, "Hello, World!")?;
-
-  let read = ReadFile(file.clone(), FileStamper::Modified);
-
-  let input_file = temp_dir.path().join("in.txt");
-  write(&input_file, "Hi there")?;
-  let read_for_write = ReadFile(input_file.clone(), FileStamper::Modified);
-  let write = WriteFile(Box::new(read_for_write.clone()), file.clone(), FileStamper::Modified);
-
-  // Require ${"`"}write${"`"} and ${"`"}read${"`"}, assert they are executed because they are new.
-  pie.require_then_assert_one_execute(&write)?;
-  assert_eq!(read_to_string(&file)?, "Hi there");
-  let output = pie.require_then_assert_one_execute(&read)?;
-  assert_eq!(output.as_str(), "Hi there");
-
-  // Although there is a hidden dependency here (${"`"}read${"`"} doesn't require ${"`"}write${"`"}), we happened to have required ${"`"}write${"`"}
-  // and ${"`"}read${"`"} in the correct order, so there is no inconsistency yet. The output of ${"`"}read${"`"} is ${"`"}"Hi there"${"`"} which is
-  // correct.
-
-  // Change ${"`"}input_file${"`"} such that ${"`"}read_for_write${"`"} becomes inconsistent, making ${"`"}write${"`"} inconsistent.
-  write_until_modified(&input_file, "Hello There!")?;
+fn test_require_hidden_dependency_panics() {
+  fn run() -> Result<(), io::Error> {
+    let mut pie = test_pie();
+    let temp_dir = create_temp_dir()?;
 
-  // Require ${"`"}read${"`"} and assert that it has not been executed, because all its dependencies are still consistent.
-  let output = pie.require_then_assert_no_execute(&read)?;
-  assert_eq!(output.as_str(), "Hi there");
-  // Require ${"`"}write${"`"} and assert that it is executed, because its dependency to ${"`"}read_for_write${"`"} is inconsistent.
-  pie.require_then_assert_one_execute(&write)?;
-  assert_eq!(read_to_string(&file)?, "Hello There!");
+    let file = temp_dir.path().join("in_out.txt");
+    write(&file, "Hello, World!")?;
 
-  // This is incorrect, as ${"`"}read${"`"} was deemed consistent with output ${"`"}"Hi there"${"`"}, even though ${"`"}write${"`"} was inconsistent
-  // and needed to first write ${"`"}"Hello There!"${"`"} to ${"`"}file${"`"}. This inconsistency occurs because the dependency from ${"`"}read${"`"}
-  // to ${"`"}write${"`"} was hidden by ${"`"}file${"`"}! This inconsistent behaviour is undesirable.
+    let read = ReadFile(file.clone(), FileStamper::Modified);
+    let write = WriteFile(Box::new(Return("Hi there")), file.clone(), FileStamper::Modified);
 
-  // Note: this is asserting the current behaviour, not the desired behaviour, which is to disallow this!
-  // Note: we required the tasks in separate sessions (${"`"}require_then_assert_one_execute${"`"} starts a new session), but
-  //       requiring these tasks in a single session will have the same outcome.
+    pie.require_then_assert_one_execute(&write)?;
+    pie.require_then_assert_one_execute(&read)?;
 
-  Ok(())
+    Ok(())
+  }
+  run().unwrap();
 }
`;
    let target = document.getElementById('diff2html_4');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We check for a <code>&quot;Hidden dependency&quot;</code> panic, rename the test, wrap it in a nested <code>run</code> function to support <code>Result</code>, and simplify it.
The second call to <code>require_then_assert_one_execute</code> will panic due to a hidden dependency: <code>read</code> requires <code>file</code> without a task dependency to <code>write</code>.</p>
<p>Now add a test for the second case to <code>pie/tests/top_down.rs</code>:</p>
<pre><code class="language-rust ">#[should_panic(expected = &quot;Hidden dependency&quot;)]
#[test]
fn test_provide_hidden_dependency_panics() {
  fn run() -&gt; Result&lt;(), io::Error&gt; {
    let mut pie = test_pie();
    let temp_dir = create_temp_dir()?;

    let file = temp_dir.path().join(&quot;in_out.txt&quot;);
    write(&amp;file, &quot;Hello, World!&quot;)?;

    let read = ReadFile(file.clone(), FileStamper::Modified);
    let write = WriteFile(Box::new(Return(&quot;Hi there&quot;)), file.clone(), FileStamper::Modified);

    pie.require_then_assert_one_execute(&amp;read)?;
    pie.require_then_assert_one_execute(&amp;write)?;

    Ok(())
  }
  run().unwrap();
}</code></pre>
<p>Here, the second call to <code>require_then_assert_one_execute</code> will panic due to a hidden dependency: <code>write</code> provides <code>file</code> which is required by <code>read</code> which does not have a task dependency to <code>write</code>.</p>
<p>Confirm both tests succeed with <code>cargo test</code>.
All tests are succeeding again 🎉.</p>
<p>We should also write some tests that show that non-hidden (visible?) dependencies do actually work.
However, our <code>ReadFile</code> task is not capable of making task dependencies at all, so we will need to fix that first (and refactor all uses of <code>ReadFile</code> unfortunately).</p>
<p>Modify <code>pie/tests/common/mod.rs</code>:</p>
<div class="diff2html" id="diff2html_5"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/common/mod.rs
+++ pie/tests/common/mod.rs
@@ -63,7 +63,7 @@
 #[derive(Clone, Eq, PartialEq, Hash, Debug)]
 pub enum TestTask {
   Return(&'static str),
-  ReadFile(PathBuf, FileStamper),
+  ReadFile(PathBuf, FileStamper, Option<Box<TestTask>>),
   WriteFile(Box<TestTask>, PathBuf, FileStamper),
   ToLower(Box<TestTask>),
   ToUpper(Box<TestTask>),
@@ -74,7 +74,10 @@
   fn execute<C: Context<Self>>(&self, context: &mut C) -> Self::Output {
     match self {
       TestTask::Return(string) => Ok(string.to_string().into()),
-      TestTask::ReadFile(path, stamper) => {
+      TestTask::ReadFile(path, stamper, origin) => {
+        if let Some(origin) = origin {
+          context.require_task(origin)?;
+        }
         let mut string = String::new();
         if let Some(mut file) = context.require_file_with_stamper(path, *stamper).map_err(|e| e.kind())? {
           file.read_to_string(&mut string).map_err(|e| e.kind())?;
`;
    let target = document.getElementById('diff2html_5');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We add an optional task argument to <code>ReadFile</code>, which we require when the read task is executed.
We call this optional task argument an <code>origin</code>, a shorthand for “originating task”.
This is a pattern that appears in programmatic build systems, where a task requires certain files, but those files could be provided by another task.
Instead of <code>Option&lt;Box&lt;TestTask&gt;&gt;</code>, we can also use <code>Vec&lt;TestTask&gt;</code> if multiple originating tasks are required.</p>
<details id="admonition-a-cleaner-approach" class="admonition admonish-tip">
<summary class="admonition-title">
<p>A Cleaner Approach</p>
<p><a class="admonition-anchor-link" href="#admonition-a-cleaner-approach"></a></p>
</summary>
<div>
<p>A slightly cleaner approach would be to make <code>WriteFile</code> return the path it wrote to, and change <code>ReadFile</code> to accept a task in place of its <code>PathBuf</code> argument.
Then we could pass a <code>WriteFile</code> task as the path argument for <code>ReadFile</code>.
We already hinted to this approach in the “Reduce Programming Errors by Returning Paths” block from the previous section.</p>
<p>However, that change would require a bigger refactoring, so we’ll go with the simpler (but also more flexible) approach in this tutorial.</p>
</div>
</details>
<p>Due to disallowing hidden dependencies, we need to make these originating tasks explicit, which unfortunately requires some additional work when authoring tasks.
However, the reward is that the build system will incrementalize running our tasks for free, and also ensure that the incremental build is correct.
Also, I think it is not such a bad idea to be explicit about these dependencies, because these really are dependencies that exist in the build!</p>
<p>Now we need to refactor the tests to provide <code>None</code> as the origin task for every <code>ReadFile</code> task we create.
Modify <code>pie/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_6"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -46,7 +46,7 @@
 
   let file = temp_dir.path().join("in.txt");
   write(&file, "HELLO WORLD!")?;
-  let task = ReadFile(file.clone(), FileStamper::Modified);
+  let task = ReadFile(file.clone(), FileStamper::Modified, None);
 
   // 1) Require task and assert that it is executed because it is new.
   let output = pie.require_then_assert_one_execute(&task)?;
@@ -62,7 +62,7 @@
 
   // Repeat the test with ${"`"}FileStamper::Exists${"`"}, which results in a different outcome.
   write(&file, "HELLO WORLD!")?;
-  let task = ReadFile(file.clone(), FileStamper::Exists);
+  let task = ReadFile(file.clone(), FileStamper::Exists, None);
 
   // 1) Require task and assert that it is executed because it is new.
   let output = pie.require_then_assert_one_execute(&task)?;
@@ -86,7 +86,7 @@
 
   let file = temp_dir.path().join("in.txt");
   write(&file, "HELLO WORLD!")?;
-  let read = ReadFile(file.clone(), FileStamper::Modified);
+  let read = ReadFile(file.clone(), FileStamper::Modified, None);
   let lower = ToLower(Box::new(read.clone()));
 
   // 1) Require ${"`"}ToLower${"`"} and assert that both tasks are executed in dependency order, because both tasks are new:
@@ -207,7 +207,7 @@
 
   let file = temp_dir.path().join("in.txt");
   write(&file, "Hello, World!")?;
-  let read = ReadFile(file.clone(), FileStamper::Modified);
+  let read = ReadFile(file.clone(), FileStamper::Modified, None);
   let lower = ToLower(Box::new(read.clone()));
   let upper = ToUpper(Box::new(lower.clone()));
 
@@ -262,7 +262,7 @@
 
     let seq = Sequence(vec![
       WriteFile(Box::new(Return("Hi there")), output_file.clone(), FileStamper::Modified),
-      WriteFile(Box::new(ReadFile(input_file.clone(), FileStamper::Modified)), output_file.clone(), FileStamper::Modified),
+      WriteFile(Box::new(ReadFile(input_file.clone(), FileStamper::Modified, None)), output_file.clone(), FileStamper::Modified),
     ]);
     // Require ${"`"}seq${"`"}, resulting in overlapping provided files between the two different write tasks.
     pie.require(&seq)?;
@@ -302,7 +302,7 @@
   let input_file = temp_dir.path().join("in.txt");
   write(&input_file, "Hello, World!")?;
 
-  let read = ReadFile(input_file.clone(), FileStamper::Modified);
+  let read = ReadFile(input_file.clone(), FileStamper::Modified, None);
   let write = WriteFile(Box::new(read), output_file.clone(), FileStamper::Modified);
 
   pie.require_then_assert_one_execute(&write)?;
@@ -327,7 +327,7 @@
 
   let input_file = temp_dir.path().join("in.txt");
   write(&input_file, "Hello, World!")?;
-  let read = ReadFile(input_file.clone(), FileStamper::Modified);
+  let read = ReadFile(input_file.clone(), FileStamper::Modified, None);
   let output_file_2 = temp_dir.path().join("out_2.txt");
   let write_2 = WriteFile(Box::new(read.clone()), output_file_2.clone(), FileStamper::Modified);
 
@@ -362,7 +362,7 @@
     let file = temp_dir.path().join("in_out.txt");
     write(&file, "Hello, World!")?;
 
-    let read = ReadFile(file.clone(), FileStamper::Modified);
+    let read = ReadFile(file.clone(), FileStamper::Modified, None);
     let write = WriteFile(Box::new(Return("Hi there")), file.clone(), FileStamper::Modified);
 
     pie.require_then_assert_one_execute(&write)?;
@@ -383,7 +383,7 @@
     let file = temp_dir.path().join("in_out.txt");
     write(&file, "Hello, World!")?;
 
-    let read = ReadFile(file.clone(), FileStamper::Modified);
+    let read = ReadFile(file.clone(), FileStamper::Modified, None);
     let write = WriteFile(Box::new(Return("Hi there")), file.clone(), FileStamper::Modified);
 
     pie.require_then_assert_one_execute(&read)?;
`;
    let target = document.getElementById('diff2html_6');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Confirm your changes are correct with <code>cargo test</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../3_min_sound/5_overlap/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../3_min_sound/5_overlap/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../.././diff2html-ui-base.min.js"></script>


    </div>
    </body>
</html>
