<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Integration Testing - Build your own Programmatic Incremental Build System</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../src/diff2html.min.css">
        <link rel="stylesheet" href="../../src/mdbook-admonish.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Introduction</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Programmability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../1_programmability/0_setup/index.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../../1_programmability/1_api/index.html"><strong aria-hidden="true">2.2.</strong> Programmable Build System API</a></li><li class="chapter-item expanded "><a href="../../1_programmability/2_non_incremental/index.html"><strong aria-hidden="true">2.3.</strong> Non-Incremental Context</a></li></ol></li><li class="chapter-item expanded "><a href="../../2_incrementality/index.html"><strong aria-hidden="true">3.</strong> Incrementality</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../2_incrementality/1_require_file/index.html"><strong aria-hidden="true">3.1.</strong> Requiring Files</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/2_stamp/index.html"><strong aria-hidden="true">3.2.</strong> Stamps</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/3_dependency/index.html"><strong aria-hidden="true">3.3.</strong> Dynamic Dependencies</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/4_store/index.html"><strong aria-hidden="true">3.4.</strong> Dependency Graph Store</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/5_context/index.html"><strong aria-hidden="true">3.5.</strong> Incremental Top-Down Context</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/6_example/index.html"><strong aria-hidden="true">3.6.</strong> Incrementality Example</a></li></ol></li><li class="chapter-item expanded "><a href="../../3_min_sound/index.html"><strong aria-hidden="true">4.</strong> Minimality and Soundness</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../3_min_sound/1_session/index.html"><strong aria-hidden="true">4.1.</strong> Minimality with Sessions</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/2_tracker/index.html"><strong aria-hidden="true">4.2.</strong> Tracking Build Events</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/3_test/index.html" class="active"><strong aria-hidden="true">4.3.</strong> Integration Testing</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> Prevent Overlapping File Writes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> Prevent Hidden Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.6.</strong> Prevent Cycles</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Improvements</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Serialization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> More Stampers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Configurable Hashing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Efficiency</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Incremental Bottom-Up Context</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Observability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Deferred Tasks</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Multiple Task Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> On Static Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> On Declarativity</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Related Work</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
<!-- CHANGE: removed all but light and ayu theme, and renamed ayu to dark -->                          
<!--                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>-->
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/edit/master/tutorial/src/3_min_sound/3_test/index.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h1>
<h2 id="testing-utilities"><a class="header" href="#testing-utilities">Testing utilities</a></h2>
<p>First we start by adding testing utilities (it never ends, does it?) that will make writing integration tests more convenient.
Unfortunately, we can't use <code>dev_shared</code> for this, as we would need to add a dependency to from <code>dev_shared</code> to <code>pie</code>, resulting in a dependency cycle because <code>pie</code> depends on <code>dev_shared</code>.</p>
<details id="admonition-development-dependency-cycle" class="admonition info">
<summary class="admonition-title">
<p>Development dependency cycle</p>
<p><a class="admonition-anchor-link" href="#admonition-development-dependency-cycle"></a></p>
</summary>
<div>
<p>If you would create this cycle, the code would still compile, but there would be 2 different instances of <code>pie</code> at the same time: one with unit testing enabled (<code>#[cfg(test)]</code>), and one without.
Even though these libraries are very similar, they are effectively 2 completely different libraries.
When <code>pie</code> uses code from <code>dev_shared</code> that depends again on <code>pie</code>, then there will be errors about types and traits not matching.</p>
<p>This is <a href="https://github.com/rust-lang/cargo/issues/6765">probably a bug in cargo</a>, or at least undesired behaviour. 
It should allow this cycle and make it work correctly, or disallow it.</p>
</div>
</details>
<p>We will put the utilities in a common file and use that as a module in integration tests.
Create the <code>pie/src/tests</code> directory, create the <code>pie/src/tests/common</code> directory, and create the <code>pie/src/tests/common/mod.rs</code> file.
Add the following code to <code>pie/src/tests/common/mod.rs</code>:</p>
<pre><code class="language-rust ">use std::io::{BufWriter, ErrorKind, Stdout};

use pie::{Context, Pie, Task};
use pie::tracker::CompositeTracker;
use pie::tracker::event::EventTracker;
use pie::tracker::writing::WritingTracker;

/// Testing tracker composed of an [`EventTracker`] for testing and stdout [`WritingTracker`] for debugging.
pub type TestTracker&lt;T&gt; = CompositeTracker&lt;EventTracker&lt;T, &lt;T as Task&gt;::Output&gt;, WritingTracker&lt;BufWriter&lt;Stdout&gt;&gt;&gt;;
pub fn test_tracker&lt;T: Task&gt;() -&gt; TestTracker&lt;T&gt; {
  CompositeTracker(EventTracker::default(), WritingTracker::with_stdout())
}

/// Testing [`Pie`] using [`TestTracker`].
pub type TestPie&lt;T&gt; = Pie&lt;T, &lt;T as Task&gt;::Output, TestTracker&lt;T&gt;&gt;;
pub fn test_pie&lt;T: Task&gt;() -&gt; TestPie&lt;T&gt; {
  TestPie::with_tracker(test_tracker())
}</code></pre>
<p>These are just types and functions to create <code>TestPie</code> instances, which are <code>Pie</code> instances using <code>CompositeTracker&lt;EventTracker, WritingTracker&gt;</code> as tracker, where the writing tracker will write to standard output.</p>
<p>Add the following to <code>pie/src/tests/common/mod.rs</code>:</p>
<pre><code class="language-rust ">/// Testing extensions for [`TestPie`].
pub trait TestPieExt&lt;T: Task&gt; {
  /// Require `task` in a new session, assert that there are no dependency check errors, then runs `test_assert_func`
  /// on the event tracker for test assertion purposes.
  fn require_then_assert(
    &amp;mut self,
    task: &amp;T,
    test_assert_func: impl FnOnce(&amp;EventTracker&lt;T, T::Output&gt;),
  ) -&gt; T::Output;

  /// Require `task` in a new session, asserts that there are no dependency check errors.
  fn require(&amp;mut self, task: &amp;T) -&gt; T::Output {
    self.require_then_assert(task, |_| {})
  }

  /// Require `task` in a new session, then assert that it is not executed.
  fn require_then_assert_no_execute(&amp;mut self, task: &amp;T) -&gt; T::Output {
    self.require_then_assert(task, |t|
      assert!(!t.any_execute_of(task), &quot;expected no execution of task {:?}, but it was executed&quot;, task),
    )
  }
  /// Require `task` in a new session, then assert that it is executed exactly once.
  fn require_then_assert_one_execute(&amp;mut self, task: &amp;T) -&gt; T::Output {
    self.require_then_assert(task, |t|
      assert!(t.one_execute_of(task), &quot;expected one execution of task {:?}, but it was not executed, or was executed more than once&quot;, task),
    )
  }
}
impl&lt;T: Task&gt; TestPieExt&lt;T&gt; for TestPie&lt;T&gt; {
  fn require_then_assert(&amp;mut self, task: &amp;T, test_assert_func: impl FnOnce(&amp;EventTracker&lt;T, T::Output&gt;)) -&gt; T::Output {
    let mut session = self.new_session();
    let output = session.require(task);
    assert!(session.dependency_check_errors().is_empty(), &quot;expected no dependency checking errors, but there are \
    dependency checking errors: {:?}&quot;, session.dependency_check_errors());
    test_assert_func(&amp;self.tracker().0);
    output
  }
}</code></pre>
<p>We define an extension trait <code>TestPieExt</code> with a <code>require_then_assert</code> method, which requires a task in a new session, asserts that there are no dependency check errors, and then gives us the opportunity to perform additional assertions via a function that gives access to <code>EventTracker</code>.
This is very convenient for integration testing, as most tests will follow the pattern of requiring a task and then asserting properties.</p>
<p>This trait also provides:</p>
<ul>
<li><code>require</code> which is <code>require_then_assert</code> without an assertion closure,</li>
<li><code>require_then_assert_no_execute</code> which after requiring asserts that the task has not been executed using <code>!t.any_execution_of(task)</code> from <code>EventTracker</code>,</li>
<li><code>require_then_assert_one_execute</code> which does the same but asserts that it has been executed exactly once.</li>
</ul>
<p>We implement <code>TestPieExt</code> for <code>TestPie</code> so that we can call <code>require_then_assert</code> on any <code>TestPie</code> instance.</p>
<details id="admonition-extension-trait" class="admonition info">
<summary class="admonition-title">
<p>Extension trait</p>
<p><a class="admonition-anchor-link" href="#admonition-extension-trait"></a></p>
</summary>
<div>
<p>Extension traits are a pattern in Rust where we can add methods to an existing type via an extension trait and an implementation of the extension trait for the existing type.</p>
</div>
</details>
<p>We still need to define a task for testing.
Add the following to <code>pie/src/tests/common/mod.rs</code>:</p>
<pre><code class="language-rust ">/// Testing tasks enumeration.
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub enum TestTask {
  StringConstant(&amp;'static str),
}
impl Task for TestTask {
  type Output = Result&lt;TestOutput, ErrorKind&gt;;
  fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, _context: &amp;mut C) -&gt; Self::Output {
    match self {
      TestTask::StringConstant(string) =&gt; Ok(string.to_string().into()),
    }
  }
}

/// [`TestTask`] output enumeration.
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub enum TestOutput {
  String(String),
}
impl From&lt;String&gt; for TestOutput {
  fn from(value: String) -&gt; Self { Self::String(value) }
}
impl TestOutput {
  pub fn as_str(&amp;self) -&gt; &amp;str {
    match self {
      Self::String(s) =&gt; &amp;s,
    }
  }
}</code></pre>
<p>We define a <code>TestTask</code> enumeration containing all testing tasks, which for now is just a <code>StringConstant</code> task that returns a string, and implement <code>Task</code> for it.
The <code>Output</code> for <code>TestTask</code> is <code>Result&lt;TestOutput, ErrorKind&gt;</code> so that we can propagate IO errors in the future.</p>
<p><code>TestOutput</code> enumerates all possible outputs for <code>TestTask</code>, which for now is just a <code>String</code>.
We implement <code>From&lt;String&gt;</code> for <code>TestOutput</code> so we can easily convert <code>String</code>s into <code>TestOutput</code>. 
<code>as_str</code> performs the opposite operation.</p>
<p>Check that the code compiles with <code>cargo test</code>.</p>
<h2 id="first-integration-test"><a class="header" href="#first-integration-test">First integration test</a></h2>
<p>Now we're ready to test incrementality and soundness of the top-down incremental context through integration tests.
Create the <code>pie/src/tests/top_down.rs</code> file and add to it:</p>
<pre><code class="language-rust ">use std::io;

use assert_matches::assert_matches;

use pie::tracker::event::*;

use crate::common::{test_pie, TestPieExt, TestTask::*};

mod common;

#[test]
fn test_execution() -&gt; Result&lt;(), io::Error&gt; {
  let mut pie = test_pie();
  let task = StringConstant(&quot;Hello, World!&quot;);
  let output = pie.require_then_assert(&amp;task, |tracker| {
    let events = tracker.slice();
    assert_matches!(events.get(0), Some(Event::RequireTaskStart(RequireTaskStart { task: t, .. })) if t == &amp;task);
    assert_matches!(events.get(1), Some(Event::ExecuteStart(ExecuteStart { task: t, .. })) if t == &amp;task);
    assert_matches!(events.get(2), Some(Event::ExecuteEnd(ExecuteEnd { task: t, .. })) if t == &amp;task);
    assert_matches!(events.get(3), Some(Event::RequireTaskEnd(RequireTaskEnd { task: t, .. })) if t == &amp;task);
  })?;
  assert_eq!(output.as_str(), &quot;Hello, World!&quot;);
  Ok(())
}</code></pre>
<p>In this first <code>test_execution</code> test we are just making sure that new tasks are executed, assert that the order of operations is correct, and check the task output.
We use <code>require_then_assert</code> to require the task and then perform assertions through a closure.
We're using <code>tracker.slice()</code> to get a slice of all build events, and assert (using <a href="https://docs.rs/assert_matches/latest/assert_matches/macro.assert_matches.html"><code>assert_matches!</code></a> again) that the following operations happen in order:</p>
<ul>
<li>start requiring <code>task</code>,</li>
<li>start executing <code>task</code>,</li>
<li>done executing <code>task</code>,</li>
<li>done requiring <code>task</code>.</li>
</ul>
<p><code>require_then_assert</code> returns the output of the task, which is a <code>Result</code>, so we first propagate the error with <code>?</code>.
Finally, we assert that the output equals what we expect.</p>
<p>Check that this test succeeds with <code>cargo test</code>.
To see what test failures look like, temporarily change <code>events.get(2)</code> to <code>events.get(3)</code> for example.</p>
<details id="admonition-integration-testing-in-rust" class="admonition info">
<summary class="admonition-title">
<p>Integration testing in Rust</p>
<p><a class="admonition-anchor-link" href="#admonition-integration-testing-in-rust"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/rust-by-example/testing/integration_testing.html">Integration tests</a> in Rust are for testing whether the different parts of your library work together correctly.
Integration tests have access to the public API of your crate.</p>
<p>In this <code>top_down.rs</code> integration test file, we're importing <code>common/mod.rs</code> by creating a module for it via <code>mod common;</code>.
If we create another integration testing file, we would again create a module for it in that integration testing file.
This is because every file in the <code>tests</code> directory is compiled as a separate crate, and can basically be seen as a separate <code>lib.rs</code> or <code>main.rs</code> file.</p>
<p>Putting the testing utilities behind a <code>common</code> directory ensures that it will not be compiled as a separate integration testing crate.</p>
</div>
</details>
<h2 id="testing-incrementality-and-soundness"><a class="header" href="#testing-incrementality-and-soundness">Testing incrementality and soundness</a></h2>
<p>We will now test incrementality and soundness.</p>
<h3 id="no-dependencies"><a class="header" href="#no-dependencies">No dependencies</a></h3>
<p>Let's first test that requiring a task without dependencies twice, only executes it once.
Add the following test to <code>pie/src/tests/top_down.rs</code>:</p>
<pre><code class="language-rust ">#[test]
fn test_reuse() -&gt; Result&lt;(), io::Error&gt; {
  let mut pie = test_pie();
  let task = StringConstant(&quot;Hello, World!&quot;);
  // New task: execute.
  let output = pie.require(&amp;task)?;
  assert_eq!(output.as_str(), &quot;Hello, World!&quot;);
  // Nothing changed: no execute
  pie.require_then_assert_no_execute(&amp;task)?;
  Ok(())
}</code></pre>
<p>We're using <code>require</code> and <code>require_then_assert_no_execute</code> from <code>TestPieExt</code> which require the same task twice, in two different sessions.
Since <code>StringConstant</code> has no dependencies, it should only ever be executed once, after which its output is cached for all eternity.</p>
<p>Check that this test succeeds with <code>cargo test</code>.</p>
<div id="admonition-reading-standard-output-from-tests" class="admonition info">
<div class="admonition-title">
<p>Reading standard output from tests</p>
<p><a class="admonition-anchor-link" href="#admonition-reading-standard-output-from-tests"></a></p>
</div>
<div>
<p>Cargo runs tests in parallel by default, which is good to run all tests as fast as possible (and it's also safe due to Rust's memory-safety and thread-safety guarantees!)
However, this mixes the standard outputs of all tests, which makes reading the build log from our writing tracker impossible.
If you want to see the standard output, either:</p>
<ul>
<li>Run tests <a href="https://doc.rust-lang.org/book/ch11-02-running-tests.html#running-tests-in-parallel-or-consecutively">consecutively</a> with: <code>cargo test -- --test-threads=1</code></li>
<li>Run a <a href="https://doc.rust-lang.org/book/ch11-02-running-tests.html#running-single-tests">single test</a> in the <code>top_down</code> integration test file with: <code>cargo test --test top_down test_reuse</code></li>
</ul>
<p>The second command should result in something like:</p>
<pre><code>    Finished test [unoptimized + debuginfo] target(s) in 0.02s
     Running tests/top_down.rs (/pie/target/debug/deps/top_down-f49294f0992aeb61)

running 1 test
→ StringConstant(&quot;Hello, World!&quot;)
 ▶ StringConstant(&quot;Hello, World!&quot;)
 ◀ Ok(String(&quot;Hello, World!&quot;))
← Ok(String(&quot;Hello, World!&quot;))
🏁
→ StringConstant(&quot;Hello, World!&quot;)
← Ok(String(&quot;Hello, World!&quot;))
🏁
test test_reuse ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

</code></pre>
</div>
</div>
<h3 id="file-dependency"><a class="header" href="#file-dependency">File dependency</a></h3>
<p>Next we want to test that a task with dependencies is not executed if its dependencies are consistent, and is executed when any of its dependencies are inconsistent.
Therefore, we need to add a task that has dependencies.</p>
<p>Modify <code>pie/src/tests/common/mod.rs</code>:</p>
<div class="diff2html" id="diff2html_0"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/common/mod.rs
+++ pie/tests/common/mod.rs
@@ -1,6 +1,8 @@
-use std::io::{BufWriter, ErrorKind, Stdout};
+use std::io::{BufWriter, ErrorKind, Read, Stdout};
+use std::path::PathBuf;
 
 use pie::{Context, Pie, Task};
+use pie::stamp::FileStamper;
 use pie::tracker::CompositeTracker;
 use pie::tracker::event::EventTracker;
 use pie::tracker::writing::WritingTracker;
@@ -60,12 +62,20 @@
 #[derive(Clone, Eq, PartialEq, Hash, Debug)]
 pub enum TestTask {
   StringConstant(&'static str),
+  ReadStringFromFile(PathBuf, FileStamper),
 }
 impl Task for TestTask {
   type Output = Result<TestOutput, ErrorKind>;
-  fn execute<C: Context<Self>>(&self, _context: &mut C) -> Self::Output {
+  fn execute<C: Context<Self>>(&self, context: &mut C) -> Self::Output {
     match self {
       TestTask::StringConstant(string) => Ok(string.to_string().into()),
+      TestTask::ReadStringFromFile(path, stamper) => {
+        let mut string = String::new();
+        if let Some(mut file) = context.require_file_with_stamper(&path, *stamper).map_err(|e| e.kind())? {
+          file.read_to_string(&mut string).map_err(|e| e.kind())?;
+        }
+        Ok(string.into())
+      }
     }
   }
 }
`;
    let target = document.getElementById('diff2html_0');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We add a <code>ReadStringFromFile</code> task that requires a file and returns its content as a string, similar to the ones we have implemented in the past.</p>
<p>Modify <code>pie/src/tests/top_down.rs</code> to add a new test:</p>
<div class="diff2html" id="diff2html_1"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -1,7 +1,10 @@
+use std::fs::write;
 use std::io;
 
 use assert_matches::assert_matches;
 
+use dev_shared::{create_temp_dir, write_until_modified};
+use pie::stamp::FileStamper;
 use pie::tracker::event::*;
 
 use crate::common::{test_pie, TestPieExt, TestTask::*};
@@ -34,3 +37,43 @@
   pie.require_then_assert_no_execute(&task)?;
   Ok(())
 }
+
+#[test]
+fn test_require_file() -> Result<(), io::Error> {
+  let mut pie = test_pie();
+  let temp_dir = create_temp_dir()?;
+
+  let path = temp_dir.path().join("in.txt");
+  write(&path, "HELLO WORLD!")?;
+  let task = ReadStringFromFile(path.clone(), FileStamper::Modified);
+  
+  // Require task and assert that it is executed because it is new.
+  let output = pie.require_then_assert_one_execute(&task)?;
+  assert_eq!(output.as_str(), "HELLO WORLD!");
+  // Require task again and assert that it is not executed because all its dependencies are consistent.
+  let output = pie.require_then_assert_no_execute(&task)?;
+  assert_eq!(output.as_str(), "HELLO WORLD!");
+  // Change required file such that the file dependency of the task becomes inconsistent.
+  write_until_modified(&path, "!DLROW OLLEH")?;
+  // Require task again and assert that it re-executed because its file dependency is inconsistent.
+  let output = pie.require_then_assert_one_execute(&task)?;
+  assert_eq!(output.as_str(), "!DLROW OLLEH");
+
+  // Repeat the test with FileStamper::Exists, which results in a different outcome.
+  write(&path, "HELLO WORLD!")?;
+  let task = ReadStringFromFile(path.clone(), FileStamper::Exists);
+
+  // Require task and assert that it is executed because it is new.
+  let output = pie.require_then_assert_one_execute(&task)?;
+  assert_eq!(output.as_str(), "HELLO WORLD!");
+  // Require task again and assert that it is not executed because all its dependencies are consistent.
+  let output = pie.require_then_assert_no_execute(&task)?;
+  assert_eq!(output.as_str(), "HELLO WORLD!");
+  // Change required file, but the file dependency of the task stays consistent.
+  write_until_modified(&path, "!DLROW OLLEH")?;
+  // Require task again and assert that it is not executed because all its dependencies are consistent.
+  let output = pie.require_then_assert_no_execute(&task)?;
+  assert_eq!(output.as_str(), "HELLO WORLD!");
+
+  Ok(())
+}
`;
    let target = document.getElementById('diff2html_1');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>In this test, we require a <code>ReadStringFromFile</code> task several times, and assert whether it should be executed or not.
The first time, the task is new, so it should be executed.
The second time, the task is not new, and its single require file dependency is still consistent, so it should not be executed.
Then, we change the file the task depends on with <code>write_until_modified</code>.
Then, we require the task again, and it should be executed because its dependency became inconsistent.</p>
<p>We repeat the test with the <code>FileStamper::Exists</code> stamper, which correctly results in the task only being executed once.
It is a new task because its stamper is different, and it is not re-executed when the file is changed due to <code>FileStamper::Exists</code> only checking if the file exists.</p>
<p>Check that this test succeeds with <code>cargo test</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../3_min_sound/2_tracker/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../3_min_sound/2_tracker/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../src/diff2html-ui-base.min.js"></script>


    </div>
    </body>
</html>
