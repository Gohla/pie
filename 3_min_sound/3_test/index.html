<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Integration Testing - Build your own Programmatic Incremental Build System</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../.././diff2html.min.css">
        <link rel="stylesheet" href="../.././mdbook-admonish.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Introduction</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Programmability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../1_programmability/0_setup/index.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../../1_programmability/1_api/index.html"><strong aria-hidden="true">2.2.</strong> Programmable Build System API</a></li><li class="chapter-item expanded "><a href="../../1_programmability/2_non_incremental/index.html"><strong aria-hidden="true">2.3.</strong> Non-Incremental Context</a></li></ol></li><li class="chapter-item expanded "><a href="../../2_incrementality/index.html"><strong aria-hidden="true">3.</strong> Incrementality</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../2_incrementality/1_require_file/index.html"><strong aria-hidden="true">3.1.</strong> Requiring Files</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/2_stamp/index.html"><strong aria-hidden="true">3.2.</strong> Stamps</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/3_dependency/index.html"><strong aria-hidden="true">3.3.</strong> Dynamic Dependencies</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/4_store/index.html"><strong aria-hidden="true">3.4.</strong> Dependency Graph Store</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/5_context/index.html"><strong aria-hidden="true">3.5.</strong> Incremental Top-Down Context</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/6_example/index.html"><strong aria-hidden="true">3.6.</strong> Incrementality Example</a></li></ol></li><li class="chapter-item expanded "><a href="../../3_min_sound/index.html"><strong aria-hidden="true">4.</strong> Testing Incrementality & Soundness</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../3_min_sound/1_session/index.html"><strong aria-hidden="true">4.1.</strong> Minimality with Sessions</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/2_tracker/index.html"><strong aria-hidden="true">4.2.</strong> Tracking Build Events</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/3_test/index.html" class="active"><strong aria-hidden="true">4.3.</strong> Integration Testing</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/4_fix_task_dep/index.html"><strong aria-hidden="true">4.4.</strong> Fix Superfluous Task Dependency</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/5_overlap/index.html"><strong aria-hidden="true">4.5.</strong> Prevent Overlapping File Writes</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/6_hidden_dep/index.html"><strong aria-hidden="true">4.6.</strong> Prevent Hidden Dependencies</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.7.</strong> Prevent Cycles</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Improvements</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Serialization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> More Stampers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Configurable Hashing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Efficiency</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Incremental Bottom-Up Context</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Observability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Deferred Tasks</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Multiple Task Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> On Static Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> On Declarativity</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Related Work</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
<!-- CHANGE: removed all but light and ayu theme, and renamed ayu to dark -->                          
<!--                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>-->
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/edit/master/tutorial/src/3_min_sound/3_test/index.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h1>
<h2 id="testing-utilities"><a class="header" href="#testing-utilities">Testing utilities</a></h2>
<p>First we start by adding testing utilities (it never ends, does it?) that will make writing integration tests more convenient.
Unfortunately, we can’t use <code>dev_shared</code> for this, as we would need to add a dependency to from <code>dev_shared</code> to <code>pie</code>, resulting in a dependency cycle because <code>pie</code> depends on <code>dev_shared</code>.</p>
<details id="admonition-development-dependency-cycle" class="admonition admonish-note">
<summary class="admonition-title">
<p>Development Dependency Cycle</p>
<p><a class="admonition-anchor-link" href="#admonition-development-dependency-cycle"></a></p>
</summary>
<div>
<p>If you would create this cycle, the code would still compile, but there would be 2 different instances of <code>pie</code> at the same time: one with unit testing enabled (<code>#[cfg(test)]</code>), and one without.
Even though these libraries are very similar, they are effectively 2 completely different libraries.
When <code>pie</code> uses code from <code>dev_shared</code> that depends again on <code>pie</code>, then there will be errors about types and traits not matching.</p>
<p>This is <a href="https://github.com/rust-lang/cargo/issues/6765" title="" target="_blank">probably a bug in cargo</a>, or at least undesired behaviour. 
It should allow this cycle and make it work correctly, or disallow it.</p>
</div>
</details>
<p>We will put the utilities in a common file and use that as a module in integration tests.
Create the <code>pie/src/tests</code> directory, create the <code>pie/src/tests/common</code> directory, and create the <code>pie/src/tests/common/mod.rs</code> file.
Add the following code to <code>pie/src/tests/common/mod.rs</code>:</p>
<pre><code class="language-rust ">use std::io::{BufWriter, ErrorKind, Stdout};

use pie::{Context, Pie, Task};
use pie::tracker::CompositeTracker;
use pie::tracker::event::EventTracker;
use pie::tracker::writing::WritingTracker;

/// Testing tracker composed of an [`EventTracker`] for testing and stdout [`WritingTracker`] for debugging.
pub type TestTracker&lt;T&gt; = CompositeTracker&lt;EventTracker&lt;T, &lt;T as Task&gt;::Output&gt;, WritingTracker&lt;BufWriter&lt;Stdout&gt;&gt;&gt;;
pub fn test_tracker&lt;T: Task&gt;() -&gt; TestTracker&lt;T&gt; {
  CompositeTracker(EventTracker::default(), WritingTracker::with_stdout())
}

/// Testing [`Pie`] using [`TestTracker`].
pub type TestPie&lt;T&gt; = Pie&lt;T, &lt;T as Task&gt;::Output, TestTracker&lt;T&gt;&gt;;
pub fn test_pie&lt;T: Task&gt;() -&gt; TestPie&lt;T&gt; {
  TestPie::with_tracker(test_tracker())
}</code></pre>
<p>These are just types and functions to create <code>TestPie</code> instances, which are <code>Pie</code> instances using <code>CompositeTracker&lt;EventTracker, WritingTracker&gt;</code> as tracker, where the writing tracker will write to standard output.</p>
<p>Add the following to <code>pie/src/tests/common/mod.rs</code>:</p>
<pre><code class="language-rust ">/// Testing extensions for [`TestPie`].
pub trait TestPieExt&lt;T: Task&gt; {
  /// Require `task` in a new session, assert that there are no dependency check errors, then runs `test_assert_func`
  /// on the event tracker for test assertion purposes.
  fn require_then_assert(
    &amp;mut self,
    task: &amp;T,
    test_assert_func: impl FnOnce(&amp;EventTracker&lt;T, T::Output&gt;),
  ) -&gt; T::Output;

  /// Require `task` in a new session, asserts that there are no dependency check errors.
  fn require(&amp;mut self, task: &amp;T) -&gt; T::Output {
    self.require_then_assert(task, |_| {})
  }

  /// Require `task` in a new session, then assert that it is not executed.
  fn require_then_assert_no_execute(&amp;mut self, task: &amp;T) -&gt; T::Output {
    self.require_then_assert(task, |t|
      assert!(!t.any_execute_of(task), &quot;expected no execution of task {:?}, but it was executed&quot;, task),
    )
  }
  /// Require `task` in a new session, then assert that it is executed exactly once.
  fn require_then_assert_one_execute(&amp;mut self, task: &amp;T) -&gt; T::Output {
    self.require_then_assert(task, |t|
      assert!(t.one_execute_of(task), &quot;expected one execution of task {:?}, but it was not executed, or was executed more than once&quot;, task),
    )
  }
}
impl&lt;T: Task&gt; TestPieExt&lt;T&gt; for TestPie&lt;T&gt; {
  fn require_then_assert(&amp;mut self, task: &amp;T, test_assert_func: impl FnOnce(&amp;EventTracker&lt;T, T::Output&gt;)) -&gt; T::Output {
    let mut session = self.new_session();
    let output = session.require(task);
    assert!(session.dependency_check_errors().is_empty(), &quot;expected no dependency checking errors, but there are \
    dependency checking errors: {:?}&quot;, session.dependency_check_errors());
    test_assert_func(&amp;self.tracker().0);
    output
  }
}</code></pre>
<p>We define an extension trait <code>TestPieExt</code> with a <code>require_then_assert</code> method, which requires a task in a new session, asserts that there are no dependency check errors, and then gives us the opportunity to perform additional assertions via a function that gives access to <code>EventTracker</code>.
This is very convenient for integration testing, as most tests will follow the pattern of requiring a task and then asserting properties.</p>
<p>This trait also provides:</p>
<ul>
<li><code>require</code> which is <code>require_then_assert</code> without an assertion closure,</li>
<li><code>require_then_assert_no_execute</code> which after requiring asserts that the task has not been executed using <code>!t.any_execution_of(task)</code> from <code>EventTracker</code>,</li>
<li><code>require_then_assert_one_execute</code> which does the same but asserts that it has been executed exactly once.</li>
</ul>
<p>We implement <code>TestPieExt</code> for <code>TestPie</code> so that we can call <code>require_then_assert</code> on any <code>TestPie</code> instance.</p>
<details id="admonition-rust-help-extension-trait" class="admonition admonish-tip">
<summary class="admonition-title">
<p>Rust Help: Extension Trait</p>
<p><a class="admonition-anchor-link" href="#admonition-rust-help-extension-trait"></a></p>
</summary>
<div>
<p>Rust does not allow adding methods to an existing type/trait to ensure forward compatibility.
For example, if your library could add a method <code>foo</code> to <code>String</code>, but in a later Rust version the <code>String::foo</code> method would be added to the standard library, then all users of your library will run into an ambiguity and fail to compile.</p>
<p>Extension traits are a pattern in Rust where we can add methods to an existing type via a trait (typically named <code>TraitExt</code>) and an implementation of that trait for the existing type.
Because the extension trait must be imported to make the methods available to the current module, this can only cause compatibility issues if the trait is actually imported.</p>
</div>
</details>
<p>We still need to define a task for testing.
Add the following to <code>pie/src/tests/common/mod.rs</code>:</p>
<pre><code class="language-rust ">/// Testing tasks enumeration.
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub enum TestTask {
  Return(&amp;'static str),
}
impl Task for TestTask {
  type Output = Result&lt;TestOutput, ErrorKind&gt;;
  fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, _context: &amp;mut C) -&gt; Self::Output {
    match self {
      TestTask::Return(string) =&gt; Ok(string.to_string().into()),
    }
  }
}

/// [`TestTask`] output enumeration.
#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub enum TestOutput {
  String(String),
}
impl From&lt;String&gt; for TestOutput {
  fn from(value: String) -&gt; Self { Self::String(value) }
}
impl TestOutput {
  pub fn as_str(&amp;self) -&gt; &amp;str {
    match self {
      Self::String(s) =&gt; &amp;s,
    }
  }
}</code></pre>
<p>We define a <code>TestTask</code> enumeration containing all testing tasks, which for now is just a <code>Return</code> task that just returns its string, and implement <code>Task</code> for it.
The <code>Output</code> for <code>TestTask</code> is <code>Result&lt;TestOutput, ErrorKind&gt;</code> so that we can propagate IO errors in the future.</p>
<p><code>TestOutput</code> enumerates all possible outputs for <code>TestTask</code>, which for now is just a <code>String</code>.
We implement <code>From&lt;String&gt;</code> for <code>TestOutput</code> so we can easily convert <code>String</code>s into <code>TestOutput</code>. 
<code>as_str</code> performs the opposite operation.</p>
<p>Check that the code compiles with <code>cargo test</code>.</p>
<h2 id="first-integration-test"><a class="header" href="#first-integration-test">First integration test</a></h2>
<p>Now we’re ready to test incrementality and soundness of the top-down incremental context through integration tests.
Create the <code>pie/src/tests/top_down.rs</code> file and add to it:</p>
<pre><code class="language-rust ">use std::io;

use assert_matches::assert_matches;

use pie::tracker::event::*;

use crate::common::{test_pie, TestPieExt, TestTask::*};

mod common;

#[test]
fn test_execution() -&gt; Result&lt;(), io::Error&gt; {
  let mut pie = test_pie();
  let task = Return(&quot;Hello, World!&quot;);
  let output = pie.require_then_assert(&amp;task, |tracker| {
    let events = tracker.slice();
    assert_matches!(events.get(0), Some(Event::RequireTaskStart(RequireTaskStart { task: t, .. })) if t == &amp;task);
    assert_matches!(events.get(1), Some(Event::ExecuteStart(ExecuteStart { task: t, .. })) if t == &amp;task);
    assert_matches!(events.get(2), Some(Event::ExecuteEnd(ExecuteEnd { task: t, .. })) if t == &amp;task);
    assert_matches!(events.get(3), Some(Event::RequireTaskEnd(RequireTaskEnd { task: t, .. })) if t == &amp;task);
  })?;
  assert_eq!(output.as_str(), &quot;Hello, World!&quot;);
  Ok(())
}</code></pre>
<p>In this first <code>test_execution</code> test we are just making sure that new tasks are executed, assert that the order of operations is correct, and check the task output.
We use <code>require_then_assert</code> to require the task and then perform assertions through a closure.
We’re using <code>tracker.slice()</code> to get a slice of all build events, and assert (using <a href="https://docs.rs/assert_matches/latest/assert_matches/macro.assert_matches.html" title="" target="_blank">
<code>assert_matches!</code></a> again) that the following operations happen in order:</p>
<ul>
<li>start requiring <code>task</code>,</li>
<li>start executing <code>task</code>,</li>
<li>done executing <code>task</code>,</li>
<li>done requiring <code>task</code>.</li>
</ul>
<p><code>require_then_assert</code> returns the output of the task, which is a <code>Result</code>, so we first propagate the error with <code>?</code>.
Finally, we assert that the output equals what we expect.</p>
<p>Check that this test succeeds with <code>cargo test</code>.
To see what test failures look like, temporarily change <code>events.get(2)</code> to <code>events.get(3)</code> for example.</p>
<details id="admonition-rust-help-integration-testing" class="admonition admonish-tip">
<summary class="admonition-title">
<p>Rust Help: Integration Testing</p>
<p><a class="admonition-anchor-link" href="#admonition-rust-help-integration-testing"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/rust-by-example/testing/integration_testing.html" title="" target="_blank">Integration tests</a> in Rust are for testing whether the different parts of your library work together correctly.
Integration tests have access to the public API of your crate.</p>
<p>In this <code>top_down.rs</code> integration test file, we’re importing <code>common/mod.rs</code> by creating a module for it via <code>mod common;</code>.
If we create another integration testing file, we would again create a module for it in that integration testing file.
This is because every file in the <code>tests</code> directory is compiled as a separate crate, and can basically be seen as a separate <code>lib.rs</code> or <code>main.rs</code> file.</p>
<p>Putting the testing utilities behind a <code>common</code> directory ensures that it will not be compiled as a separate integration testing crate.</p>
</div>
</details>
<h2 id="testing-incrementality-and-soundness"><a class="header" href="#testing-incrementality-and-soundness">Testing incrementality and soundness</a></h2>
<p>We will now test incrementality and soundness.</p>
<h3 id="no-dependencies"><a class="header" href="#no-dependencies">No dependencies</a></h3>
<p>Let’s first test that requiring a task without dependencies twice, only executes it once.
Add the following test to <code>pie/src/tests/top_down.rs</code>:</p>
<pre><code class="language-rust ">#[test]
fn test_reuse() -&gt; Result&lt;(), io::Error&gt; {
  let mut pie = test_pie();
  let task = Return(&quot;Hello, World!&quot;);
  // New task: execute.
  let output = pie.require(&amp;task)?;
  assert_eq!(output.as_str(), &quot;Hello, World!&quot;);
  // Nothing changed: no execute
  pie.require_then_assert_no_execute(&amp;task)?;
  Ok(())
}</code></pre>
<p>We’re using <code>require</code> and <code>require_then_assert_no_execute</code> from <code>TestPieExt</code> which require the same task twice, in two different sessions.
Since <code>Return</code> has no dependencies, it should only ever be executed once, after which its output is cached for all eternity.</p>
<p>Check that this test succeeds with <code>cargo test</code>.</p>
<div id="admonition-rust-help-reading-standard-output-from-tests" class="admonition admonish-tip">
<div class="admonition-title">
<p>Rust Help: Reading Standard Output from Tests</p>
<p><a class="admonition-anchor-link" href="#admonition-rust-help-reading-standard-output-from-tests"></a></p>
</div>
<div>
<p>Cargo runs tests in parallel by default, which is good to run all tests as fast as possible (and it’s also safe due to Rust’s memory-safety and thread-safety guarantees!)
However, this mixes the standard outputs of all tests, which makes reading the build log from our writing tracker impossible.
If you want to see the standard output, either:</p>
<ul>
<li>Run tests <a href="https://doc.rust-lang.org/book/ch11-02-running-tests.html#running-tests-in-parallel-or-consecutively" title="" target="_blank">consecutively</a> with: <code>cargo test -- --test-threads=1</code></li>
<li>Run a <a href="https://doc.rust-lang.org/book/ch11-02-running-tests.html#running-single-tests" title="" target="_blank">single test</a> in the <code>top_down</code> integration test file with: <code>cargo test --test top_down test_reuse</code></li>
</ul>
<p>The second command should result in something like:</p>
<pre><code>    Finished test [unoptimized + debuginfo] target(s) in 0.02s
     Running tests/top_down.rs (/pie/target/debug/deps/top_down-feb1204e977f2147)

running 1 test
→ Return(&quot;Hello, World!&quot;)
 ▶ Return(&quot;Hello, World!&quot;)
 ◀ Ok(String(&quot;Hello, World!&quot;))
← Ok(String(&quot;Hello, World!&quot;))
🏁
→ Return(&quot;Hello, World!&quot;)
← Ok(String(&quot;Hello, World!&quot;))
🏁
test test_reuse ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s

</code></pre>
</div>
</div>
<h3 id="testing-file-dependencies"><a class="header" href="#testing-file-dependencies">Testing file dependencies</a></h3>
<p>Next we want to test that a task with dependencies is not executed if its dependencies are consistent, and is executed when any of its dependencies are inconsistent.
Therefore, we need to add a task that has dependencies.</p>
<p>Modify <code>pie/src/tests/common/mod.rs</code>:</p>
<div class="diff2html" id="diff2html_0"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/common/mod.rs
+++ pie/tests/common/mod.rs
@@ -1,6 +1,8 @@
-use std::io::{BufWriter, ErrorKind, Stdout};
+use std::io::{BufWriter, ErrorKind, Read, Stdout};
+use std::path::PathBuf;
 
 use pie::{Context, Pie, Task};
+use pie::stamp::FileStamper;
 use pie::tracker::CompositeTracker;
 use pie::tracker::event::EventTracker;
 use pie::tracker::writing::WritingTracker;
@@ -60,12 +62,20 @@
 #[derive(Clone, Eq, PartialEq, Hash, Debug)]
 pub enum TestTask {
   Return(&'static str),
+  ReadFile(PathBuf, FileStamper),
 }
 impl Task for TestTask {
   type Output = Result<TestOutput, ErrorKind>;
-  fn execute<C: Context<Self>>(&self, _context: &mut C) -> Self::Output {
+  fn execute<C: Context<Self>>(&self, context: &mut C) -> Self::Output {
     match self {
       TestTask::Return(string) => Ok(string.to_string().into()),
+      TestTask::ReadFile(path, stamper) => {
+        let mut string = String::new();
+        if let Some(mut file) = context.require_file_with_stamper(path, *stamper).map_err(|e| e.kind())? {
+          file.read_to_string(&mut string).map_err(|e| e.kind())?;
+        }
+        Ok(string.into())
+      }
     }
   }
 }
`;
    let target = document.getElementById('diff2html_0');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We add a <code>ReadFile</code> task that requires a file and returns its content as a string, similar to the ones we have implemented in the past.</p>
<p>Modify <code>pie/src/tests/top_down.rs</code> to add a new test:</p>
<div class="diff2html" id="diff2html_1"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -1,7 +1,10 @@
+use std::fs::write;
 use std::io;
 
 use assert_matches::assert_matches;
 
+use dev_shared::{create_temp_dir, write_until_modified};
+use pie::stamp::FileStamper;
 use pie::tracker::event::*;
 
 use crate::common::{test_pie, TestPieExt, TestTask::*};
@@ -34,3 +37,43 @@
   pie.require_then_assert_no_execute(&task)?;
   Ok(())
 }
+
+#[test]
+fn test_require_file() -> Result<(), io::Error> {
+  let mut pie = test_pie();
+  let temp_dir = create_temp_dir()?;
+
+  let file = temp_dir.path().join("in.txt");
+  write(&file, "HELLO WORLD!")?;
+  let task = ReadFile(file.clone(), FileStamper::Modified);
+
+  // 1) Require task and assert that it is executed because it is new.
+  let output = pie.require_then_assert_one_execute(&task)?;
+  assert_eq!(output.as_str(), "HELLO WORLD!");
+  // 2) Require task again and assert that it is not executed because its file dependency consistent.
+  let output = pie.require_then_assert_no_execute(&task)?;
+  assert_eq!(output.as_str(), "HELLO WORLD!");
+  // 3) Change required file such that the file dependency of the task becomes inconsistent.
+  write_until_modified(&file, "!DLROW OLLEH")?;
+  // 4) Require task again and assert that it is re-executed because its file dependency is inconsistent.
+  let output = pie.require_then_assert_one_execute(&task)?;
+  assert_eq!(output.as_str(), "!DLROW OLLEH");
+
+  // Repeat the test with ${"`"}FileStamper::Exists${"`"}, which results in a different outcome.
+  write(&file, "HELLO WORLD!")?;
+  let task = ReadFile(file.clone(), FileStamper::Exists);
+
+  // 1) Require task and assert that it is executed because it is new.
+  let output = pie.require_then_assert_one_execute(&task)?;
+  assert_eq!(output.as_str(), "HELLO WORLD!");
+  // 2) Require task again and assert that it is not executed because its file dependency is consistent.
+  let output = pie.require_then_assert_no_execute(&task)?;
+  assert_eq!(output.as_str(), "HELLO WORLD!");
+  // 3) Change required file, but the file dependency of the task stays consistent.
+  write_until_modified(&file, "!DLROW OLLEH")?;
+  // 4) Require task again and assert that it is not executed because its file dependency is still consistent.
+  let output = pie.require_then_assert_no_execute(&task)?;
+  assert_eq!(output.as_str(), "HELLO WORLD!");
+
+  Ok(())
+}
`;
    let target = document.getElementById('diff2html_1');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>In <code>test_require_file</code>, we first create a temporary directory and <code>file</code>, and a <code>ReadFile</code> <code>task</code> that reads from <code>file</code>.
We require the <code>task</code> task several times, and assert whether it should be executed or not:</p>
<ol>
<li>The task is new, so it should be executed, which we assert with <code>require_then_assert_one_execute</code>.</li>
<li>The task is not new, but its single require file dependency is still consistent, so it should not be executed.</li>
<li>We change the file the task depends on with <code>write_until_modified</code>.</li>
<li>We require the task again. This time it should be executed because its file dependency became inconsistent.</li>
</ol>
<p>We repeat the test with the <code>FileStamper::Exists</code> stamper, which correctly results in the task only being executed once.
It is a new task because its stamper is different, and it is not re-executed when the file is changed due to <code>FileStamper::Exists</code> only checking if the file exists.</p>
<p>Note that in general, the <code>FileStamper::Exists</code> stamper is not a good stamper to use with <code>ReadFile</code>, because it will only be re-executed when the file is added or removed.
But for testing purposes, this is fine. </p>
<p>Check that this test succeeds with <code>cargo test</code>.</p>
<h3 id="testing-task-dependencies"><a class="header" href="#testing-task-dependencies">Testing task dependencies</a></h3>
<p>Now it’s time to test the more complicated task dependencies.
For that, we’ll implement a task that depends on another task.
Modify <code>pie/src/tests/common/mod.rs</code>:</p>
<div class="diff2html" id="diff2html_2"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/common/mod.rs
+++ pie/tests/common/mod.rs
@@ -63,6 +63,7 @@
 pub enum TestTask {
   Return(&'static str),
   ReadFile(PathBuf, FileStamper),
+  ToLower(Box<TestTask>),
 }
 impl Task for TestTask {
   type Output = Result<TestOutput, ErrorKind>;
@@ -76,6 +77,10 @@
         }
         Ok(string.into())
       }
+      TestTask::ToLower(string_provider_task) => {
+        let string = context.require_task(string_provider_task)?.into_string();
+        Ok(string.to_lowercase().into())
+      }
     }
   }
 }
@@ -94,4 +99,9 @@
       Self::String(s) => &s,
     }
   }
+  pub fn into_string(self) -> String {
+    match self {
+      Self::String(s) => s,
+    }
+  }
 }
`;
    let target = document.getElementById('diff2html_2');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We add a <code>ToLower</code> task that requires another task (stored as <code>Box&lt;TestTask&gt;</code>) to get a <code>String</code>, which it then converts to lower case.
We also add the <code>into_string</code> method to <code>TestOutput</code> for conveniently getting an owned <code>String</code> from a <code>TestOutput</code>.</p>
<details id="admonition-rust-help-boxing-to-prevent-cyclic-size-calculation" class="admonition admonish-tip">
<summary class="admonition-title">
<p>Rust Help: Boxing to Prevent Cyclic Size Calculation</p>
<p><a class="admonition-anchor-link" href="#admonition-rust-help-boxing-to-prevent-cyclic-size-calculation"></a></p>
</summary>
<div>
<p>We store the string providing task as <code>Box&lt;TestTask&gt;</code> in order to prevent cyclic size calculation, which would cause <code>TestTask</code> to have an undetermined size.
This is due to several reasons:</p>
<ul>
<li>In Rust, values are stored on the stack by default. To store something on the stack, Rust needs to know its size <em>at compile-time</em>.</li>
<li>The size of an <code>enum</code> is the size of the largest variant.</li>
<li>The size of a struct is the sum of the size of the fields.</li>
</ul>
<p>If we don’t box the task, to calculate the size of the <code>ToLower</code> enum variant, we need to calculate the size of <code>TestTask</code>, which would require calculating the size of the <code>ToLower</code> variant, and so forth.
Therefore, we can’t calulate the size of <code>ToLower</code> nor <code>TestTask</code>, which is an error.</p>
<p>Boxing solves this because <code>Box&lt;TestTask&gt;</code> allocates a <code>TestTask</code> on the heap, and then creates a pointer to it.
Therefore, the size of <code>Box&lt;TestTask&gt;</code> is the size of one pointer, breaking the cycle in the size calculations.</p>
<p>Note that this explanation <a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html" title="" target="_blank">simplifies many aspects of Rust’s size calculation</a>.</p>
</div>
</details>
<p>Now add a test to <code>pie/src/tests/top_down.rs</code>: </p>
<div class="diff2html" id="diff2html_3"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -77,3 +77,16 @@
 
   Ok(())
 }
+
+#[test]
+fn test_require_task() -> Result<(), io::Error> {
+  let mut pie = test_pie();
+  let temp_dir = create_temp_dir()?;
+
+  let file = temp_dir.path().join("in.txt");
+  write(&file, "HELLO WORLD!")?;
+  let read = ReadFile(file.clone(), FileStamper::Modified);
+  let lower = ToLower(Box::new(read.clone()));
+
+  Ok(())
+}
`;
    let target = document.getElementById('diff2html_3');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>In <code>test_require_task</code>, we create a <code>read</code> task that reads from <code>file</code>, and a <code>lower</code> task that requires <code>read</code>.
In this test, we want to test three properties:</p>
<ol>
<li>When we require <code>lower</code> for the first time, it will require <code>read</code>, which will require <code>file</code>, <code>read</code> will return the contents of <code>file</code> as a string, and <code>lower</code> will turn that string into lowercase and return it. </li>
<li>When we require <code>lower</code> when <code>file</code> has not been changed, no task is executed.</li>
<li>When we require <code>lower</code> when <code>file</code>’s contents <em>have changed</em>, then first <code>read</code> must be executed, and then <code>lower</code> must be executed with the output of <code>read</code>.</li>
</ol>
<h4 id="initial-require"><a class="header" href="#initial-require">Initial require</a></h4>
<p>Test the first property by adding the following code to <code>pie/src/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_4"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -1,5 +1,6 @@
 use std::fs::write;
 use std::io;
+use std::ops::RangeInclusive;
 
 use assert_matches::assert_matches;
 
@@ -88,5 +89,56 @@
   let read = ReadFile(file.clone(), FileStamper::Modified);
   let lower = ToLower(Box::new(read.clone()));
 
+  // 1) Require ${"`"}ToLower${"`"} and assert that both tasks are executed in dependency order, because both tasks are new:
+  // → ToLower
+  //   ▶ ToLower [reason: new]
+  //     → ReadFile
+  //       ▶ ReadFile [reason: new]
+  //         - ${"`"}file${"`"}
+  //       ◀ Ok(String("HELLO WORLD!"))
+  //     ← Ok(String("HELLO WORLD!"))
+  //   ◀ Ok(String("hello world!"))
+  // ← Ok(String("hello world!"))
+  // 🏁
+  let output = pie.require_then_assert(&lower, |tracker| {
+    // ${"`"}ToLower${"`"} is required and executed, and its require and execute are temporally sound.
+    let lower_require = assert_matches!(tracker.first_require_task_range(&lower), Some(r) => r);
+    let lower_execute = assert_matches!(tracker.first_execute_range(&lower), Some(r) => r);
+    assert_task_temporally_sound(&lower_require, &lower_execute);
+
+    // ${"`"}ReadFile${"`"} is required and executed, and its require and execute are temporally sound.
+    let read_require = assert_matches!(tracker.first_require_task_range(&read), Some(r) => r);
+    let read_execute = assert_matches!(tracker.first_execute_range(&read), Some(r) => r);
+    assert_task_temporally_sound(&read_require, &read_execute);
+
+    // Sanity check: ${"`"}file${"`"} is required.
+    let file_require = assert_matches!(tracker.first_require_file_index(&file), Some(i) => i);
+
+    // ${"`"}ReadFile${"`"} is required while ${"`"}ToLower${"`"} is being required.
+    assert!(read_require.start() > lower_require.start());
+    assert!(lower_require.end() > read_require.end());
+
+    // ${"`"}ReadFile${"`"} is executed while ${"`"}ToLower${"`"} is being executed.
+    assert!(read_execute.start() > lower_execute.start());
+    assert!(lower_execute.end() > read_execute.end());
+
+    // Sanity check: ${"`"}ReadFile${"`"} requires ${"`"}file${"`"} while executing.
+    assert!(file_require > read_execute.start());
+    assert!(read_execute.end() > file_require);
+  })?;
+  assert_eq!(output.as_str(), "hello world!");
+
   Ok(())
 }
+
+/// Assert that task requires and executes are temporally sound.
+fn assert_task_temporally_sound(require: &RangeInclusive<usize>, execute: &RangeInclusive<usize>) {
+  // Require and execute ends come after require and execute starts.
+  assert!(require.end() > require.start());
+  assert!(execute.end() > execute.start());
+  // A task is only executed if it is required.
+  // - Task execute starts should be later than their requires.
+  assert!(execute.start() > require.start());
+  // - Task require ends should be later than their executes.
+  assert!(require.end() > execute.end());
+}
`;
    let target = document.getElementById('diff2html_4');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We require <code>lower</code> for the first time and then assert properties using <code>require_then_assert</code>.
The comment shows the expected build log.</p>
<p>Inside <code>require_then_assert</code> we will make extensive use of the indexes and ranges from our <code>EventTracker</code>, and use <code>assert_matches!</code> to ensure these indexes and ranges exist (i.e., return <code>Some</code>).
Ranges (<code>RangeInclusive</code>) are just the start and end indices of events, accessed with <code>.start()</code> and <code>.end()</code>.
Indices are numbers (<code>usize</code>) that we can compare using the standard <code>&gt;</code> operator.
A higher index indicates that the event happened later.</p>
<p>We get the ranges for requiring and executing the <code>lower</code> and <code>read</code> tasks, asserting that they are both required and executed.
Then we perform some sanity checks in <code>assert_task_temporally_sound</code>:</p>
<ul>
<li>Require and execute end events should come after their start events.</li>
<li>A task only starts being executed after it starts being required. If a task is executed without being required (and thus without being checked), we are breaking incrementality.</li>
<li>A task must only finish being required after it is finished being executed. If requiring a task ends before executing it, we are breaking soundness, because we are returning an inconsistent value to the requiring task.</li>
</ul>
<p>We confirm that <code>file</code> is required and get the corresponding event index into <code>file_require</code>.
Then we assert several properties:</p>
<ul>
<li><code>read</code> is required/executed while <code>lower</code> is being required/executed.
<ul>
<li>If <code>read</code> would be executed <em>after</em> <code>lower</code> finished executing, we are breaking soundness because then we would have executed <code>lower</code> without first requiring/executing its dependencies.</li>
<li>If <code>read</code> would be executed <em>before</em> <code>lower</code> started executing, we are breaking incrementality due to executing a task that was not required. In this test, we would not really break incrementality if this happened, but in general we could.</li>
</ul>
</li>
<li><code>file</code> is required while <code>read</code> is being executed. A sanity check to ensure the file dependency is made by the right task.</li>
</ul>
<p>Finally, we assert that the final output of requiring <code>lower</code> is <code>&quot;hello world!&quot;</code>, which is the contents of the file in lowercase.
Check that this test succeeds with <code>cargo test</code>.
That concludes the first property that we wanted to test!</p>
<h4 id="no-changes"><a class="header" href="#no-changes">No changes</a></h4>
<p>The second one is easier: when <code>file</code> has not changed, no task is executed.
Add the following code to <code>pie/src/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_5"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -128,6 +128,18 @@
   })?;
   assert_eq!(output.as_str(), "hello world!");
 
+  // 2) Require ${"`"}ToLower${"`"} again and assert that no tasks are executed because all dependencies are consistent:
+  // → ToLower
+  //   ? ReadFile
+  //     → ReadFile
+  //       ✓ ${"`"}file${"`"}
+  //     ← Ok(String("HELLO WORLD!"))
+  //   ✓ ReadFile
+  // ← Ok(String("hello world!"))
+  // 🏁
+  let output = pie.require_then_assert_no_execute(&lower)?;
+  assert_eq!(output.as_str(), "hello world!");
+
   Ok(())
 }
 
`;
    let target = document.getElementById('diff2html_5');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Here we change nothing and use <code>require_then_assert_no_execute</code> to assert no task is executed.
Check that this test succeeds with <code>cargo test</code>.</p>
<h4 id="changed-file-affects-task"><a class="header" href="#changed-file-affects-task">Changed file affects task</a></h4>
<p>Now we test the third property, testing soundness and incrementality after a change.
Add the following code to <code>pie/src/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_6"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -140,6 +140,47 @@
   let output = pie.require_then_assert_no_execute(&lower)?;
   assert_eq!(output.as_str(), "hello world!");
 
+  // Change ${"`"}file${"`"} such that the file dependency of ${"`"}ReadFile${"`"} becomes inconsistent.
+  write_until_modified(&file, "!DLROW OLLEH")?;
+
+  // 3) Require ${"`"}ToLower${"`"} and assert that both tasks are re-executed in reverse dependency order:
+  // → ToLower
+  //   ? ReadFile
+  //     → ReadFile
+  //       ✗ ${"`"}file${"`"} [inconsistent: modified file stamp change]
+  //       ▶ ReadFile [reason: ${"`"}file${"`"} is inconsistent due to modified file stamp change]
+  //         - ${"`"}file${"`"}
+  //       ◀ Ok(String("!DLROW OLLEH")) [note: returns a different output!]
+  //     ← Ok(String("!DLROW OLLEH"))
+  //   ✗ ReadFile [inconsistent: equals output stamp change]
+  //   ▶ ToLower [reason: ReadFile is inconsistent due to equals output stamp change]
+  //     → ReadFile
+  //     ← Ok(String("!DLROW OLLEH")) [note: skipped checking ${"`"}read${"`"} because it is already consistent this session!]
+  //   ◀ Ok(String("!dlrow olleh"))
+  // ← Ok(String("!dlrow olleh"))
+  // 🏁
+  let output = pie.require_then_assert(&lower, |tracker| {
+    // Sanity checks: ${"`"}ToLower${"`"} and ${"`"}ReadFile${"`"} are required and executed, and ${"`"}file${"`"} is required.
+    let lower_require = assert_matches!(tracker.first_require_task_range(&lower), Some(r) => r);
+    let lower_execute = assert_matches!(tracker.first_execute_range(&lower), Some(r) => r);
+    assert_task_temporally_sound(&lower_require, &lower_execute);
+    let read_require = assert_matches!(tracker.first_require_task_range(&read), Some(r) => r);
+    let read_execute = assert_matches!(tracker.first_execute_range(&read), Some(r) => r);
+    assert_task_temporally_sound(&read_require, &read_execute);
+    let file_require = assert_matches!(tracker.first_require_file_index(&file), Some(i) => i);
+
+    // Sanity check: ${"`"}ReadFile${"`"} requires ${"`"}file${"`"} while executing.
+    assert!(file_require > read_execute.start());
+    assert!(read_execute.end() > file_require);
+
+    // ${"`"}ToLower${"`"} is executed after ${"`"}ReadFile${"`"} has been executed.
+    assert!(lower_execute.start() > read_execute.end());
+    // ${"`"}ReadFile${"`"} is executed while ${"`"}ToLower${"`"} is being required.
+    assert!(read_execute.start() > lower_require.start());
+    assert!(lower_require.end() > read_execute.end());
+  })?;
+  assert_eq!(output.as_str(), "!dlrow olleh");
+
   Ok(())
 }
 
`;
    let target = document.getElementById('diff2html_6');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We first change the <code>file</code> contents such that <code>read</code>’s <code>file</code> dependency becomes inconsistent, and then require <code>lower</code> again.
In the <code>require_then_assert</code> block we first assert that both tasks are required and executed, <code>file</code> is required, and perform sanity checks again.</p>
<p>Now let’s go back to the build log in the comment, which is lot more complicated this time due to recursive consistency checking. The gist is:</p>
<ul>
<li>To check if <code>lower</code> should be executed, we check its dependencies: a task dependency to <code>read</code>.
<ul>
<li>To check if <code>read</code> should be executed, we check its dependencies: a <code>file</code> dependency, which is inconsistent, thus we execute <code>read</code>.</li>
<li><code>read</code> executes and now returns <code>&quot;!DLROW OLLEH&quot;</code> instead of <code>&quot;HELLO WORLD!&quot;</code>.</li>
</ul>
</li>
<li>Then we are back to checking <code>lower</code>’s task dependency to <code>read</code>, which is inconsistent because <code>read</code> returns a different value, which is inconsistent due to the equals output stamper. </li>
<li>Thus, we execute <code>lower</code> which requires <code>read</code>.</li>
<li>We can skip checking <code>read</code> because we already checked and executed it: it is deemed consistent this session. We immediately return its output <code>&quot;!DLROW OLLEH&quot;</code> to <code>lower</code>.</li>
<li><code>lower</code> turns the string lowercase and returns it.</li>
</ul>
<p>Note that we are executing <code>read</code> <em>before</em> executing <code>lower</code> this time (but still <em>while requiring</em> <code>lower</code>).
This is important for incrementality because if <code>read</code> had not returned a different output, we would not have to execute <code>lower</code> due to its equals output stamp still being consistent (we call this <em>early cutoff</em>).
We test this property with the last 3 assertions in the <code>require_then_assert</code> block.</p>
<p>Finally, we assert that the output is <code>&quot;!dlrow olleh&quot;</code> as expected.
Confirm that this test succeeds with <code>cargo test</code>.</p>
<p>Now that we’re testing task dependencies anyway, let’s also test a fourth property: the early cutoff behaviour.</p>
<h4 id="early-cutoff"><a class="header" href="#early-cutoff">Early cutoff</a></h4>
<p>Early cutoff can happen in this test when <code>read</code> is re-executed due to its file dependency being inconsistent (modified file stamp change), but returns the same output as last time.
In that case, we don’t have to execute <code>lower</code> because its task dependency to <code>read</code> is still consistent (equals output stamp is the same).
We can trigger this case in this test by changing <code>file</code> such that its last modified date changes, but its contents stay the same.</p>
<p>Add the following code to <code>pie/src/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_7"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -181,6 +181,17 @@
   })?;
   assert_eq!(output.as_str(), "!dlrow olleh");
 
+  // Change ${"`"}file${"`"} such that the file dependency of ${"`"}ReadFile${"`"} becomes inconsistent, but still has the same content.
+  write_until_modified(&file, "!DLROW OLLEH")?;
+
+  let output = pie.require_then_assert(&lower, |tracker| {
+    // ${"`"}ReadFile${"`"} needs to be executed due to its ${"`"}file${"`"} dependency being inconsistent (modified stamp changed).
+    assert!(tracker.one_execute_of(&read));
+    // ${"`"}ToLower${"`"} is not executed, because its task dependency to ${"`"}ReadFile${"`"} is consistent (equals stamp is the same).
+    assert!(!tracker.any_execute_of(&lower));
+  })?;
+  assert_eq!(output.as_str(), "!dlrow olleh");
+
   Ok(())
 }
 
`;
    let target = document.getElementById('diff2html_7');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We change <code>file</code> in the way we discussed, and then assert that <code>read</code> is executed, but <code>lower</code> is not.
Confirm that this test succeeds with <code>cargo test</code>.</p>
<div id="admonition-benefits-of-early-cutoff" class="admonition admonish-info">
<div class="admonition-title">
<p>Benefits of Early Cutoff</p>
<p><a class="admonition-anchor-link" href="#admonition-benefits-of-early-cutoff"></a></p>
</div>
<div>
<p>Early cutoff is one of the great benefits of a build system with precise dynamic dependencies.
In larger builds, it can cut off large parts of the build which do not need to be executed.</p>
<p>In our build system, we only have the simple equals output stamper.
But if you extend the build system with user-defined stampers (which isn’t too hard), task authors have much more control over early cutoff.
For example, we could require a task that parses a configuration file, but use a stamper that extracts only the particular configuration option our task is using.
Then, our task will only be re-executed if that configuration option changes.</p>
<p>Thus, stampers can increase the precision of task dependencies, which in turn increases incrementality with early cutoff.</p>
</div>
</div>
<p>Nice! These tests give quite some confidence that what we’ve been doing so far seems to be sound and incremental.
We can (and should) of course write more tests for better coverage of the implementation.
For example, we haven’t tested tasks with multiple dependencies yet.
However, in this tutorial we will move on to a couple of specific tests first, because there are several issues still hiding in our implementation: (at least) one bug, and three soundness holes.
After we’ve uncovered those issues and fix them, feel free to write more tests yourself!</p>
<details id="admonition-download-source-code" class="admonition admonish-example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="../../gen/3_min_sound/3_test/source.zip">download the source files up to this point</a>.</p>
</div>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../3_min_sound/2_tracker/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../3_min_sound/4_fix_task_dep/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../3_min_sound/2_tracker/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../3_min_sound/4_fix_task_dep/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../.././diff2html-ui-base.min.js"></script>


    </div>
    </body>
</html>
