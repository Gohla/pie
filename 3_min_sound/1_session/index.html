<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Minimality with Sessions - Build your own Programmatic Incremental Build System</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../.././diff2html.min.css">
        <link rel="stylesheet" href="../.././mdbook-admonish.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../0_intro/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../0_intro/1_setup/index.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li></ol></li><li class="chapter-item expanded "><a href="../../1_programmability/index.html"><strong aria-hidden="true">2.</strong> Programmability</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../1_programmability/1_api/index.html"><strong aria-hidden="true">2.1.</strong> Programmable Build System API</a></li><li class="chapter-item expanded "><a href="../../1_programmability/2_non_incremental/index.html"><strong aria-hidden="true">2.2.</strong> Non-Incremental Context</a></li></ol></li><li class="chapter-item expanded "><a href="../../2_incrementality/index.html"><strong aria-hidden="true">3.</strong> Incrementality</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../2_incrementality/1_require_file/index.html"><strong aria-hidden="true">3.1.</strong> Requiring Files</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/2_stamp/index.html"><strong aria-hidden="true">3.2.</strong> Stamps</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/3_dependency/index.html"><strong aria-hidden="true">3.3.</strong> Dynamic Dependencies</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/4_store/index.html"><strong aria-hidden="true">3.4.</strong> Dependency Graph Store</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/5_context/index.html"><strong aria-hidden="true">3.5.</strong> Incremental Top-Down Context</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/6_example/index.html"><strong aria-hidden="true">3.6.</strong> Incrementality Example</a></li></ol></li><li class="chapter-item expanded "><a href="../../3_min_sound/index.html"><strong aria-hidden="true">4.</strong> Testing Incrementality & Soundness</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../3_min_sound/1_session/index.html" class="active"><strong aria-hidden="true">4.1.</strong> Minimality with Sessions</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/2_tracker/index.html"><strong aria-hidden="true">4.2.</strong> Tracking Build Events</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/3_test/index.html"><strong aria-hidden="true">4.3.</strong> Integration Testing</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/4_fix_task_dep/index.html"><strong aria-hidden="true">4.4.</strong> Fix Superfluous Task Dependency</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/5_overlap/index.html"><strong aria-hidden="true">4.5.</strong> Prevent Overlapping File Writes</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/6_hidden_dep/index.html"><strong aria-hidden="true">4.6.</strong> Prevent Hidden Dependencies</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/7_cycle/index.html"><strong aria-hidden="true">4.7.</strong> Prevent Cycles</a></li></ol></li><li class="chapter-item expanded "><a href="../../4_next/index.html"><strong aria-hidden="true">5.</strong> What's Next?</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
<!-- CHANGE: removed all but light and ayu theme, and renamed ayu to dark -->                          
<!--                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>-->
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/edit/master/tutorial/src/3_min_sound/1_session/index.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="minimality-with-sessions"><a class="header" href="#minimality-with-sessions">Minimality with Sessions</a></h1>
<p>A task is consistent if its dependencies are consistent, and consistency of file dependencies is based on the filesystem.
However, the filesystem can change during a build, meaning that a task can be affected by multiple different changes in one build.
For example, after executing a task, it could immediately be affected by a change in a source file again without the build system knowing about it, and that would not be minimal nor sound.</p>
<p>Therefore, we will introduce the concept of a <em>session</em>.
Builds are only performed in a session, and at most one session may exist at any given time.
In one session, each task is checked or executed <em>at most once</em>, meaning that changes made to source files during a session are <em>not guaranteed to be detected</em>.</p>
<p>The result is that if a task is deemed inconsistent at the time it is checked, it will be executed, and will not be checked nor executed any more that session.
If a task is deemed consistent at the time it is checked, it will not be checked any more that session.
This simplifies minimality and soundness, as we do not need to worry about checking tasks multiple times.
Furthermore, it is also an optimisation, as requiring the same task many times only results in one check.</p>
<p>We will continue as follows:</p>
<ol>
<li>Create the <code>Session</code> type to hold all session data, and the <code>Pie</code> type as an entry point into the build system that manages a session.</li>
<li>Update <code>TopDownContext</code> to work with <code>Session</code>.</li>
<li>Update the incrementality example to work with <code>Session</code> and <code>Pie</code>.</li>
<li>Ensure minimality by keeping track whether a task has been required this session.</li>
</ol>
<h2 id="pie-and-session"><a class="header" href="#pie-and-session">PIE and Session</a></h2>
<p>Change the imports in <code>pie/src/lib.rs</code>: </p>
<div class="diff2html" id="diff2html_0"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -6,6 +6,9 @@
 
 use stamp::{FileStamper, OutputStamper};
 
+use crate::context::top_down::TopDownContext;
+use crate::store::{Store, TaskNode};
+
 pub mod stamp;
 pub mod dependency;
 pub mod context;
`;
    let target = document.getElementById('diff2html_0');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Now add the <code>Pie</code> and <code>Session</code> types to <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust ">/// Main entry point into PIE, a sound and incremental programmatic build system.
pub struct Pie&lt;T, O&gt; {
  store: Store&lt;T, O&gt;,
}

impl&lt;T: Task&gt; Default for Pie&lt;T, T::Output&gt; {
  fn default() -&gt; Self { Self { store: Store::default() } }
}

impl&lt;T: Task&gt; Pie&lt;T, T::Output&gt; {
  /// Creates a new build session. Only one session may be active at once, enforced via mutable (exclusive) borrow.
  pub fn new_session(&amp;mut self) -&gt; Session&lt;T, T::Output&gt; { Session::new(self) }
  /// Runs `f` inside a new build session.
  pub fn run_in_session&lt;R&gt;(&amp;mut self, f: impl FnOnce(Session&lt;T, T::Output&gt;) -&gt; R) -&gt; R {
    let session = self.new_session();
    f(session)
  }
}

/// A session in which builds are executed.
pub struct Session&lt;'p, T, O&gt; {
  store: &amp;'p mut Store&lt;T, O&gt;,
  current_executing_task: Option&lt;TaskNode&gt;,
  dependency_check_errors: Vec&lt;io::Error&gt;,
}

impl&lt;'p, T: Task&gt; Session&lt;'p, T, T::Output&gt; {
  fn new(pie: &amp;'p mut Pie&lt;T, T::Output&gt;) -&gt; Self {
    Self {
      store: &amp;mut pie.store,
      current_executing_task: None,
      dependency_check_errors: Vec::default(),
    }
  }

  /// Requires `task`, returning its up-to-date output.
  pub fn require(&amp;mut self, task: &amp;T) -&gt; T::Output {
    todo!(&quot;Create TopDownContext with this session, and require the task&quot;)
  }

  /// Gets all errors produced during dependency checks.
  pub fn dependency_check_errors(&amp;self) -&gt; &amp;[io::Error] { &amp;self.dependency_check_errors }
}</code></pre>
<p>We set up the types such that <code>Pie</code> owns the store, and <code>Session</code> owns all data for a build session that <code>TopDownContext</code> previously owned.
We put the store in <code>Pie</code> because we want to keep the dependency graph and task outputs between build sessions, otherwise we cannot be incremental.</p>
<p>A <code>Session</code> is created with <code>Pie::new_session</code>, which borrows <code>Pie</code> mutibly, ensuring that there can only be one <code>Session</code> instance (per <code>Pie</code> instance).
<code>run_in_session</code> is a convenience method that runs given function inside a new session.</p>
<p><code>Session::require</code> should require the task with the top-down context and return its up-to-date output, which we will implement once we’ve changed <code>TopDownContext</code>.
The dependency check errors can be accessed with <code>Session::dependency_check_errors</code>.</p>
<p>Note that <code>Session</code> also has access to <code>Store</code>, because <code>TopDownContext</code> needs access to the store.
The store is mutibly borrowed from <code>Pie</code>.
Therefore, the <code>Session</code> struct is generic over the <code>'p</code> lifetime, where the <code>p</code> stands for <code>Pie</code>.
We can leave out this lifetime in <code>Pie::new_session</code>, because the compiler infers it from us, but we must be explicit in structs and most impls.</p>
<p>Check that the code compiles (but gives warnings) with <code>cargo check</code>.</p>
<p>Now we need to modify <code>TopDownContext</code> to work with <code>Session</code>.</p>
<h2 id="update-topdowncontext"><a class="header" href="#update-topdowncontext">Update TopDownContext</a></h2>
<p>Change <code>TopDownContext</code> to only contain a mutable reference to <code>Session</code> in <code>pie/src/context/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_1"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -2,28 +2,20 @@
 use std::io;
 use std::path::Path;
 
-use crate::{Context, fs, Task};
+use crate::{Context, fs, Session, Task};
 use crate::dependency::{FileDependency, TaskDependency};
 use crate::stamp::{FileStamper, OutputStamper};
-use crate::store::{Store, TaskNode};
+use crate::store::TaskNode;
 
-pub struct TopDownContext<T, O> {
-  store: Store<T, O>,
-  current_executing_task: Option<TaskNode>,
-  dependency_check_errors: Vec<io::Error>,
+pub struct TopDownContext<'p, 's, T, O> {
+  session: &'s mut Session<'p, T, O>,
 }
 
-impl<T: Task> TopDownContext<T, T::Output> {
-  pub fn new() -> Self {
-    Self {
-      store: Store::default(),
-      current_executing_task: None,
-      dependency_check_errors: Vec::default(),
-    }
-  }
+impl<'p, 's, T: Task> TopDownContext<'p, 's, T, T::Output> {
+  pub fn new(session: &'s mut Session<'p, T, T::Output>) -> Self { Self { session } }
 
-  pub fn get_dependency_check_errors(&self) -> impl Iterator<Item=&io::Error> {
-    self.dependency_check_errors.iter()
+  pub fn require_initial(&mut self, task: &T) -> T::Output {
+    self.require_task(task)
   }
 }
 
`;
    let target = document.getElementById('diff2html_1');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Here, we use lifetime <code>'s</code> to denote the lifetime of a session, and make <code>TopDownContext</code> generic over it.
<code>new</code> now just accepts a mutable reference to the session.
The <code>get_dependency_check_errors</code> method can be removed.
We add a <code>require_initial</code> convenience method for <code>Session</code>.</p>
<p>In the rest of the file, we need to update the <code>impl</code> lines to include the lifetimes, and we need to replace most instances of <code>self</code> with <code>self.session</code>.
You could do this with the following find-replace regex: <code>self\.([\w\d_]+)\.</code> -&gt; <code>self.session.$1.</code></p>
<p>Change <code>pie/src/context/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_2"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -19,40 +19,40 @@
   }
 }
 
-impl<T: Task> Context<T> for TopDownContext<T, T::Output> {
+impl<'p, 's, T: Task> Context<T> for TopDownContext<'p, 's, T, T::Output> {
   fn require_file_with_stamper<P: AsRef<Path>>(&mut self, path: P, stamper: FileStamper) -> Result<Option<File>, io::Error> {
-    let Some(current_executing_task_node) = &self.current_executing_task else {
+    let Some(current_executing_task_node) = &self.session.current_executing_task else {
       return fs::open_if_file(path); // No current executing task, so no dependency needs to be made.
     };
     let path = path.as_ref();
-    let node = self.store.get_or_create_file_node(path);
+    let node = self.session.store.get_or_create_file_node(path);
     let (dependency, file) = FileDependency::new_with_file(path, stamper)?;
-    self.store.add_file_require_dependency(current_executing_task_node, &node, dependency);
+    self.session.store.add_file_require_dependency(current_executing_task_node, &node, dependency);
     Ok(file)
   }
 
   fn require_task_with_stamper(&mut self, task: &T, stamper: OutputStamper) -> T::Output {
-    let node = self.store.get_or_create_task_node(task);
+    let node = self.session.store.get_or_create_task_node(task);
 
     // Get required task output by executing it if needed, or by getting the output from the store if not needed.
     let output = if self.should_execute_task(&node) {
-      self.store.reset_task(&node);
-      let previous_executing_task = self.current_executing_task.replace(node);
+      self.session.store.reset_task(&node);
+      let previous_executing_task = self.session.current_executing_task.replace(node);
       let output = task.execute(self);
-      self.current_executing_task = previous_executing_task;
-      self.store.set_task_output(&node, output.clone());
+      self.session.current_executing_task = previous_executing_task;
+      self.session.store.set_task_output(&node, output.clone());
       output
     } else {
       // Correctness: when ${"`"}should_execute_task${"`"} returns ${"`"}true${"`"}, the above block is executed. Otherwise this block is
       // executed and ${"`"}should_execute_task${"`"} ensures that the task has an output.
-      self.store.get_task_output(&node).clone()
+      self.session.store.get_task_output(&node).clone()
     };
 
     // Create task require dependency if a task is currently executing (i.e., we are not requiring the initial task).
-    if let Some(current_executing_task_node) = &self.current_executing_task {
+    if let Some(current_executing_task_node) = &self.session.current_executing_task {
       let dependency = TaskDependency::new(task.clone(), stamper, output.clone());
-      if self.store.add_task_require_dependency(current_executing_task_node, &node, dependency).is_err() {
-        let current_executing_task = self.store.get_task(current_executing_task_node);
+      if self.session.store.add_task_require_dependency(current_executing_task_node, &node, dependency).is_err() {
+        let current_executing_task = self.session.store.get_task(current_executing_task_node);
         panic!("Cyclic task dependency; current executing task '{:?}' is requiring task '{:?}' which was already required", current_executing_task, task);
       }
     }
@@ -61,19 +61,19 @@
   }
 }
 
-impl<T: Task> TopDownContext<T, T::Output> {
+impl<'p, 's, T: Task> TopDownContext<'p, 's, T, T::Output> {
   /// Checks whether given task should be executed, returning ${"`"}true${"`"} if it should be executed. A task should be executed
   /// if any of its dependencies are inconsistent, or when it has no output.
   fn should_execute_task(&mut self, node: &TaskNode) -> bool {
     // Borrow: because we pass ${"`"}self${"`"} (which is ${"`"}&mut self${"`"}) to ${"`"}is_inconsistent${"`"} for recursive consistency checking,
     //         we need to clone and collect dependencies into a ${"`"}Vec${"`"}. Otherwise we have an immutable borrow of ${"`"}self${"`"}
     //         through ${"`"}self.store${"`"} while we create a mutable borrow of ${"`"}self${"`"}, which is not allowed.
-    let dependencies: Vec<_> = self.store.get_dependencies_of_task(node).cloned().collect();
+    let dependencies: Vec<_> = self.session.store.get_dependencies_of_task(node).cloned().collect();
     for dependency in dependencies {
       match dependency.is_inconsistent(self) {
         Ok(Some(_)) => return true,
         Err(e) => { // Error while checking: store error and assume inconsistent
-          self.dependency_check_errors.push(e);
+          self.session.dependency_check_errors.push(e);
           return true;
         }
         _ => {} // Consistent: continue checking
@@ -81,6 +81,6 @@
     }
     // Task has no dependencies or all dependencies are consistent. Should only execute if it has no output, meaning
     // that it has never been executed before.
-    return !self.store.task_has_output(node);
+    return !self.session.store.task_has_output(node);
   }
 }
`;
    let target = document.getElementById('diff2html_2');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Now we change <code>Session</code> to use <code>TopDownContext</code>. </p>
<h2 id="update-session"><a class="header" href="#update-session">Update Session</a></h2>
<p>Change <code>pie/src/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_3"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -95,7 +95,8 @@
 
   /// Requires ${"`"}task${"`"}, returning its up-to-date output.
   pub fn require(&mut self, task: &T) -> T::Output {
-    todo!("Create TopDownContext with this session, and require the task")
+    self.current_executing_task = None;
+    TopDownContext::new(self).require_initial(task)
   }
 
   /// Gets all errors produced during dependency checks.
`;
    let target = document.getElementById('diff2html_3');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We reset the <code>current_executing_task</code> to <code>None</code>, to be sure that we start a build without an executing task.
Then, we just create a <code>TopDownContext</code> and call <code>require_initial</code>.</p>
<p>Finally, we can now make the <code>context</code> module private, as users of the library run builds using <code>Session</code>, instead of having to create a context implementation.
Change <code>pie/src/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_4"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -11,7 +11,7 @@
 
 pub mod stamp;
 pub mod dependency;
-pub mod context;
+mod context;
 mod fs;
 mod store;
 
`;
    let target = document.getElementById('diff2html_4');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Check that the code compiles with <code>cargo check --lib</code>.
This only checks if the library builds, but not any examples.
We need to update the incrementality example to work with these changes.</p>
<h2 id="update-incremental-example"><a class="header" href="#update-incremental-example">Update incremental example</a></h2>
<p>Change <code>pie/examples/incremental.rs</code> to use sessions:</p>
<div class="diff2html" id="diff2html_5"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/examples/incremental.rs
+++ pie/examples/incremental.rs
@@ -1,11 +1,8 @@
-#![allow(unused_imports, unused_variables)]
-
 use std::io::{self, Read};
 use std::path::{Path, PathBuf};
 
 use dev_shared::{create_temp_dir, write_until_modified};
-use pie::{Context, Task};
-use pie::context::top_down::TopDownContext;
+use pie::{Context, Pie, Task};
 use pie::stamp::FileStamper;
 
 /// Task that reads a string from a file.
@@ -38,24 +35,24 @@
   let input_file = temp_dir.path().join("input.txt");
   write_until_modified(&input_file, "Hi")?;
 
-  let mut context = TopDownContext::new();
+  let mut pie = Pie::default();
   let read_task = ReadStringFromFile::new(&input_file, FileStamper::Modified);
 
   println!("A) New task: expect ${"`"}read_task${"`"} to execute");
   // ${"`"}read_task${"`"} is new, meaning that we have no cached output for it, thus it must be executed.
-  let output = context.require_task(&read_task)?;
+  let output = pie.new_session().require(&read_task)?;
   assert_eq!(&output, "Hi");
 
   println!("\nB) Reuse: expect no execution");
   // ${"`"}read_task${"`"} is not new and its file dependency is still consistent. It is consistent because the modified time of
   // ${"`"}input_file${"`"} has not changed, thus the modified stamp is equal.
-  let output = context.require_task(&read_task)?;
+  let output = pie.new_session().require(&read_task)?;
   assert_eq!(&output, "Hi");
 
   write_until_modified(&input_file, "Hello")?;
   println!("\nC) Inconsistent file dependency: expect ${"`"}read_task${"`"} to execute");
   // The file dependency of ${"`"}read_task${"`"} is inconsistent due to the changed modified time of ${"`"}input_file${"`"}.
-  let output = context.require_task(&read_task)?;
+  let output = pie.new_session().require(&read_task)?;
   assert_eq!(&output, "Hello");
 
   let input_file_b = temp_dir.path().join("input_b.txt");
@@ -66,9 +63,10 @@
   // Task ${"`"}read_task${"`"}, ${"`"}read_task_b_modified${"`"} and ${"`"}read_task_b_exists${"`"} are different, due to their ${"`"}Eq${"`"} implementation
   // determining that their paths and stampers are different. Therefore, ${"`"}read_task_b_modified${"`"} and ${"`"}read_task_b_exists${"`"}
   // are new tasks, and must be executed.
-  let output = context.require_task(&read_task_b_modified)?;
+  let mut session = pie.new_session();
+  let output = session.require(&read_task_b_modified)?;
   assert_eq!(&output, "Test");
-  let output = context.require_task(&read_task_b_exists)?;
+  let output = session.require(&read_task_b_exists)?;
   assert_eq!(&output, "Test");
 
   write_until_modified(&input_file_b, "Test Test")?;
@@ -80,9 +78,10 @@
   //
   // Note that using an ${"`"}Exists${"`"} stamper for this task does not make a lot of sense, since it will only read the file
   // on first execute and when it is recreated. But this is just to demonstrate different stampers.
-  let output = context.require_task(&read_task_b_modified)?;
+  let mut session = pie.new_session();
+  let output = session.require(&read_task_b_modified)?;
   assert_eq!(&output, "Test Test");
-  let output = context.require_task(&read_task_b_exists)?;
+  let output = session.require(&read_task_b_exists)?;
   assert_eq!(&output, "Test");
 
   Ok(())
`;
    let target = document.getElementById('diff2html_5');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>When we only require one task, we replace <code>context.require_task</code> with <code>pie.new_session().require</code>.
When we want to require multiple tasks, we use <code>new_session</code> and call <code>session.require</code> multiple times.</p>
<p>It is very important to create a new session each time in this example, because a task is only checked/executed once each session.
If we use a single session, our changes are never seen, and we just execute each task once, which is not what we want.
Therefore, every time we make changes to source files, or expect that changes have been made to source files, we must create a new session.</p>
<div id="admonition-multiple-sessions" class="admonition admonish-question">
<div class="admonition-title">
<p>Multiple Sessions?</p>
<p><a class="admonition-anchor-link" href="#admonition-multiple-sessions"></a></p>
</div>
<div>
<p>In changes D and E, Rust is smart enough to allow creating a new session even though the previous <code>session</code> variable is still active, because it knows that we don’t use that previous session anymore.</p>
</div>
</div>
<p>Check that the example works with <code>cargo run --example incremental</code>, and check that the rest of the code works by running <code>cargo test</code>.</p>
<h2 id="minimality"><a class="header" href="#minimality">Minimality</a></h2>
<p>Now we can ensure minimality by keeping track whether a task has been required this session.
Change <code>pie/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_6"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -1,3 +1,4 @@
+use std::collections::HashSet;
 use std::fmt::Debug;
 use std::fs::File;
 use std::hash::Hash;
@@ -81,6 +82,7 @@
 pub struct Session<'p, T, O> {
   store: &'p mut Store<T, O>,
   current_executing_task: Option<TaskNode>,
+  consistent: HashSet<TaskNode>,
   dependency_check_errors: Vec<io::Error>,
 }
 
@@ -89,6 +91,7 @@
     Self {
       store: &mut pie.store,
       current_executing_task: None,
+      consistent: HashSet::default(),
       dependency_check_errors: Vec::default(),
     }
   }
`;
    let target = document.getElementById('diff2html_6');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We add the <code>consistent</code> field to <code>Session</code> which is a hash set over task nodes.
We create a new one each session, because we only want to keep track of which tasks are consistent on a per-session basis.</p>
<p>Now change the top-down context in <code>pie/context/top_down.rs</code> to use this:</p>
<div class="diff2html" id="diff2html_7"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -35,7 +35,8 @@
     let node = self.session.store.get_or_create_task_node(task);
 
     // Get required task output by executing it if needed, or by getting the output from the store if not needed.
-    let output = if self.should_execute_task(&node) {
+    let already_consistent = self.session.consistent.contains(&node);
+    let output = if !already_consistent && self.should_execute_task(&node) {
       self.session.store.reset_task(&node);
       let previous_executing_task = self.session.current_executing_task.replace(node);
       let output = task.execute(self);
@@ -57,6 +58,7 @@
       }
     }
 
+    self.session.consistent.insert(node);
     output
   }
 }
`;
    let target = document.getElementById('diff2html_7');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>At the start of requiring a task, we check whether the task is already deemed consistent this session, using the <code>consistent</code> hash set in <code>Session</code>.
If the task is consistent, we skip execution by using <code>!already_consistent &amp;&amp;</code> in the if check.
Because <code>&amp;&amp;</code> is <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#lazy-boolean-operators" title="" target="_blank">short-circuiting (also called lazy)</a>, we even skip the entire <code>should_execute</code> call that checks whether we should execute a task, when the task is already consistent.
This increases performance when a lot of consistent tasks are required.</p>
<p>Finally, at the end of <code>require</code>, we insert the task node into the <code>consistent</code> hash set, to denote that the task is now consistent this session.
That’s it! This was a simple change due to the work we did before to get the <code>Session</code> API in place.</p>
<p>With this new API in place, minimality of task checking and execution in place, and all code adjusted to work with it, we can continue with tracking build events.</p>
<details id="admonition-download-source-code" class="admonition admonish-example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="../../gen/3_min_sound/1_session/source.zip">download the source files up to this point</a>.</p>
</div>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../3_min_sound/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../3_min_sound/2_tracker/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../3_min_sound/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../3_min_sound/2_tracker/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../.././diff2html-ui-base.min.js"></script>


    </div>
    </body>
</html>
