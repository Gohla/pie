<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Minimality with Sessions - Build your own Programmatic Incremental Build System</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../src/mdbook-admonish.css">
        <link rel="stylesheet" href="../../src/diff2html.min.css">
        <link rel="stylesheet" href="../../src/custom.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Introduction</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Programmability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../1_programmability/0_setup/index.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../../1_programmability/1_api/index.html"><strong aria-hidden="true">2.2.</strong> Programmable Build System API</a></li><li class="chapter-item expanded "><a href="../../1_programmability/2_non_incremental/index.html"><strong aria-hidden="true">2.3.</strong> Non-Incremental Context</a></li></ol></li><li class="chapter-item expanded "><a href="../../2_incrementality/index.html"><strong aria-hidden="true">3.</strong> Incrementality</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../2_incrementality/1_require_file/index.html"><strong aria-hidden="true">3.1.</strong> Requiring Files</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/2_stamp/index.html"><strong aria-hidden="true">3.2.</strong> Stamps</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/3_dependency/index.html"><strong aria-hidden="true">3.3.</strong> Dynamic Dependencies</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/4_store/index.html"><strong aria-hidden="true">3.4.</strong> Dependency Graph Store</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/5_context/index.html"><strong aria-hidden="true">3.5.</strong> Incremental Top-Down Context</a></li></ol></li><li class="chapter-item expanded "><a href="../../3_min_sound/index.html"><strong aria-hidden="true">4.</strong> Minimality and Soundness</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../3_min_sound/1_session/index.html" class="active"><strong aria-hidden="true">4.1.</strong> Minimality with Sessions</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/2_tracker/index.html"><strong aria-hidden="true">4.2.</strong> Tracking Build Events</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Prevent Overlapping File Writes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> Prevent Hidden Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> Prevent Cycles</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Improvements</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Serialization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> More Stampers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Configurable Hashing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Efficiency</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Incremental Bottom-Up Context</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Observability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Deferred Tasks</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Multiple Task Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> On Static Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> On Declarativity</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Related Work</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/edit/master/tutorial/src/3_min_sound/1_session/index.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="minimality-with-sessions"><a class="header" href="#minimality-with-sessions">Minimality with Sessions</a></h1>
<p>A task is consistent if its dependencies are consistent, and consistency of file dependencies is based on the filesystem.
However, the filesystem can change during a build, meaning that a task can be affected by multiple different changes in one build.
For example, after executing a task, it could immediately be affected by a change in a source file again without the build system knowing about it, and that would not be minimal nor sound.</p>
<p>Therefore, we will introduce the concept of a <em>session</em>.
Builds are only performed in a session, and at most one session may exist at any given time.
In one session, each task is checked or executed <em>at most once</em>, meaning that changes made to source files during a session are <em>not guaranteed to be detected</em>.</p>
<p>The result is that if a task is deemed inconsistent at the time it is checked, it will be executed, and will not be checked nor executed any more that session.
If a task is deemed consistent at the time it is checked, it will not be checked any more that session.
This simplifies minimality and soundness, as we do not need to worry about checking tasks multiple times.
Furthermore, it is also an optimisation, as requiring the same task many times only results in one check.</p>
<p>We will implement the <code>Session</code> type to hold all session data, and the <code>Pie</code> type as an entry point into the build system that manages a session.</p>
<h2 id="pie-and-session"><a class="header" href="#pie-and-session">PIE and Session</a></h2>
<p>Change the imports in <code>pie/src/lib.rs</code>: </p>
<pre><code class="language-rust customdiff "> 
 use stamp::{FileStamper, OutputStamper};
 
+use crate::context::top_down::TopDownContext;
+use crate::store::{Store, TaskNode};
+
 pub mod stamp;
 pub mod context;
 mod fs;</code></pre>
<p>Now add the <code>Pie</code> and <code>Session</code> types to <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust ">/// Main entry point into PIE, a sound and incremental programmatic build system.
pub struct Pie&lt;T, O&gt; {
  store: Store&lt;T, O&gt;,
}

impl&lt;T: Task&gt; Default for Pie&lt;T, T::Output&gt; {
  fn default() -&gt; Self { Self { store: Store::default() } }
}

impl&lt;T: Task&gt; Pie&lt;T, T::Output&gt; {
  /// Creates a new build session. Only one session may be active at once, enforced via mutable (exclusive) borrow.
  pub fn new_session(&amp;mut self) -&gt; Session&lt;T, T::Output&gt; { Session::new(self) }
  /// Runs `f` inside a new build session.
  pub fn run_in_session&lt;R&gt;(&amp;mut self, f: impl FnOnce(Session&lt;T, T::Output&gt;) -&gt; R) -&gt; R {
    let session = self.new_session();
    f(session)
  }
}

/// A session in which builds are executed.
pub struct Session&lt;'p, T, O&gt; {
  store: &amp;'p mut Store&lt;T, O&gt;,
  current_executing_task: Option&lt;TaskNode&gt;,
  dependency_check_errors: Vec&lt;io::Error&gt;,
}

impl&lt;'p, T: Task&gt; Session&lt;'p, T, T::Output&gt; {
  fn new(pie: &amp;'p mut Pie&lt;T, T::Output&gt;) -&gt; Self {
    Self {
      store: &amp;mut pie.store,
      current_executing_task: None,
      dependency_check_errors: Vec::default(),
    }
  }

  /// Requires `task`, returning its up-to-date output.
  pub fn require(&amp;mut self, task: &amp;T) -&gt; T::Output {
    todo!(&quot;Create TopDownContext with this session, and require the task&quot;)
  }

  /// Gets all errors produced during dependency checks.
  pub fn dependency_check_errors(&amp;self) -&gt; impl Iterator&lt;Item=&amp;io::Error&gt; { self.dependency_check_errors.iter() }
}</code></pre>
<p>We set up the types such that <code>Pie</code> owns the store, and <code>Session</code> owns all data for a build session that <code>TopDownContext</code> previously owned.
We put the store in <code>Pie</code> because we want to keep the dependency graph and task outputs between build sessions, otherwise we cannot be incremental.</p>
<p>A <code>Session</code> is created with <code>Pie::new_session</code>, which borrows <code>Pie</code> mutibly, ensuring that there can only be one <code>Session</code> instance (per <code>Pie</code> instance).
<code>run_in_session</code> is a convenience method that runs given function inside a new session.</p>
<p><code>Session::require</code> should require the task with the top-down context and return its up-to-date output, which we will implement once we've changed <code>TopDownContext</code>.
The dependency check errors can be accessed with <code>Session::dependency_check_errors</code>.</p>
<p>Note that <code>Session</code> also has access to <code>Store</code>, because <code>TopDownContext</code> needs access to the store.
The store is mutibly borrowed from <code>Pie</code>.
Therefore, the <code>Session</code> struct is generic over the <code>'p</code> lifetime, where the <code>p</code> stands for <code>Pie</code>.
We can leave out this lifetime in <code>Pie::new_session</code>, because the compiler infers it from us, but we must be explicit in structs and most impls.</p>
<p>Check that the code compiles (but gives warnings) with <code>cargo check</code>.</p>
<p>Now we need to modify <code>TopDownContext</code> to work with <code>Session</code>.</p>
<h2 id="update-topdowncontext"><a class="header" href="#update-topdowncontext">Update TopDownContext</a></h2>
<p>Change <code>TopDownContext</code> to only contain a mutable reference to <code>Session</code> in <code>pie/src/context/top_down.rs</code>:</p>
<pre><code class="language-rust customdiff "> use std::io;
 use std::path::Path;
 
-use crate::{Context, fs, Task};
+use crate::{Context, fs, Session, Task};
 use crate::dependency::{FileDependency, TaskDependency};
 use crate::stamp::{FileStamper, OutputStamper};
-use crate::store::{Store, TaskNode};
+use crate::store::TaskNode;
 
-pub struct TopDownContext&lt;T, O&gt; {
-  store: Store&lt;T, O&gt;,
-  current_executing_task: Option&lt;TaskNode&gt;,
-  dependency_check_errors: Vec&lt;io::Error&gt;,
+pub struct TopDownContext&lt;'p, 's, T, O&gt; {
+  session: &amp;'s mut Session&lt;'p, T, O&gt;,
 }
 
-impl&lt;T: Task&gt; TopDownContext&lt;T, T::Output&gt; {
-  pub fn new() -&gt; Self {
-    Self {
-      store: Store::default(),
-      current_executing_task: None,
-      dependency_check_errors: Vec::default(),
-    }
-  }
+impl&lt;'p, 's, T: Task&gt; TopDownContext&lt;'p, 's, T, T::Output&gt; {
+  pub fn new(session: &amp;'s mut Session&lt;'p, T, T::Output&gt;) -&gt; Self { Self { session } }
 
-  pub fn get_dependency_check_errors(&amp;self) -&gt; impl Iterator&lt;Item=&amp;io::Error&gt; {
-    self.dependency_check_errors.iter()
+  pub fn require_initial(&amp;mut self, task: &amp;T) -&gt; T::Output {
+    self.require_task(task)
   }
 }
 </code></pre>
<p>Here, we use lifetime <code>'s</code> to denote the lifetime of a session, and make <code>TopDownContext</code> generic over it.
<code>new</code> now just accepts a mutable reference to the session.
The <code>get_dependency_check_errors</code> method can be removed.
We add a <code>require_initial</code> convenience method for <code>Session</code>.</p>
<p>In the rest of the file, we need to update the <code>impl</code> lines to include the lifetimes, and we need to replace most instances of <code>self</code> with <code>self.session</code>.
You could do this with the following find-replace regex: <code>self\.([\w\d_]+)\.</code> -&gt; <code>self.session.$1.</code></p>
<p>Change <code>pie/src/context/top_down.rs</code>:</p>
<pre><code class="language-rust customdiff "> }
 
 
-impl&lt;T: Task&gt; Context&lt;T&gt; for TopDownContext&lt;T, T::Output&gt; {
+impl&lt;'p, 's, T: Task&gt; Context&lt;T&gt; for TopDownContext&lt;'p, 's, T, T::Output&gt; {
   fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
-    let Some(current_executing_task_node) = &amp;self.current_executing_task else {
+    let Some(current_executing_task_node) = &amp;self.session.current_executing_task else {
       return fs::open_if_file(path); // No current executing task, so no dependency needs to be made.
     };
     let path = path.as_ref();
-    let node = self.store.get_or_create_file_node(path);
+    let node = self.session.store.get_or_create_file_node(path);
     let (dependency, file) = FileDependency::new_with_file(path, stamper)?;
-    self.store.add_file_require_dependency(current_executing_task_node, &amp;node, dependency);
+    self.session.store.add_file_require_dependency(current_executing_task_node, &amp;node, dependency);
     Ok(file)
   }
 
   fn require_task_with_stamper(&amp;mut self, task: &amp;T, stamper: OutputStamper) -&gt; T::Output {
-    let node = self.store.get_or_create_task_node(task);
+    let node = self.session.store.get_or_create_task_node(task);
 
     // Get required task output by executing it if needed, or by getting the output from the store if not needed.
     let output = if self.should_execute_task(&amp;node) {
-      self.store.reset_task(&amp;node);
-      let previous_executing_task = self.current_executing_task.replace(node);
+      self.session.store.reset_task(&amp;node);
+      let previous_executing_task = self.session.current_executing_task.replace(node);
       let output = task.execute(self);
-      self.current_executing_task = previous_executing_task;
-      self.store.set_task_output(&amp;node, output.clone());
+      self.session.current_executing_task = previous_executing_task;
+      self.session.store.set_task_output(&amp;node, output.clone());
       output
     } else {
       // Correctness: when `should_execute_task` returns `true`, the above block is executed. Otherwise this block is 
       // executed and `should_execute_task` ensures that the task has an output.
-      self.store.get_task_output(&amp;node).clone()
+      self.session.store.get_task_output(&amp;node).clone()
     };
 
     // Create task require dependency if a task is currently executing (i.e., we are not requiring the initial task).
-    if let Some(current_executing_task_node) = &amp;self.current_executing_task {
+    if let Some(current_executing_task_node) = &amp;self.session.current_executing_task {
       let dependency = TaskDependency::new(task.clone(), stamper, output.clone());
-      if self.store.add_task_require_dependency(current_executing_task_node, &amp;node, dependency).is_err() {
-        let current_executing_task = self.store.get_task(current_executing_task_node);
+      if self.session.store.add_task_require_dependency(current_executing_task_node, &amp;node, dependency).is_err() {
+        let current_executing_task = self.session.store.get_task(current_executing_task_node);
         panic!(&quot;Cyclic task dependency; current executing task '{:?}' is requiring task '{:?}' which was already required&quot;, current_executing_task, task);
       }
     }
@@ -62,19 +62,19 @@
   }
 }
 
-impl&lt;T: Task&gt; TopDownContext&lt;T, T::Output&gt; {
+impl&lt;'p, 's, T: Task&gt; TopDownContext&lt;'p, 's, T, T::Output&gt; {
   /// Checks whether given task should be executed, returning `true` if it should be executed. A task should be executed
   /// if any of its dependencies are inconsistent, or when it has no output.
   fn should_execute_task(&amp;mut self, node: &amp;TaskNode) -&gt; bool {
     // Borrow: because we pass `self` (which is `&amp;mut self`) to `is_inconsistent` for recursive consistency checking, 
     //         we need to clone and collect dependencies into a `Vec`. Otherwise we have an immutable borrow of `self`
     //         through `self.store` while we create a mutable borrow of `self`, which is not allowed.
-    let dependencies: Vec&lt;_&gt; = self.store.get_dependencies_of_task(node).cloned().collect();
+    let dependencies: Vec&lt;_&gt; = self.session.store.get_dependencies_of_task(node).cloned().collect();
     for dependency in dependencies {
       match dependency.is_inconsistent(self) {
         Ok(Some(_)) =&gt; return true,
         Err(e) =&gt; { // Error while checking: store error and assume inconsistent
-          self.dependency_check_errors.push(e);
+          self.session.dependency_check_errors.push(e);
           return true;
         }
         _ =&gt; {} // Consistent: continue checking
@@ -82,6 +82,6 @@
     }
     // Task has no dependencies or all dependencies are consistent. Should only execute if it has no output, meaning
     // that it has never been executed before.
-    return !self.store.task_has_output(node);
+    return !self.session.store.task_has_output(node);
   }
 }</code></pre>
<p>Now we change <code>Session</code> to use <code>TopDownContext</code>. </p>
<h2 id="update-session"><a class="header" href="#update-session">Update Session</a></h2>
<p>Change <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff "> 
   /// Requires `task`, returning its up-to-date output.
   pub fn require(&amp;mut self, task: &amp;T) -&gt; T::Output {
-    todo!(&quot;Create TopDownContext with this session, and require the task&quot;)
+    self.current_executing_task = None;
+    TopDownContext::new(self).require_initial(task)
   }
 
   /// Gets all errors produced during dependency checks.</code></pre>
<p>We reset the <code>current_executing_task</code> to <code>None</code>, to be sure that we start a build without an executing task.
Then, we just create a <code>TopDownContext</code> and call <code>require_initial</code>.</p>
<p>Finally, we can now make the <code>context</code> module private, as users of the library run builds using <code>Session</code>, instead of having to create a context implementation.
Change <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff "> use crate::store::{Store, TaskNode};
 
 pub mod stamp;
-pub mod context;
+mod context;
 mod fs;
 mod dependency;
 mod store;</code></pre>
<p>Check that the code compiles with <code>cargo check --lib</code>.
This only checks if the library builds, but not any examples.
We need to update the incrementality example to work with these changes.</p>
<h2 id="update-incremental-example"><a class="header" href="#update-incremental-example">Update incremental example</a></h2>
<p>First change some imports in <code>pie/examples/incremental.rs</code>:</p>
<pre><code class="language-rust customdiff "> use std::path::{Path, PathBuf};
 
 use dev_shared::{create_temp_dir, write_until_modified};
-use pie::{Context, Task};
-use pie::context::top_down::TopDownContext;
+use pie::{Context, Pie, Task};
 use pie::stamp::FileStamper;
 
 /// Enumeration over file pseudo-tasks.</code></pre>
<p>Then, change <code>pie/examples/incremental.rs</code> to use sessions:</p>
<pre><code class="language-rust customdiff ">     Ok(())
   }
 }
 
 fn main() -&gt; Result&lt;(), io::Error&gt; {
   let temp_dir = create_temp_dir()?;
   let input_file = temp_dir.path().join(&quot;input.txt&quot;);
   write(&amp;input_file, &quot;Hi&quot;)?;
   let output_file = temp_dir.path().join(&quot;output.txt&quot;);
 
-  let mut context = TopDownContext::new();
+  let mut pie = Pie::default();
   let read_task = ReadStringFromFile::new(&amp;input_file, FileStamper::Modified);
   let write_task = WriteStringToFile::new(read_task.clone(), &amp;output_file, FileStamper::Modified);
 
   println!(&quot;A) New task: expect `read_task` to execute&quot;);
   // `read_task` is new, meaning that we have no cached output for it, thus it must be executed.
-  let output = context.require_task(&amp;read_task)?;
+  let output = pie.new_session().require(&amp;read_task)?;
   assert_eq!(&amp;output, &quot;Hi&quot;);
 
   println!(&quot;\nB) Reuse: expect no execution&quot;);
   // `read_task` is not new and its file dependency is still consistent. It is consistent because the modified time of 
   // `input_file` has not changed, thus the modified stamp is equal.
-  let output = context.require_task(&amp;read_task)?;
+  let output = pie.new_session().require(&amp;read_task)?;
   assert_eq!(&amp;output, &quot;Hi&quot;);
 
   write_until_modified(&amp;input_file, &quot;Hello&quot;)?;
   println!(&quot;\nC) Inconsistent file dependency: expect `read_task` to execute&quot;);
   // The file dependency of `read_task` is inconsistent due to the changed modified time of `input_file`.
-  let output = context.require_task(&amp;read_task)?;
+  let output = pie.new_session().require(&amp;read_task)?;
   assert_eq!(&amp;output, &quot;Hello&quot;);
 
   println!(&quot;\nD) New task, reuse other: expect only `write_task` to execute&quot;);
   // write_task` is new, but `read_task` is not new and its file dependency is still consistent.
-  context.require_task(&amp;write_task)?;
+  pie.new_session().require(&amp;write_task)?;
   assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello&quot;);
 
   write_until_modified(&amp;input_file, &quot;Hello, World!&quot;)?;
   println!(&quot;\nE) Inconsistent file and task dependency: expect both tasks to execute&quot;);
   // The file dependency of `read_task` is inconsistent. Then, the task dependency from `write_task` to `read_task` is 
   // inconsistent because `read_task` now returns `&quot;Hello, World!&quot;` as output instead of &quot;Hello&quot;, and thus its equals 
   // output stamp is different.
-  context.require_task(&amp;write_task)?;
+  pie.new_session().require(&amp;write_task)?;
   assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello, World!&quot;);
 
   write_until_modified(&amp;input_file, &quot;Hello, World!&quot;)?; // Note: writing same file contents!
   println!(&quot;\nF) Early cutoff: expect only `read_task` to execute&quot;);
   // File dependency of `read_task` is inconsistent because the modified time changed, but it returns the same output 
   // `&quot;Hello, World!&quot;` because the contents of the file have not actually changed. Then, the task dependency from 
   // `write_task` to `read_task` is consistent because its output did not change, and thus the equality output stamp is 
   // the same.
-  context.require_task(&amp;write_task)?;
+  pie.new_session().require(&amp;write_task)?;
   assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello, World!&quot;);
 
   write_until_modified(&amp;output_file, &quot;&quot;)?;
   println!(&quot;\nG) Regenerate changed output file: expect only `write_task` to execute&quot;);
   // The file dependency of `write_task` to `output_file` is inconsistent.
-  context.require_task(&amp;write_task)?;
+  pie.new_session().require(&amp;write_task)?;
   assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello, World!&quot;);
 
   write_until_modified(&amp;output_file, &quot;&quot;)?;
   remove_file(&amp;output_file)?;
   println!(&quot;\nH) Regenerate deleted output file: expect only `write_task` to execute&quot;);
   // Same results when `output_file` is deleted.
-  context.require_task(&amp;write_task)?;
+  pie.new_session().require(&amp;write_task)?;
   assert_eq!(&amp;read_to_string(&amp;output_file)?, &quot;Hello, World!&quot;);
 
   let input_file_b = temp_dir.path().join(&quot;input_b.txt&quot;);
   write(&amp;input_file_b, &quot;Test&quot;)?;
   let read_task_b_modified = ReadStringFromFile::new(&amp;input_file_b, FileStamper::Modified);
   let read_task_b_exists = ReadStringFromFile::new(&amp;input_file_b, FileStamper::Exists);
   println!(&quot;\nI) Different tasks: expect `read_task_b_modified` and `read_task_b_exists` to execute&quot;);
   // Task `read_task`, `read_task_b_modified` and `read_task_b_exists` are different, due to their `Eq` implementation 
   // determining that their paths and stampers are different. Therefore, `read_task_b_modified` and `read_task_b_exists`
   // are new tasks, and must be executed.
-  let output = context.require_task(&amp;read_task_b_modified)?;
+  let mut session = pie.new_session();
+  let output = session.require(&amp;read_task_b_modified)?;
   assert_eq!(&amp;output, &quot;Test&quot;);
-  let output = context.require_task(&amp;read_task_b_exists)?;
+  let output = session.require(&amp;read_task_b_exists)?;
   assert_eq!(&amp;output, &quot;Test&quot;);
 
   write_until_modified(&amp;input_file_b, &quot;Test Test&quot;)?;
   println!(&quot;\nJ) Different stampers: expect only `read_task_b_modified` to execute&quot;);
   // Both `read_task_b_modified` and `read_task_b_exists` read from the same file, but they use different stampers.
   // Therefore, `read_task_b_modified` must be executed because the modified time has changed, but `read_task_b_exists`
   // will not be executed because its file dependency stamper only checks for existence of the file, and the existence 
   // of the file has not changed.
   //
   // Note that using an `Exists` stamper for this task does not make a lot of sense, since it will only read the file 
   // on first execute and when it is recreated. But this is just to demonstrate different stampers.
-  let output = context.require_task(&amp;read_task_b_modified)?;
+  let mut session = pie.new_session();
+  let output = session.require(&amp;read_task_b_modified)?;
   assert_eq!(&amp;output, &quot;Test Test&quot;);
-  let output = context.require_task(&amp;read_task_b_exists)?;
+  let output = session.require(&amp;read_task_b_exists)?;
   assert_eq!(&amp;output, &quot;Test&quot;);
 
   Ok(())
 }</code></pre>
<p>When we only require one task, we replace <code>context.require_task</code> with <code>pie.new_session().require</code>.
When we want to require multiple tasks, we use <code>new_session</code> and call <code>session.require</code> multiple times.</p>
<p>It is very important to create a new session each time in this example, because a task is only checked/executed once each session.
If we use a single session, our changes are never seen, and we just execute each task once, which is not what we want.
Therefore, every time we make changes to source files, or expect that changes have been made to source files, we must create a new session.</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="#admonition-note"></a></p>
</div>
<div>
<p>In changes I and J, Rust is smart enough to allow creating a new session even though the previous <code>session</code> variable is still active, because it knows that we don't use that previous session anymore.</p>
</div>
</div>
<p>Check that all code works by running <code>cargo test</code>.</p>
<p>With this new API in place, and all code adjusted to work with it, we can continue with tracking build events.</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="../../gen/3_min_sound/1_session/source.zip">download the source files up to this point</a>.</p>
</div>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../3_min_sound/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../3_min_sound/2_tracker/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../3_min_sound/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../3_min_sound/2_tracker/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../src/diff2html-ui-base.min.js"></script>
        <script src="../../src/diff.js"></script>


    </div>
    </body>
</html>
