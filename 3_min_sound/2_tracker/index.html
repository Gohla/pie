<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tracking Build Events - Build your own Programmatic Incremental Build System</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../src/diff2html.min.css">
        <link rel="stylesheet" href="../../src/mdbook-admonish.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Introduction</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Programmability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../1_programmability/0_setup/index.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../../1_programmability/1_api/index.html"><strong aria-hidden="true">2.2.</strong> Programmable Build System API</a></li><li class="chapter-item expanded "><a href="../../1_programmability/2_non_incremental/index.html"><strong aria-hidden="true">2.3.</strong> Non-Incremental Context</a></li></ol></li><li class="chapter-item expanded "><a href="../../2_incrementality/index.html"><strong aria-hidden="true">3.</strong> Incrementality</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../2_incrementality/1_require_file/index.html"><strong aria-hidden="true">3.1.</strong> Requiring Files</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/2_stamp/index.html"><strong aria-hidden="true">3.2.</strong> Stamps</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/3_dependency/index.html"><strong aria-hidden="true">3.3.</strong> Dynamic Dependencies</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/4_store/index.html"><strong aria-hidden="true">3.4.</strong> Dependency Graph Store</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/5_context/index.html"><strong aria-hidden="true">3.5.</strong> Incremental Top-Down Context</a></li></ol></li><li class="chapter-item expanded "><a href="../../3_min_sound/index.html"><strong aria-hidden="true">4.</strong> Minimality and Soundness</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../3_min_sound/1_session/index.html"><strong aria-hidden="true">4.1.</strong> Minimality with Sessions</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/2_tracker/index.html" class="active"><strong aria-hidden="true">4.2.</strong> Tracking Build Events</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Prevent Overlapping File Writes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> Prevent Hidden Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> Prevent Cycles</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Improvements</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Serialization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> More Stampers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Configurable Hashing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Efficiency</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Incremental Bottom-Up Context</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Observability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Deferred Tasks</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Multiple Task Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> On Static Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> On Declarativity</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Related Work</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
<!-- CHANGE: removed all but light and ayu theme, and renamed ayu to dark -->                          
<!--                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>-->
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/edit/master/tutorial/src/3_min_sound/2_tracker/index.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tracking-build-events"><a class="header" href="#tracking-build-events">Tracking Build Events</a></h1>
<p>So far we have had no convenient way to inspect what our build system is doing, apart from <code>println!</code> debugging or attaching a debugger to the program.
In this section, we will change that by tracking build events for debugging and integration testing purposes.</p>
<p>We will:</p>
<ol>
<li>Create a <code>Tracker</code> trait that receives build events through method calls. The <code>Tracker</code> trait can be implemented in different ways to handle build events in different ways.</li>
<li>Implement a <code>NoopTracker</code> that does nothing, removing the tracking overhead.</li>
<li>Make the build system generic over <code>Tracker</code>, such that <code>Context</code> implementations call methods on the tracker to create build events.</li>
<li>Implement a <code>WritingTracker</code> that writes build events to standard output or standard error, for debugging purposes.</li>
<li>Implement an <code>EventTracker</code> that stores build events for later inspection, for integration testing purposes.</li>
<li>Implement a <code>CompositeTracker</code> that forwards build events to 2 other trackers, so we can use multiple trackers at the same time.</li>
</ol>
<h2 id="tracker-trait"><a class="header" href="#tracker-trait"><code>Tracker</code> trait</a></h2>
<p>Add the <code>tracker</code> module to <code>pie/src/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_0"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -10,6 +10,7 @@
 use crate::store::{Store, TaskNode};
 
 pub mod stamp;
+pub mod tracker;
 mod context;
 mod fs;
 mod dependency;
`;
    let target = document.getElementById('diff2html_0');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Then create the <code>pie/src/tracker</code> directory, create the <code>pie/src/tracker/mod.rs</code> file, and add the following content:</p>
<pre><code class="language-rust ">use std::path::Path;

use crate::stamp::{FileStamp, FileStamper, OutputStamp, OutputStamper};
use crate::Task;

/// Trait for tracking build events. Can be used to implement logging, event tracing, progress tracking, metrics, etc.
#[allow(unused_variables)]
pub trait Tracker&lt;T: Task&gt; {
  /// Start a new build.
  fn build_start(&amp;mut self) {}
  /// A build has been completed.
  fn build_end(&amp;mut self) {}

  /// A file at `path` has been required, using `stamper` to create `stamp`.
  fn required_file(&amp;mut self, path: &amp;Path, stamper: &amp;FileStamper, stamp: &amp;FileStamp) {}
  /// Require `task` using `stamper`.
  fn require_task(&amp;mut self, task: &amp;T, stamper: &amp;OutputStamper) {}
  /// A `task` has been required, resulting in consistent `output`, using `stamper` to create `stamp`, and task 
  /// `was_executed`.
  fn required_task(&amp;mut self, task: &amp;T, output: &amp;T::Output, stamper: &amp;OutputStamper, stamp: &amp;OutputStamp&lt;T::Output&gt;, was_executed: bool) {}

  /// Execute `task`.
  fn execute(&amp;mut self, task: &amp;T) {}
  /// A `task` has been executed, producing `output`.
  fn executed(&amp;mut self, task: &amp;T, output: &amp;T::Output) {}
}</code></pre>
<p>The <code>Tracker</code> trait is generic over <code>Task</code>.</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="#admonition-note"></a></p>
</div>
<div>
<p>Here, we chose to put the <code>Task</code> constraint on the trait itself.
This will not lead to cascading constraints, as the <code>Tracker</code> trait will only be used as a constraint in <code>impl</code>s, not in structs or other traits.</p>
</div>
</div>
<p><code>Tracker</code> has methods corresponding to events that happen during a build, such as a build starting or ending, requiring a file, requiring a task, and executing a task.
These methods accept <code>&amp;mut self</code> so that tracker implementations can perform mutation, such as storing a build event.
We provide default methods that do nothing so that implementors of <code>Tracker</code> only have to override the methods for events they are interested in.
We use <code>#[allow(unused_variables)]</code> on the trait to not give warnings for unused variables, as all variables are unused due to the empty default implementations.</p>
<details id="admonition-default-methods" class="admonition info">
<summary class="admonition-title">
<p>Default methods</p>
<p><a class="admonition-anchor-link" href="#admonition-default-methods"></a></p>
</summary>
<div>
<p>Adding a method to <code>Tracker</code> with a default implementation ensures that implementations of <code>Tracker</code> do not have to be changed to work with the new method.
This is both good and bad.
Good because we can add methods without breaking compatibility.
Bad because we can forget to handle a new method, which can lead to problems with for example a composite tracker that forwards events to 2 trackers.
In this tutorial we chose the convenient option, but be sure to think about these kind of tradeoffs yourself!</p>
</div>
</details>
<p>Check that the code compiles with <code>cargo test</code>.</p>
<h2 id="no-op-tracker"><a class="header" href="#no-op-tracker">No-op tracker</a></h2>
<p>Add a no-op tracker, which is a tracker that does nothing, by adding the following code to <code>pie/src/tracker/mod.rs</code>:</p>
<pre><code class="language-rust ">/// [`Tracker`] that does nothing.
#[derive(Copy, Clone, Debug)]
pub struct NoopTracker;
impl&lt;T: Task&gt; Tracker&lt;T&gt; for NoopTracker {}</code></pre>
<p>Due to the default methods that do nothing on <code>Tracker</code>, this implementation is extremely simple. </p>
<details id="admonition-removing-tracker-overhead" class="admonition info">
<summary class="admonition-title">
<p>Removing tracker overhead</p>
<p><a class="admonition-anchor-link" href="#admonition-removing-tracker-overhead"></a></p>
</summary>
<div>
<p>We will use generics to select which tracker implementation to use.
Therefore, all calls to trackers are statically dispatched, and could be inlined.
Because <code>NoopTracker</code> only has empty methods, and those empty methods can be inlined, using <code>NoopTracker</code> will effectively remove all tracking code from your binary, thus removing the overhead of tracking if you don't want it.</p>
<p>In this tutorial, we do not annotate methods with <a href="https://nnethercote.github.io/perf-book/inlining.html"><code>#[inline]</code></a>, meaning that the Rust compiler (and the LLVM backend) will make its own decisions on what to make inlineable and what not.
If you care about performance here, be sure to annotate those default empty methods with <code>#[inline]</code>.</p>
</div>
</details>
<h2 id="using-the-tracker-trait"><a class="header" href="#using-the-tracker-trait">Using the <code>Tracker</code> trait</a></h2>
<p>Now we will make the build system generic over <code>Tracker</code>, and insert <code>Tracker</code> calls in context implementations.</p>
<p>Make <code>Pie</code> and <code>Session</code> generic over <code>Tracker</code> by modifying <code>pie/src/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_1"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -8,6 +8,7 @@
 
 use crate::context::top_down::TopDownContext;
 use crate::store::{Store, TaskNode};
+use crate::tracker::{NoopTracker, Tracker};
 
 pub mod stamp;
 pub mod tracker;
@@ -60,35 +61,46 @@
 }
 
 /// Main entry point into PIE, a sound and incremental programmatic build system.
-pub struct Pie<T, O> {
+pub struct Pie<T, O, A = NoopTracker> {
   store: Store<T, O>,
+  tracker: A,
 }
 
 impl<T: Task> Default for Pie<T, T::Output> {
-  fn default() -> Self { Self { store: Store::default() } }
+  fn default() -> Self { Self::with_tracker(NoopTracker) }
 }
 
-impl<T: Task> Pie<T, T::Output> {
+impl<T: Task, A: Tracker<T>> Pie<T, T::Output, A> {
+  /// Creates a new [${"`"}Pie${"`"}] instance with given ${"`"}tracker${"`"}.
+  pub fn with_tracker(tracker: A) -> Self { Self { store: Store::default(), tracker } }
+  
   /// Creates a new build session. Only one session may be active at once, enforced via mutable (exclusive) borrow.
-  pub fn new_session(&mut self) -> Session<T, T::Output> { Session::new(self) }
+  pub fn new_session(&mut self) -> Session<T, T::Output, A> { Session::new(self) }
   /// Runs ${"`"}f${"`"} inside a new build session.
-  pub fn run_in_session<R>(&mut self, f: impl FnOnce(Session<T, T::Output>) -> R) -> R {
+  pub fn run_in_session<R>(&mut self, f: impl FnOnce(Session<T, T::Output, A>) -> R) -> R {
     let session = self.new_session();
     f(session)
   }
+
+  /// Gets the [${"`"}Tracker${"`"}] instance.
+  pub fn tracker(&self) -> &A { &self.tracker }
+  /// Gets the mutable [${"`"}Tracker${"`"}] instance.
+  pub fn tracker_mut(&mut self) -> &mut A { &mut self.tracker }
 }
 
 /// A session in which builds are executed.
-pub struct Session<'p, T, O> {
+pub struct Session<'p, T, O, A> {
   store: &'p mut Store<T, O>,
+  tracker: &'p mut A,
   current_executing_task: Option<TaskNode>,
   dependency_check_errors: Vec<io::Error>,
 }
 
-impl<'p, T: Task> Session<'p, T, T::Output> {
-  fn new(pie: &'p mut Pie<T, T::Output>) -> Self {
+impl<'p, T: Task, A: Tracker<T>> Session<'p, T, T::Output, A> {
+  fn new(pie: &'p mut Pie<T, T::Output, A>) -> Self {
     Self {
       store: &mut pie.store,
+      tracker: &mut pie.tracker,
       current_executing_task: None,
       dependency_check_errors: Vec::default(),
     }
@@ -100,6 +112,10 @@
     TopDownContext::new(self).require_initial(task)
   }
 
+  /// Gets the [${"`"}Tracker${"`"}] instance.
+  pub fn tracker(&self) -> &A { &self.tracker }
+  /// Gets the mutable [${"`"}Tracker${"`"}] instance.
+  pub fn tracker_mut(&mut self) -> &mut A { &mut self.tracker }
   /// Gets all errors produced during dependency checks.
   pub fn dependency_check_errors(&self) -> impl Iterator<Item=&io::Error> { self.dependency_check_errors.iter() }
 }
`;
    let target = document.getElementById('diff2html_1');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We use <code>A</code> as the generic argument for tracker types in the source code.
The <code>Pie</code> struct owns the tracker, similarly to how it owns the store.
<code>Pie</code> can be created with a specific tracker with <code>with_tracker</code>, and provides access to the tracker with <code>tracker</code> and <code>tracker_mut</code>.</p>
<details id="admonition-default-type" class="admonition info">
<summary class="admonition-title">
<p>Default type</p>
<p><a class="admonition-anchor-link" href="#admonition-default-type"></a></p>
</summary>
<div>
<p>We assign <code>NoopTracker</code> as the default type for trackers in <code>Pie</code>, so that no tracking is performed when we use the <code>Pie</code> type without an explicit tracker type.
The <code>Default</code> implementation only works with <code>NoopTracker</code>, because we <code>impl Default for Pie&lt;T, T::Output&gt;</code>, which is equivalent to <code>impl Default for Pie&lt;T, T::Output, NoopTracker&gt;</code> due to the default type.</p>
</div>
</details>
<p>We make <code>Session</code> generic over trackers, and mutibly borrow the tracker from <code>Pie</code>, again like we do with the store.
For convenience, <code>Session</code> also provides access to the tracker with <code>tracker</code> and <code>tracker_mut</code>.</p>
<p>Now we make <code>TopDownContext</code> generic over <code>Tracker</code>, and insert calls to tracker methods.
Modify <code>pie/src/context/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_2"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -6,21 +6,25 @@
 use crate::dependency::{FileDependency, TaskDependency};
 use crate::stamp::{FileStamper, OutputStamper};
 use crate::store::TaskNode;
+use crate::tracker::Tracker;
 
-pub struct TopDownContext<'p, 's, T, O> {
-  session: &'s mut Session<'p, T, O>,
+pub struct TopDownContext<'p, 's, T, O, A> {
+  session: &'s mut Session<'p, T, O, A>,
 }
 
-impl<'p, 's, T: Task> TopDownContext<'p, 's, T, T::Output> {
-  pub fn new(session: &'s mut Session<'p, T, T::Output>) -> Self { Self { session } }
+impl<'p, 's, T: Task, A: Tracker<T>> TopDownContext<'p, 's, T, T::Output, A> {
+  pub fn new(session: &'s mut Session<'p, T, T::Output, A>) -> Self { Self { session } }
 
   pub fn require_initial(&mut self, task: &T) -> T::Output {
-    self.require_task(task)
+    self.session.tracker.build_start();
+    let output = self.require_task(task);
+    self.session.tracker.build_end();
+    output
   }
 }
 
 
-impl<'p, 's, T: Task> Context<T> for TopDownContext<'p, 's, T, T::Output> {
+impl<'p, 's, T: Task, A: Tracker<T>> Context<T> for TopDownContext<'p, 's, T, T::Output, A> {
   fn require_file_with_stamper<P: AsRef<Path>>(&mut self, path: P, stamper: FileStamper) -> Result<Option<File>, io::Error> {
     let Some(current_executing_task_node) = &self.session.current_executing_task else {
       return fs::open_if_file(path); // No current executing task, so no dependency needs to be made.
@@ -28,20 +32,25 @@
     let path = path.as_ref();
     let node = self.session.store.get_or_create_file_node(path);
     let (dependency, file) = FileDependency::new_with_file(path, stamper)?;
+    self.session.tracker.required_file(path, dependency.stamper(), dependency.stamp());
     self.session.store.add_file_require_dependency(current_executing_task_node, &node, dependency);
     Ok(file)
   }
 
   fn require_task_with_stamper(&mut self, task: &T, stamper: OutputStamper) -> T::Output {
+    self.session.tracker.require_task(task, &stamper);
     let node = self.session.store.get_or_create_task_node(task);
 
     // Get required task output by executing it if needed, or by getting the output from the store if not needed.
-    let output = if self.should_execute_task(&node) {
+    let should_execute = self.should_execute_task(&node);
+    let output = if should_execute {
+      self.session.tracker.execute(task);
       self.session.store.reset_task(&node);
       let previous_executing_task = self.session.current_executing_task.replace(node);
       let output = task.execute(self);
       self.session.current_executing_task = previous_executing_task;
       self.session.store.set_task_output(&node, output.clone());
+      self.session.tracker.executed(task, &output);
       output
     } else {
       // Correctness: when ${"`"}should_execute_task${"`"} returns ${"`"}true${"`"}, the above block is executed. Otherwise this block is 
@@ -49,9 +58,11 @@
       self.session.store.get_task_output(&node).clone()
     };
 
+    let dependency = TaskDependency::new(task.clone(), stamper, output.clone());
+    self.session.tracker.required_task(task, &output,dependency.stamper(), dependency.stamp(), should_execute);
+
     // Create task require dependency if a task is currently executing (i.e., we are not requiring the initial task).
     if let Some(current_executing_task_node) = &self.session.current_executing_task {
-      let dependency = TaskDependency::new(task.clone(), stamper, output.clone());
       if self.session.store.add_task_require_dependency(current_executing_task_node, &node, dependency).is_err() {
         let current_executing_task = self.session.store.get_task(current_executing_task_node);
         panic!("Cyclic task dependency; current executing task '{:?}' is requiring task '{:?}' which was already required", current_executing_task, task);
@@ -62,7 +73,7 @@
   }
 }
 
-impl<'p, 's, T: Task> TopDownContext<'p, 's, T, T::Output> {
+impl<'p, 's, T: Task, A: Tracker<T>> TopDownContext<'p, 's, T, T::Output, A> {
   /// Checks whether given task should be executed, returning ${"`"}true${"`"} if it should be executed. A task should be executed
   /// if any of its dependencies are inconsistent, or when it has no output.
   fn should_execute_task(&mut self, node: &TaskNode) -> bool {
`;
    let target = document.getElementById('diff2html_2');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We make <code>TopDownContext</code> generic over trackers, and call methods on the tracker:</p>
<ul>
<li><code>build_start</code>/<code>build_end</code> in <code>require_initial</code> to track build start and ends,</li>
<li><code>required_file</code> in <code>require_file_with_stamper</code> to track file dependencies,</li>
<li><code>require_task</code>/<code>required_task</code> in <code>require_file_with_stamper</code> to track task dependencies,</li>
<li><code>execute</code>/<code>executed</code> in <code>require_task_with_stamper</code> to track task execution start and ends.</li>
</ul>
<p>In <code>require_file_with_stamper</code>, we also extract <code>should_execute</code> into a variable, and pull <code>dependency</code> out of the <code>if</code>, so that we can pass the required data to <code>tracker.required_task</code>.</p>
<p>Check that the code compiles with <code>cargo test</code>.
Existing code should keep working due to the <code>NoopTracker</code> default type in <code>Pie</code>.</p>
<p>We won't modify <code>NonIncrementalContext</code> to use a tracker, as <code>NonIncrementalContext</code> has no state, so we cannot pass a tracker to it.</p>
<h2 id="implement-writing-tracker"><a class="header" href="#implement-writing-tracker">Implement writing tracker</a></h2>
<p>Now we can implement some interesting trackers.
We start with a simple <code>WritingTracker</code> that writes build events to some writer.</p>
<p>Add the <code>writing</code> module to <code>pie/src/tracker/mod.rs</code>:</p>
<div class="diff2html" id="diff2html_3"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/tracker/mod.rs
+++ pie/src/tracker/mod.rs
@@ -3,6 +3,8 @@
 use crate::stamp::{FileStamp, FileStamper, OutputStamp, OutputStamper};
 use crate::Task;
 
+pub mod writing;
+
 /// Trait for tracking build events. Can be used to implement logging, event tracing, progress tracking, metrics, etc.
 #[allow(unused_variables)]
 pub trait Tracker<T: Task> {
`;
    let target = document.getElementById('diff2html_3');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Then create the <code>pie/src/tracker/writing.rs</code> file and add:</p>
<pre><code class="language-rust ">use std::io::{self, BufWriter, Stderr, Stdout, Write};

use crate::stamp::{OutputStamp, OutputStamper};
use crate::Task;
use crate::tracker::Tracker;

/// [`Tracker`] that writes events to a [`Write`] instance, for example [`Stdout`].
#[derive(Clone, Debug)]
pub struct WritingTracker&lt;W&gt; {
  writer: W,
  indentation: u32,
}

impl WritingTracker&lt;BufWriter&lt;Stdout&gt;&gt; {
  /// Creates a [`WritingTracker`] that writes to buffered standard output.
  pub fn with_stdout() -&gt; Self { Self::new(BufWriter::new(io::stdout())) }
}
impl WritingTracker&lt;BufWriter&lt;Stderr&gt;&gt; {
  /// Creates a [`WritingTracker`] that writes to buffered standard error.
  pub fn with_stderr() -&gt; Self { Self::new(BufWriter::new(io::stderr())) }
}
impl&lt;W: Write&gt; WritingTracker&lt;W&gt; {
  /// Creates a [`WritingTracker`] that writes to `writer`.
  pub fn new(writer: W) -&gt; Self {
    Self {
      writer,
      indentation: 0,
    }
  }
}</code></pre>
<p>The <code>WritingTracker</code> is generic over a writer <code>W</code> that must implement <code>Write</code>, which is a standard trait for writing bytes to something.
<code>with_stdout</code> and <code>with_stderr</code> can be used to create buffered writers to standard output and standard error.
<code>new</code> can be used to create a writer to anything that implements <code>Write</code>, such as a <code>File</code>.</p>
<p>Add the <code>Tracker</code> implementation to <code>pie/src/tracker/writing.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;W: Write, T: Task&gt; Tracker&lt;T&gt; for WritingTracker&lt;W&gt; {
  fn required_task(&amp;mut self, task: &amp;T, _output: &amp;T::Output, _stamper: &amp;OutputStamper, _stamp: &amp;OutputStamp&lt;T::Output&gt;, was_executed: bool) {
    if !was_executed {
      self.writeln(format_args!(&quot;✓ {:?}&quot;, task));
      self.flush();
    }
  }

  fn execute(&amp;mut self, task: &amp;T) {
    self.writeln(format_args!(&quot;→ {:?}&quot;, task));
    self.indent();
    self.flush();
  }
  fn executed(&amp;mut self, _task: &amp;T, output: &amp;T::Output) {
    self.unindent();
    self.writeln(format_args!(&quot;← {:?}&quot;, output));
    self.flush();
  }
}

#[allow(dead_code)]
impl&lt;W: Write&gt; WritingTracker&lt;W&gt; {
  fn writeln(&amp;mut self, args: std::fmt::Arguments) {
    self.write_indentation();
    writeln!(&amp;mut self.writer, &quot;{}&quot;, args).ok();
  }
  fn write(&amp;mut self, args: std::fmt::Arguments) {
    write!(&amp;mut self.writer, &quot;{}&quot;, args).ok();
  }
  fn write_nl(&amp;mut self) {
    write!(&amp;mut self.writer, &quot;\n&quot;).ok();
  }

  fn indent(&amp;mut self) {
    self.indentation = self.indentation.saturating_add(1);
  }
  fn unindent(&amp;mut self) {
    self.indentation = self.indentation.saturating_sub(1);
  }
  fn write_indentation(&amp;mut self) {
    for _ in 0..self.indentation {
      write!(&amp;mut self.writer, &quot; &quot;).ok();
    }
  }

  fn flush(&amp;mut self) {
    self.writer.flush().ok();
  }
}</code></pre>
<p>We implement 3 tracker methods that write when:</p>
<ul>
<li>✓: a task is required but was not executed (i.e., consistent),</li>
<li>→: a task starts to execute,</li>
<li>←: when the task is done executing.</li>
</ul>
<p>The text to write is formatted with <code>format_args!</code>, which is passed into <code>writeln</code> using <code>std::fmt::Arguments</code> for flexibility.
We <code>flush</code> the writer after every event to ensure that bytes are written out.
When a task starts to execute, we increase indentation to signify the recursive checking/execution.
When a task is done executing, we decrease the indentation again.</p>
<details id="admonition-saturating-arithmetic" class="admonition info">
<summary class="admonition-title">
<p>Saturating arithmetic</p>
<p><a class="admonition-anchor-link" href="#admonition-saturating-arithmetic"></a></p>
</summary>
<div>
<p>We use <code>saturating_add</code> and <code>saturating_sub</code> for safety, which are saturating arithmetic operations that saturate at the numeric bounds instead of overflowing.
For example, <code>0u32.saturating_sub(1)</code> will result in <code>0</code> instead of overflowing into <code>4294967295</code>.</p>
<p>These saturating operations are not really needed when calls to <code>indent</code> and <code>unindent</code> are balanced.
However, if we make a mistake, it is better to write no indentation than to write 4294967295 spaces of indentation.</p>
<p>Alternatively, we could use standard arithmetic operations, which panic on overflow in debug/development mode, but silently overflow in release mode.</p>
</div>
</details>
<details id="admonition-failing-writes" class="admonition info">
<summary class="admonition-title">
<p>Failing writes</p>
<p><a class="admonition-anchor-link" href="#admonition-failing-writes"></a></p>
</summary>
<div>
<p>Writes can fail, but we silently ignore them in this tutorial (with <code>let _ = ...</code>) for simplicity.
You could panic when writing fails, but panicking when writing to standard output fails is probably going a bit too far.
You could store the latest write error and give access to it, which at least allows users of <code>WritingTracker</code> check for some errors.</p>
<p>In general, tracking events can fail, but the current <code>Tracker</code> API does not allow for propagating these errors with <code>Result</code>.
This in turn because <code>TopDownContext</code> does not return <code>Result</code> for <code>require_task</code> due to the trade-offs discussed in the section on <code>TopDownContext</code>.</p>
</div>
</details>
<p>If you want, you can capture more build events and write them, and/or provide more configuration as to what build events should be written.
But in this tutorial, we will keep it simple like this.</p>
<p>Check that the code compiles with <code>cargo test</code>.</p>
<p>Let's try out our writing tracker in the incrementality example by modifying <code>pie/examples/incremental.rs</code>:</p>
<div class="diff2html" id="diff2html_4"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/examples/incremental.rs
+++ pie/examples/incremental.rs
@@ -35,7 +35,6 @@
     FileTask::ReadStringFromFile(Self(path.as_ref().to_path_buf(), stamper))
   }
   fn execute<C: Context<FileTask>>(&self, context: &mut C) -> Result<String, io::ErrorKind> {
-    println!("Reading from {} with {:?} stamper", self.0.file_name().unwrap().to_string_lossy(), self.1);
     let file = context.require_file_with_stamper(&self.0, self.1).map_err(|e| e.kind())?;
     if let Some(mut file) = file {
       let mut string = String::new();
@@ -57,7 +56,6 @@
     FileTask::WriteStringToFile(Self(string_provider.into(), path.into(), stamper))
   }
   fn execute<C: Context<FileTask>>(&self, context: &mut C) -> Result<(), io::ErrorKind> {
-    println!("Writing to {} with {:?} stamper", self.1.file_name().unwrap().to_string_lossy(), self.2);
     let string = context.require_task(&self.0)?;
     let mut file = File::create(&self.1).map_err(|e| e.kind())?;
     file.write_all(string.as_bytes()).map_err(|e| e.kind())?;
@@ -72,7 +70,7 @@
   write(&input_file, "Hi")?;
   let output_file = temp_dir.path().join("output.txt");
 
-  let mut pie = Pie::default();
+  let mut pie = Pie::with_tracker(pie::tracker::writing::WritingTracker::with_stdout());
   let read_task = ReadStringFromFile::new(&input_file, FileStamper::Modified);
   let write_task = WriteStringToFile::new(read_task.clone(), &output_file, FileStamper::Modified);
 
`;
    let target = document.getElementById('diff2html_4');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We remove the <code>println!</code> statements from tasks and create <code>Pie</code> with <code>WritingTracker</code>.
Now run the example with <code>cargo run --example incremental</code>, and you should see the writing tracker print consistent tasks and task executions to standard output.</p>
<h2 id="implement-event-tracker"><a class="header" href="#implement-event-tracker">Implement event tracker</a></h2>
<p>The writing tracker is great for debugging purposes, but we cannot use it to check whether our build system is incremental and sound.
To check incrementality and soundness, we need to be able to check whether a task has executed or not, and check the order of build events.
Therefore, we will implement the <code>EventTracker</code> that stores build events for later inspection.</p>
<p>Add the <code>event</code> module to <code>pie/src/tracker/mod.rs</code>:</p>
<div class="diff2html" id="diff2html_5"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/tracker/mod.rs
+++ pie/src/tracker/mod.rs
@@ -4,6 +4,7 @@
 use crate::Task;
 
 pub mod writing;
+pub mod event;
 
 /// Trait for tracking build events. Can be used to implement logging, event tracing, progress tracking, metrics, etc.
 #[allow(unused_variables)]
`;
    let target = document.getElementById('diff2html_5');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Then create the <code>pie/src/tracker/event.rs</code> file and add:</p>
<pre><code class="language-rust ">use std::path::{Path, PathBuf};

use crate::stamp::{FileStamp, FileStamper, OutputStamp, OutputStamper};
use crate::Task;
use crate::tracker::Tracker;

/// [`Tracker`] that stores [events](Event) in a [`Vec`], useful in testing to assert that a context implementation is 
/// incremental and sound.
#[derive(Clone, Debug)]
pub struct EventTracker&lt;T: Task&gt; {
  events: Vec&lt;Event&lt;T&gt;&gt;,
}

impl&lt;T: Task&gt; Default for EventTracker&lt;T&gt; {
  fn default() -&gt; Self { Self { events: Vec::new() } }
}

/// Enumeration of important build events.
#[derive(Debug, Clone)]
pub enum Event&lt;T: Task&gt; {
  /// A file at `path` has been required, using `stamper` to create `stamp`.
  RequiredFile { path: PathBuf, stamper: FileStamper, stamp: FileStamp },
  /// Require `task` using `stamper`.
  RequireTask { task: T, stamper: OutputStamper },
  /// A `task` has been required, resulting in consistent `output`, using `stamper` to create `stamp`, and task 
  /// `was_executed`.
  RequiredTask { task: T, output: T::Output, stamper: OutputStamper, stamp: OutputStamp&lt;T::Output&gt;, was_executed: bool },

  /// Execute `task`.
  Execute { task: T },
  /// A `task` has been executed, producing `output`.
  Executed { task: T, output: T::Output },
}</code></pre>
<p>The <code>EventTracker</code> stores build events in a <code>Vec</code>.
The <code>Event</code> enumeration mimics the <code>Tracker</code> methods, but has all arguments in owned form (for example <code>task: T</code> instead of <code>task: &amp;T</code>) as we want to store these events.</p>
<p>Add the tracker implementation to <code>pie/src/tracker/event.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;T: Task&gt; Tracker&lt;T&gt; for EventTracker&lt;T&gt; {
  fn build_start(&amp;mut self) {
    self.events.clear();
  }

  fn required_file(&amp;mut self, path: &amp;Path, stamper: &amp;FileStamper, stamp: &amp;FileStamp) {
    self.events.push(Event::RequiredFile { path: path.to_path_buf(), stamper: *stamper, stamp: *stamp });
  }
  fn require_task(&amp;mut self, task: &amp;T, stamper: &amp;OutputStamper) {
    self.events.push(Event::RequireTask { task: task.clone(), stamper: stamper.clone() });
  }
  fn required_task(&amp;mut self, task: &amp;T, output: &amp;T::Output, stamper: &amp;OutputStamper, stamp: &amp;OutputStamp&lt;T::Output&gt;, was_executed: bool) {
    self.events.push(Event::RequiredTask { task: task.clone(), output: output.clone(), stamper: *stamper, stamp: stamp.clone(), was_executed });
  }

  fn execute(&amp;mut self, task: &amp;T) {
    self.events.push(Event::Execute { task: task.clone() });
  }
  fn executed(&amp;mut self, task: &amp;T, output: &amp;T::Output) {
    self.events.push(Event::Executed { task: task.clone(), output: output.clone() });
  }
}</code></pre>
<p>We implement the relevant methods from <code>Tracker</code> and store the build events as <code>Event</code> instances in <code>self.events</code>.
When a new build starts, we clear the events.</p>
<p>Now we will add code to inspect the build events.
This is quite a bit of code that we will be using in integration testing to test incrementality and soundness.
We'll add in one go to keep the tutorial going, and we will use this code in the next section, but feel free to take some time to inspect the code.</p>
<p>Add the following code to <code>pie/src/tracker/event.rs</code>:</p>
<pre><code class="language-rust ">impl&lt;T: Task&gt; EventTracker&lt;T&gt; {
  /// Returns a slice over all events.
  pub fn slice(&amp;self) -&gt; &amp;[Event&lt;T&gt;] {
    &amp;self.events
  }
  /// Returns an iterator over all events.
  pub fn iter(&amp;self) -&gt; impl Iterator&lt;Item=&amp;Event&lt;T&gt;&gt; {
    self.events.iter()
  }

  /// Returns `true` if `predicate` returns `true` for any event.
  pub fn any(&amp;self, predicate: impl FnMut(&amp;Event&lt;T&gt;) -&gt; bool) -&gt; bool {
    self.iter().any(predicate)
  }
  /// Returns the number of times `predicate` returns `true`.
  pub fn count(&amp;self, predicate: impl FnMut(&amp;&amp;Event&lt;T&gt;) -&gt; bool) -&gt; usize {
    self.iter().filter(predicate).count()
  }
  /// Returns `true` if `predicate` returns `true` for exactly one event.
  pub fn one(&amp;self, predicate: impl FnMut(&amp;&amp;Event&lt;T&gt;) -&gt; bool) -&gt; bool {
    self.count(predicate) == 1
  }

  /// Returns `Some(index)` for the first event `e` where `predicate(e)` returns `true`, or `None` otherwise.
  pub fn index_of(&amp;self, predicate: impl FnMut(&amp;Event&lt;T&gt;) -&gt; bool) -&gt; Option&lt;usize&gt; {
    self.iter().position(predicate)
  }
  /// Returns `Some(v)` for the first event `e` where `f(e)` returns `Some(v)`, or `None` otherwise.
  pub fn find_map&lt;R&gt;(&amp;self, f: impl FnMut(&amp;Event&lt;T&gt;) -&gt; Option&lt;&amp;R&gt;) -&gt; Option&lt;&amp;R&gt; {
    self.iter().find_map(f)
  }
  /// Returns `Some((index, v))` for the first event `e` where `f(e)` returns `Some(v)`, or `None` otherwise.
  pub fn index_find_map&lt;R&gt;(&amp;self, mut f: impl FnMut(&amp;Event&lt;T&gt;) -&gt; Option&lt;&amp;R&gt;) -&gt; Option&lt;(usize, &amp;R)&gt; {
    self.iter().enumerate().find_map(|(i, e)| f(e).map(|o| (i, o)))
  }


  /// Finds the first [required file event](Event::RequiredFile) for `path` and returns its stamp as `Some(stamp)`, or 
  /// `None` if no event was found.
  pub fn stamp_of_first_required_file(&amp;self, path: &amp;PathBuf) -&gt; Option&lt;&amp;FileStamp&gt; {
    self.find_map(|e| e.stamp_of_required_file(path))
  }

  /// Returns `true` if any task was executed.
  pub fn any_execution(&amp;self) -&gt; bool {
    self.any(|e| e.is_execution())
  }
  /// Returns `true` if `task` was executed.
  pub fn any_execution_of(&amp;self, task: &amp;T) -&gt; bool {
    self.any(|e| e.is_execution_of(task))
  }
  /// Returns `true` if `task` was executed exactly once.
  pub fn one_execute_of(&amp;self, task: &amp;T) -&gt; bool {
    self.one(|e| e.is_execute(task))
  }

  /// Finds the first [task execute event](Event::Execute) for `task` and returns its index as `Some(index)`, or `None` 
  /// if no event was found.
  pub fn index_of_first_execute(&amp;self, task: &amp;T) -&gt; Option&lt;usize&gt; {
    self.index_of(|e| e.is_execute(task))
  }
  /// Finds the first [task executed event](Event::Executed) for `task` and returns its index as `Some(index)`, or 
  /// `None` if no event was found.
  pub fn index_of_first_executed(&amp;self, task: &amp;T) -&gt; Option&lt;usize&gt; {
    self.index_of(|e| e.output_of_executed(task).is_some())
  }
  /// Finds the first [task executed event](Event::Executed) for `task` and returns its index and output as 
  /// `Some((index, output))`, or `None` if no event was found.
  pub fn index_output_of_first_executed(&amp;self, task: &amp;T) -&gt; Option&lt;(usize, &amp;T::Output)&gt; {
    self.index_find_map(|e| e.output_of_executed(task))
  }
}

impl&lt;T: Task&gt; Event&lt;T&gt; {
  /// Returns `Some(stamp)` if this is a [required file event](Event::RequiredFile) for file at `path`, or `None` 
  /// otherwise.
  pub fn stamp_of_required_file(&amp;self, path: &amp;PathBuf) -&gt; Option&lt;&amp;FileStamp&gt; {
    match self {
      Event::RequiredFile { path: p, stamp, .. } if p == path =&gt; Some(stamp),
      _ =&gt; None,
    }
  }

  /// Returns `true` if this is a task execution (execute or executed) event.
  pub fn is_execution(&amp;self) -&gt; bool {
    match self {
      Event::Execute { .. } =&gt; true,
      Event::Executed { .. } =&gt; true,
      _ =&gt; false,
    }
  }
  /// Returns `true` if this is an execution (execute or executed) event for `task`.
  pub fn is_execution_of(&amp;self, task: &amp;T) -&gt; bool {
    match self {
      Event::Execute { task: t } if t == task =&gt; true,
      Event::Executed { task: t, .. } if t == task =&gt; true,
      _ =&gt; false,
    }
  }
  /// Returns `true` if this is a [task execute event](Event::Execute) for `task`.
  pub fn is_execute(&amp;self, task: &amp;T) -&gt; bool {
    match self {
      Event::Execute { task: t } if t == task =&gt; true,
      _ =&gt; false,
    }
  }
  /// Returns `Some(output)` if this is a [task executed event](Event::Executed) for `task`, or `None` otherwise.
  pub fn output_of_executed(&amp;self, task: &amp;T) -&gt; Option&lt;&amp;T::Output&gt; {
    match self {
      Event::Executed { task: t, output: o } if t == task =&gt; Some(o),
      _ =&gt; None,
    }
  }
}</code></pre>
<p>We add several general inspection methods to <code>EventTracker</code>:</p>
<ul>
<li><code>slice</code> and <code>iter</code> provide raw access to all stored <code>Event</code>s,</li>
<li><code>any</code>, <code>count</code>, and <code>one</code> are for checking predicates over all events,</li>
<li><code>index_of</code> for finding the index of the first event given a predicate,</li>
<li><code>find_map</code> and <code>index_find_map</code> for finding the first event given some function, returning the output (and also index in <code>index_find_map</code>) of that function.</li>
</ul>
<p>We add methods for specific kinds of events, following the general methods.
Finally, we add convenience methods to <code>Event</code> for checking specific kinds of events.</p>
<p>Check that the code compiles with <code>cargo test</code>.</p>
<h2 id="implement-composite-tracker"><a class="header" href="#implement-composite-tracker">Implement composite tracker</a></h2>
<p>Currently, we cannot use both <code>EventTracker</code> and <code>WritingTracker</code> at the same time.
We want this so that we can check incrementality and soundness, but also look at standard output for debugging, at the same time.
Therefore, we will implement a <code>CompositeTracker</code> that forwards build events to 2 trackers.</p>
<p>Add the following code to <code>pie/src/tracker/mod.rs</code>:</p>
<pre><code class="language-rust ">/// [`Tracker`] that forwards build events to 2 trackers.
#[derive(Copy, Clone, Debug)]
pub struct CompositeTracker&lt;A1, A2&gt;(pub A1, pub A2);
impl&lt;T: Task, A1: Tracker&lt;T&gt;, A2: Tracker&lt;T&gt;&gt; Tracker&lt;T&gt; for CompositeTracker&lt;A1, A2&gt; {
  fn build_start(&amp;mut self) {
    self.0.build_start();
    self.1.build_start();
  }
  fn build_end(&amp;mut self) {
    self.0.build_end();
    self.1.build_end();
  }

  fn required_file(&amp;mut self, path: &amp;Path, stamper: &amp;FileStamper, stamp: &amp;FileStamp) {
    self.0.required_file(path, stamper, stamp);
    self.1.required_file(path, stamper, stamp);
  }
  fn require_task(&amp;mut self, task: &amp;T, stamper: &amp;OutputStamper) {
    self.0.require_task(task, stamper);
    self.1.require_task(task, stamper);
  }
  fn required_task(&amp;mut self, task: &amp;T, output: &amp;T::Output, stamper: &amp;OutputStamper, stamp: &amp;OutputStamp&lt;T::Output&gt;, was_executed: bool) {
    self.0.required_task(task, output, stamper, stamp, was_executed);
    self.1.required_task(task, output, stamper, stamp, was_executed);
  }

  fn execute(&amp;mut self, task: &amp;T) {
    self.0.execute(task);
    self.1.execute(task);
  }
  fn executed(&amp;mut self, task: &amp;T, output: &amp;T::Output) {
    self.0.executed(task, output);
    self.1.executed(task, output);
  }
}</code></pre>
<p><code>CompositeTracker</code> is a tuple struct containing 2 trackers that implements all tracker methods and forwards them to the 2 contained trackers.
Its tuple fields are <code>pub</code> so it can be constructed with <code>CompositeTracker(t1, t2)</code> and the contained trackers can be accessed with <code>c.0</code> and <code>c.1</code>.</p>
<p>Check that the code compiles with <code>cargo test</code>.</p>
<p>Now that the build event tracking infrastructure is in place, we can start integration testing!</p>
<details id="admonition-download-source-code" class="admonition example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="../../gen/3_min_sound/2_tracker/source.zip">download the source files up to this point</a>.</p>
</div>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../3_min_sound/1_session/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../3_min_sound/1_session/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../src/diff2html-ui-base.min.js"></script>


    </div>
    </body>
</html>
