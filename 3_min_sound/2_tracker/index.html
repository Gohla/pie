<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tracking Build Events - Build your own Programmatic Incremental Build System</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../src/custom.css">
        <link rel="stylesheet" href="../../src/mdbook-admonish.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Introduction</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Programmability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../1_programmability/0_setup/index.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../../1_programmability/1_api/index.html"><strong aria-hidden="true">2.2.</strong> Programmable Build System API</a></li><li class="chapter-item expanded "><a href="../../1_programmability/2_non_incremental/index.html"><strong aria-hidden="true">2.3.</strong> Non-Incremental Context</a></li></ol></li><li class="chapter-item expanded "><a href="../../2_incrementality/index.html"><strong aria-hidden="true">3.</strong> Incrementality</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../2_incrementality/1_require_file/index.html"><strong aria-hidden="true">3.1.</strong> Requiring Files</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/2_stamp/index.html"><strong aria-hidden="true">3.2.</strong> Stamps</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/3_dependency/index.html"><strong aria-hidden="true">3.3.</strong> Dynamic Dependencies</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/4_store/index.html"><strong aria-hidden="true">3.4.</strong> Dependency Graph Store</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/5_context/index.html"><strong aria-hidden="true">3.5.</strong> Incremental Top-Down Context</a></li></ol></li><li class="chapter-item expanded "><a href="../../3_min_sound/index.html"><strong aria-hidden="true">4.</strong> Minimality and Soundness</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../3_min_sound/1_session/index.html"><strong aria-hidden="true">4.1.</strong> Minimality with Sessions</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/2_tracker/index.html" class="active"><strong aria-hidden="true">4.2.</strong> Tracking Build Events</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Prevent Overlapping File Writes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> Prevent Hidden Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> Prevent Cycles</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Improvements</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Serialization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> More Stampers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Configurable Hashing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Efficiency</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Incremental Bottom-Up Context</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Observability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Deferred Tasks</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Appendix</li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Multiple Task Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> On Static Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> On Declarativity</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Related Work</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/edit/master/tutorial/src/3_min_sound/2_tracker/index.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tracking-build-events"><a class="header" href="#tracking-build-events">Tracking Build Events</a></h1>
<p>So far we have had no convenient way to inspect what our build system is doing, apart from <code>println!</code> debugging or attaching a debugger to the program.
In this section, we will change that by tracking build events for debugging and integration testing purposes.</p>
<p>We will:</p>
<ol>
<li>Create a <code>Tracker</code> trait that receives build events through method calls. The <code>Tracker</code> trait can be implemented in different ways to handle build events in different ways.</li>
<li>Implement a <code>NoopTracker</code> that does nothing, removing the tracking overhead.</li>
<li>Make the build system generic over <code>Tracker</code>, such that <code>Context</code> implementations call methods on the tracker to create build events.</li>
<li>Implement a <code>WritingTracker</code> that writes build events to standard output or standard error, for debugging purposes.</li>
<li>Implement an <code>EventTracker</code> that stores build events for later inspection, for integration testing purposes.</li>
<li>Implement a <code>CompositeTracker</code> that forwards build events to 2 other trackers, so we can use multiple trackers at the same time.</li>
</ol>
<h2 id="tracker-trait"><a class="header" href="#tracker-trait"><code>Tracker</code> trait</a></h2>
<p>Add the <code>tracker</code> module to <code>pie/src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff">
 use crate::context::top_down::TopDownContext;
 use crate::store::{Store, TaskNode};

 pub mod stamp;
+pub mod tracker;
 mod context;
 mod fs;
 mod dependency;
 mod store;
</code></pre>
<p>Then create the <code>pie/src/tracker</code> directory, create the <code>pie/src/tracker/mod.rs</code> file, and add the following content:</p>
<pre><code class="language-rust ">use crate::dependency::FileDependency;
use crate::Task;

/// Trait for tracking build events. Can be used to implement logging, event tracing, progress tracking, metrics, etc.
#[allow(unused_variables)]
pub trait Tracker&lt;T: Task&gt; {
  // Dependencies
  fn required_file(&amp;mut self, dependency: &amp;FileDependency) {}
  fn required_task(&amp;mut self, task: &amp;T, output: &amp;T::Output) {}
  // Task execution
  fn execute_task_start(&amp;mut self, task: &amp;T) {}
  fn execute_task_end(&amp;mut self, task: &amp;T, output: &amp;T::Output) {}
  // Top-down builds
  fn require_top_down_initial_start(&amp;mut self, task: &amp;T) {}
  fn require_top_down_initial_end(&amp;mut self, task: &amp;T, output: &amp;T::Output) {}
}</code></pre>
<p>The <code>Tracker</code> trait is generic over <code>Task</code>.</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="#admonition-note"></a></p>
</div>
<div>
<p>Here, we chose to put the <code>Task</code> constraint on the trait itself.
This will not lead to cascading constraints, as the <code>Tracker</code> trait will only be used as a constraint in <code>impl</code>s, not in structs or other traits.</p>
</div>
</div>
<p><code>Tracker</code> has methods corresponding to events that happen during a build, such as requiring a file, requiring a task, and executing a task.
These methods accept <code>&amp;mut self</code> so that tracker implementations can perform mutation, such as storing a build event.
We provide default methods that do nothing so that implementors of <code>Tracker</code> only have to override the methods for events they are interested in.
We use <code>#[allow(unused_variables)]</code> on the trait to not give warnings for unused variables, as all variables are unused due to the empty default implementations.</p>
<details id="admonition-default-methods" class="admonition info">
<summary class="admonition-title">
<p>Default methods</p>
<p><a class="admonition-anchor-link" href="#admonition-default-methods"></a></p>
</summary>
<div>
<p>Adding a method to <code>Tracker</code> with a default implementation ensures that implementations of <code>Tracker</code> do not have to be changed to work with the new method.
This is both good and bad.
Good because we can add methods without breaking compatibility.
Bad because we can forget to handle a new method, which can lead to problems with for example a composite tracker that forwards events to 2 trackers.
In this tutorial we chose the convenient option, but be sure to think about these kind of tradeoffs yourself!</p>
</div>
</details>
<p>Check that the code compiles with <code>cargo test</code>.</p>
<h2 id="no-op-tracker"><a class="header" href="#no-op-tracker">No-op tracker</a></h2>
<p>Add a no-op tracker, which is a tracker that does nothing, by adding the following code to <code>pie/src/tracker/mod.rs</code>:</p>
<pre><code class="language-rust ">/// [`Tracker`] that does nothing.
pub struct NoopTracker;
impl&lt;T: Task&gt; Tracker&lt;T&gt; for NoopTracker {}</code></pre>
<p>Due to the default methods that do nothing on <code>Tracker</code>, this implementation is extremely simple. </p>
<details id="admonition-removing-tracker-overhead" class="admonition info">
<summary class="admonition-title">
<p>Removing tracker overhead</p>
<p><a class="admonition-anchor-link" href="#admonition-removing-tracker-overhead"></a></p>
</summary>
<div>
<p>We will use generics to select which tracker implementation to use.
Therefore, all calls to trackers are statically dispatched, and could be inlined.
Because <code>NoopTracker</code> only has empty methods, and those empty methods can be inlined, using <code>NoopTracker</code> will effectively remove all tracking code from your binary, thus removing the overhead of tracking if you don’t want it.</p>
<p>In this tutorial, we do not annotate methods with <a href="https://nnethercote.github.io/perf-book/inlining.html" title="" target="_blank">
<code>#[inline]</code></a>, meaning that the Rust compiler (and the LLVM backend) will make its own decisions on what to make inlineable and what not.
If you care about performance here, be sure to annotate those default empty methods with <code>#[inline]</code>.</p>
</div>
</details>
<h2 id="using-the-tracker-trait"><a class="header" href="#using-the-tracker-trait">Using the <code>Tracker</code> trait</a></h2>
<p>Now we will make the build system generic over <code>Tracker</code>, and insert <code>Tracker</code> calls in context implementations.</p>
<p>Make <code>Pie</code> and <code>Session</code> generic over <code>Tracker</code> by modifying <code>src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::fmt::Debug;
 use std::fs::File;
 use std::hash::Hash;
 use std::io;
 use std::path::Path;

 use stamp::{FileStamper, OutputStamper};

 use crate::context::top_down::TopDownContext;
 use crate::store::{Store, TaskNode};
+use crate::tracker::{NoopTracker, Tracker};

 pub mod stamp;
 pub mod tracker;
 mod context;
 mod fs;
 mod dependency;
 mod store;

 /// A unit of computation in a programmatic incremental build system.
 pub trait Task: Clone + Eq + Hash + Debug {
@@ -53,49 +54,54 @@
     self.require_task_with_stamper(task, self.default_output_stamper())
   }
   /// Requires given `task`, recording a dependency (using given `stamper`) and selectively executing it. Returns its
   /// up-to-date output.
   fn require_task_with_stamper(&amp;mut self, task: &amp;T, stamper: OutputStamper) -&gt; T::Output;
   /// Returns the default output stamper.
   fn default_output_stamper(&amp;self) -&gt; OutputStamper { OutputStamper::Equals }
 }

 /// Main entry point into PIE, a sound and incremental programmatic build system.
-pub struct Pie&lt;T, O&gt; {
+pub struct Pie&lt;T, O, A = NoopTracker&gt; {
   store: Store&lt;T, O&gt;,
+  tracker: A,
 }

 impl&lt;T: Task&gt; Default for Pie&lt;T, T::Output&gt; {
-  fn default() -&gt; Self { Self { store: Store::default() } }
+  fn default() -&gt; Self { Self::with_tracker(NoopTracker) }
 }

-impl&lt;T: Task&gt; Pie&lt;T, T::Output&gt; {
+impl&lt;T: Task, A: Tracker&lt;T&gt;&gt; Pie&lt;T, T::Output, A&gt; {
+  /// Creates a new [`Pie`] instance with given `tracker`.
+  pub fn with_tracker(tracker: A) -&gt; Self { Self { store: Store::default(), tracker } }
   /// Creates a new build session. Only one session may be active at once, enforced via mutable (exclusive) borrow.
-  pub fn new_session(&amp;mut self) -&gt; Session&lt;T, T::Output&gt; { Session::new(self) }
+  pub fn new_session(&amp;mut self) -&gt; Session&lt;T, T::Output, A&gt; { Session::new(self) }
   /// Runs `f` inside a new build session.
-  pub fn run_in_session&lt;R&gt;(&amp;mut self, f: impl FnOnce(Session&lt;T, T::Output&gt;) -&gt; R) -&gt; R {
+  pub fn run_in_session&lt;R&gt;(&amp;mut self, f: impl FnOnce(Session&lt;T, T::Output, A&gt;) -&gt; R) -&gt; R {
     let session = self.new_session();
     f(session)
   }
 }

 /// A session in which builds are executed.
-pub struct Session&lt;'p, T, O&gt; {
+pub struct Session&lt;'p, T, O, A&gt; {
   store: &amp;'p mut Store&lt;T, O&gt;,
+  tracker: &amp;'p mut A,
   current_executing_task: Option&lt;TaskNode&gt;,
   dependency_check_errors: Vec&lt;io::Error&gt;,
 }

-impl&lt;'p, T: Task&gt; Session&lt;'p, T, T::Output&gt; {
-  fn new(pie: &amp;'p mut Pie&lt;T, T::Output&gt;) -&gt; Self {
+impl&lt;'p, T: Task, A: Tracker&lt;T&gt;&gt; Session&lt;'p, T, T::Output, A&gt; {
+  fn new(pie: &amp;'p mut Pie&lt;T, T::Output, A&gt;) -&gt; Self {
     Self {
       store: &amp;mut pie.store,
+      tracker: &amp;mut pie.tracker,
       current_executing_task: None,
       dependency_check_errors: Vec::default(),
     }
   }

   /// Requires `task`, returning its up-to-date output.
   pub fn require(&amp;mut self, task: &amp;T) -&gt; T::Output {
     self.current_executing_task = None;
     TopDownContext::new(self).require_initial(task)
   }</code></pre>
<p>TODO: explain
TODO: default type for generic</p>
<p>Make <code>TopDownContext</code> generic over <code>Tracker</code> and insert method calls in <code>src/context/top_down.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::fs::File;
 use std::io;
 use std::path::Path;

 use crate::{Context, fs, Session, Task};
 use crate::dependency::{FileDependency, TaskDependency};
 use crate::stamp::{FileStamper, OutputStamper};
 use crate::store::TaskNode;
+use crate::tracker::Tracker;

-pub struct TopDownContext&lt;'p, 's, T, O&gt; {
-  session: &amp;'s mut Session&lt;'p, T, O&gt;,
+pub struct TopDownContext&lt;'p, 's, T, O, A&gt; {
+  session: &amp;'s mut Session&lt;'p, T, O, A&gt;,
 }

-impl&lt;'p, 's, T: Task&gt; TopDownContext&lt;'p, 's, T, T::Output&gt; {
-  pub fn new(session: &amp;'s mut Session&lt;'p, T, T::Output&gt;) -&gt; Self { Self { session } }
+impl&lt;'p, 's, T: Task, A: Tracker&lt;T&gt;&gt; TopDownContext&lt;'p, 's, T, T::Output, A&gt; {
+  pub fn new(session: &amp;'s mut Session&lt;'p, T, T::Output, A&gt;) -&gt; Self { Self { session } }

   pub fn require_initial(&amp;mut self, task: &amp;T) -&gt; T::Output {
-    self.require_task(task)
+    self.session.tracker.require_top_down_initial_start(task);
+    let output = self.require_task(task);
+    self.session.tracker.require_top_down_initial_end(task, &amp;output);
+    output
   }
 }


-impl&lt;'p, 's, T: Task&gt; Context&lt;T&gt; for TopDownContext&lt;'p, 's, T, T::Output&gt; {
+impl&lt;'p, 's, T: Task, A: Tracker&lt;T&gt;&gt; Context&lt;T&gt; for TopDownContext&lt;'p, 's, T, T::Output, A&gt; {
   fn require_file_with_stamper&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, stamper: FileStamper) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
     let Some(current_executing_task_node) = &amp;self.session.current_executing_task else {
       return fs::open_if_file(path); // No current executing task, so no dependency needs to be made.
     };
     let path = path.as_ref();
     let node = self.session.store.get_or_create_file_node(path);
     let (dependency, file) = FileDependency::new_with_file(path, stamper)?;
+    self.session.tracker.required_file(&amp;dependency);
     self.session.store.add_file_require_dependency(current_executing_task_node, &amp;node, dependency);
     Ok(file)
   }

   fn require_task_with_stamper(&amp;mut self, task: &amp;T, stamper: OutputStamper) -&gt; T::Output {
     let node = self.session.store.get_or_create_task_node(task);

     // Get required task output by executing it if needed, or by getting the output from the store if not needed.
     let output = if self.should_execute_task(&amp;node) {
+      self.session.tracker.execute_task_start(task);
       self.session.store.reset_task(&amp;node);
       let previous_executing_task = self.session.current_executing_task.replace(node);
       let output = task.execute(self);
       self.session.current_executing_task = previous_executing_task;
       self.session.store.set_task_output(&amp;node, output.clone());
+      self.session.tracker.execute_task_end(task, &amp;output);
       output
     } else {
       // Correctness: when `should_execute_task` returns `true`, the above block is executed. Otherwise this block is 
       // executed and `should_execute_task` ensures that the task has an output.
       self.session.store.get_task_output(&amp;node).clone()
     };

     // Create task require dependency if a task is currently executing (i.e., we are not requiring the initial task).
     if let Some(current_executing_task_node) = &amp;self.session.current_executing_task {
       let dependency = TaskDependency::new(task.clone(), stamper, output.clone());
       if self.session.store.add_task_require_dependency(current_executing_task_node, &amp;node, dependency).is_err() {
         let current_executing_task = self.session.store.get_task(current_executing_task_node);
         panic!(&quot;Cyclic task dependency; current executing task '{:?}' is requiring task '{:?}' which was already required&quot;, current_executing_task, task);
       }
     }

+    self.session.tracker.required_task(task, &amp;output);
     output
   }
 }

-impl&lt;'p, 's, T: Task&gt; TopDownContext&lt;'p, 's, T, T::Output&gt; {
+impl&lt;'p, 's, T: Task, A: Tracker&lt;T&gt;&gt; TopDownContext&lt;'p, 's, T, T::Output, A&gt; {
   /// Checks whether given task should be executed, returning `true` if it should be executed. A task should be executed
   /// if any of its dependencies are inconsistent, or when it has no output.
   fn should_execute_task(&amp;mut self, node: &amp;TaskNode) -&gt; bool {
     // Borrow: because we pass `self` (which is `&amp;mut self`) to `is_inconsistent` for recursive consistency checking, 
     //         we need to clone and collect dependencies into a `Vec`. Otherwise we have an immutable borrow of `self`
     //         through `self.store` while we create a mutable borrow of `self`, which is not allowed.
     let dependencies: Vec&lt;_&gt; = self.session.store.get_dependencies_of_task(node).cloned().collect();
     for dependency in dependencies {
       match dependency.is_inconsistent(self) {
         Ok(Some(_)) =&gt; return true,</code></pre>
<p>TODO: explain</p>
<p>Check that the code compiles with <code>cargo test</code>.</p>
<p>We won’t modify <code>NonIncrementalContext</code> to use a tracker, as <code>NonIncrementalContext</code> has no state, so we cannot pass a tracker to it.</p>
<h2 id="implement-writing-tracker"><a class="header" href="#implement-writing-tracker">Implement writing tracker</a></h2>
<p>implement <code>WritingTracker</code>
test build</p>
<p>change example to use it
run example, see build events</p>
<h2 id="implement-event-tracker"><a class="header" href="#implement-event-tracker">Implement event tracker</a></h2>
<h2 id="implement-composite-tracker"><a class="header" href="#implement-composite-tracker">Implement composite tracker</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../3_min_sound/1_session/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../3_min_sound/1_session/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../src/diff.js"></script>


    </div>
    </body>
</html>
