<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Prevent Overlapping File Writes - Build your own Programmatic Incremental Build System</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../.././diff2html.min.css">
        <link rel="stylesheet" href="../.././mdbook-admonish.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../0_intro/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../0_intro/1_setup/index.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li></ol></li><li class="chapter-item expanded "><a href="../../1_programmability/index.html"><strong aria-hidden="true">2.</strong> Programmability</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../1_programmability/1_api/index.html"><strong aria-hidden="true">2.1.</strong> Programmable Build System API</a></li><li class="chapter-item expanded "><a href="../../1_programmability/2_non_incremental/index.html"><strong aria-hidden="true">2.2.</strong> Non-Incremental Context</a></li></ol></li><li class="chapter-item expanded "><a href="../../2_incrementality/index.html"><strong aria-hidden="true">3.</strong> Incrementality</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../2_incrementality/1_require_file/index.html"><strong aria-hidden="true">3.1.</strong> Requiring Files</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/2_stamp/index.html"><strong aria-hidden="true">3.2.</strong> Stamps</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/3_dependency/index.html"><strong aria-hidden="true">3.3.</strong> Dynamic Dependencies</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/4_store/index.html"><strong aria-hidden="true">3.4.</strong> Dependency Graph Store</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/5_context/index.html"><strong aria-hidden="true">3.5.</strong> Incremental Top-Down Context</a></li><li class="chapter-item expanded "><a href="../../2_incrementality/6_example/index.html"><strong aria-hidden="true">3.6.</strong> Incrementality Example</a></li></ol></li><li class="chapter-item expanded "><a href="../../3_min_sound/index.html"><strong aria-hidden="true">4.</strong> Testing Incrementality & Soundness</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../3_min_sound/1_session/index.html"><strong aria-hidden="true">4.1.</strong> Minimality with Sessions</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/2_tracker/index.html"><strong aria-hidden="true">4.2.</strong> Tracking Build Events</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/3_test/index.html"><strong aria-hidden="true">4.3.</strong> Integration Testing</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/4_fix_task_dep/index.html"><strong aria-hidden="true">4.4.</strong> Fix Superfluous Task Dependency</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/5_overlap/index.html" class="active"><strong aria-hidden="true">4.5.</strong> Prevent Overlapping File Writes</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/6_hidden_dep/index.html"><strong aria-hidden="true">4.6.</strong> Prevent Hidden Dependencies</a></li><li class="chapter-item expanded "><a href="../../3_min_sound/7_cycle/index.html"><strong aria-hidden="true">4.7.</strong> Prevent Cycles</a></li></ol></li><li class="chapter-item expanded "><a href="../../4_next/index.html"><strong aria-hidden="true">5.</strong> What's Next?</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
<!-- CHANGE: removed all but light and ayu theme, and renamed ayu to dark -->                          
<!--                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>-->
<!--                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>-->
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Gohla/pie/edit/master/tutorial/src/3_min_sound/5_overlap/index.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="prevent-overlapping-file-writes"><a class="header" href="#prevent-overlapping-file-writes">Prevent Overlapping File Writes</a></h1>
<p>So far we have only considered reading files in the build system.
However, there are many tasks that also write files.
For example, a C compiler reads a C source file (and header files) and writes an object file with the compiled result, which is typically an intermediate file that gets passed to a linker.
Another example is a file copy task that reads a file and copies it to another file.</p>
<p>We can handle file writes in tasks with <code>context.require_file</code>.
However, what should happen when two tasks write to the same file?
In a non-incremental setting, the last writer wins by overwriting (or appending to) the file.
Does this behaviour also occur in our incremental build system?</p>
<p>Unfortunately, this is not always the case in our incremental build system, because we can <code>require</code> individual tasks in a specific order that would cause an inconsistency, making the first writer win.
This is a bit tricky to explain without an example, so we will first add some testing tasks and write a test that showcases the problem.
In this section, we will continue with:</p>
<ol>
<li>Add the <code>WriteFile</code> and <code>Sequence</code> tasks to the testing tasks.</li>
<li>Create a <code>test_overlapping_file_write</code> test to showcase the issue.</li>
<li>Introduce a new kind of dependency: a <em>provide file dependency</em> for writing to (and creating) files.</li>
<li>Prevent overlapping file writes by checking for them at runtime, fixing the issue.</li>
<li>Improve and add additional tests</li>
</ol>
<h2 id="add-writefile-and-sequence-tasks"><a class="header" href="#add-writefile-and-sequence-tasks">Add <code>WriteFile</code> and <code>Sequence</code> tasks</a></h2>
<p>Add the <code>WriteFile</code> and <code>Sequence</code> tasks to <code>pie/tests/common/mod.rs</code>: </p>
<div class="diff2html" id="diff2html_0"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/common/mod.rs
+++ pie/tests/common/mod.rs
@@ -1,6 +1,7 @@
 use std::io::{BufWriter, ErrorKind, Read, Stdout};
 use std::path::PathBuf;
 
+use dev_shared::write_until_modified;
 use pie::{Context, Pie, Task};
 use pie::stamp::FileStamper;
 use pie::tracker::CompositeTracker;
@@ -63,8 +64,10 @@
 pub enum TestTask {
   Return(&'static str),
   ReadFile(PathBuf, FileStamper),
+  WriteFile(Box<TestTask>, PathBuf, FileStamper),
   ToLower(Box<TestTask>),
   ToUpper(Box<TestTask>),
+  Sequence(Vec<TestTask>),
 }
 impl Task for TestTask {
   type Output = Result<TestOutput, ErrorKind>;
@@ -78,6 +81,12 @@
         }
         Ok(string.into())
       }
+      TestTask::WriteFile(string_provider_task, path, stamper) => {
+        let string = context.require_task(string_provider_task.as_ref())?.into_string();
+        write_until_modified(path, string.as_bytes()).map_err(|e| e.kind())?;
+        context.require_file_with_stamper(path, *stamper).map_err(|e| e.kind())?;
+        Ok(TestOutput::Unit)
+      }
       TestTask::ToLower(string_provider_task) => {
         let string = context.require_task(string_provider_task)?.into_string();
         Ok(string.to_lowercase().into())
@@ -86,6 +95,12 @@
         let string = context.require_task(string_provider_task)?.into_string();
         Ok(string.to_uppercase().into())
       }
+      TestTask::Sequence(tasks) => {
+        for task in tasks {
+          context.require_task(task)?;
+        }
+        Ok(TestOutput::Unit)
+      }
     }
   }
 }
@@ -94,19 +109,25 @@
 #[derive(Clone, Eq, PartialEq, Hash, Debug)]
 pub enum TestOutput {
   String(String),
+  Unit,
 }
 impl From<String> for TestOutput {
   fn from(value: String) -> Self { Self::String(value) }
 }
+impl From<()> for TestOutput {
+  fn from(_: ()) -> Self { Self::Unit }
+}
 impl TestOutput {
   pub fn as_str(&self) -> &str {
     match self {
       Self::String(s) => &s,
+      _ => panic!("{:?} does not contain a string", self),
     }
   }
   pub fn into_string(self) -> String {
     match self {
       Self::String(s) => s,
+      _ => panic!("{:?} does not contain a string", self),
     }
   }
 }
`;
    let target = document.getElementById('diff2html_0');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p><code>WriteFile</code> requires a string providing task to produce a string, writes that string to given file, then requires the file with given stamper to create a dependency.
It uses <code>write_until_modified</code> to ensure that writes change the modification time, which we need for consistent testing.
<code>Sequence</code> requires multiple tasks stored as a <code>Vec&lt;TestTask&gt;</code>.
Both return <code>TestOutput::Unit</code> when successful, but propagate errors.
<code>TestOutput::Unit</code> is like <code>()</code>, the unit type with a single value.</p>
<p>Because <code>TestOutput</code> now has two variants, the <code>as_str</code> and <code>into_string</code> methods can now fail with a panic (which is fine for testing).</p>
<details id="admonition-why-not-use-the-inconsequential-stamper" class="admonition admonish-question">
<summary class="admonition-title">
<p>Why not use the Inconsequential Stamper?</p>
<p><a class="admonition-anchor-link" href="#admonition-why-not-use-the-inconsequential-stamper"></a></p>
</summary>
<div>
<p><code>Sequence</code> ignores <code>Result::Ok</code> outputs from required tasks, but it propagates <code>Result::Err</code> outputs. 
Therefore, we cannot use the <code>Inconsequential</code> output stamper, as it would not re-execute <code>Sequence</code> when a task it requires goes from returning <code>Ok</code> to <code>Err</code>, and vice versa.</p>
<p>We could, however, implement a stamper that ignores changes to the <code>Ok</code> variant of results, but not the <code>Err</code> variant, to increase incrementality.</p>
</div>
</details>
<h2 id="test-to-showcase-the-issue"><a class="header" href="#test-to-showcase-the-issue">Test to showcase the issue</a></h2>
<p>Now we write a test to showcase the issue.
Add the following test to <code>pie/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_1"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -1,4 +1,4 @@
-use std::fs::write;
+use std::fs::{read_to_string, write};
 use std::io;
 use std::ops::RangeInclusive;
 
@@ -245,3 +245,45 @@
 
   Ok(())
 }
+
+
+// Overlapping provided file tests
+
+#[test]
+fn test_show_overlap_issue() -> Result<(), io::Error> {
+  let mut pie = test_pie();
+  let temp_dir = create_temp_dir()?;
+
+  let output_file = temp_dir.path().join("out.txt");
+
+  let ret = Return("Hi there");
+  let write_1 = WriteFile(Box::new(ret.clone()), output_file.clone(), FileStamper::Modified);
+
+  let input_file = temp_dir.path().join("in.txt");
+  write(&input_file, "Hello, World!")?;
+  let read = ReadFile(input_file.clone(), FileStamper::Modified);
+  let write_2 = WriteFile(Box::new(read.clone()), output_file.clone(), FileStamper::Modified);
+
+  let seq = Sequence(vec![write_1.clone(), write_2.clone()]);
+
+  // Require ${"`"}seq${"`"}. The last writer, ${"`"}write_2${"`"} (${"`"}WriteFile(ReadFile(input_file))${"`"}), wins because ${"`"}Sequence${"`"} executes
+  // tasks in order.
+  pie.require(&seq)?;
+  // Assert that ${"`"}output_file${"`"} contains the string from ${"`"}input_file${"`"}.
+  assert_eq!(read_to_string(&output_file)?, "Hello, World!");
+
+  // Change ${"`"}input_file${"`"} such that ${"`"}write_2${"`"} becomes inconsistent.
+  write_until_modified(&input_file, "World, Hello?")?;
+
+  // Require ${"`"}write_1${"`"} and assert that it is executed, because ${"`"}write_2${"`"} modified ${"`"}output_file${"`"} after ${"`"}write_1${"`"}, thus
+  // ${"`"}write_1${"`"}'s file dependency to ${"`"}output_file${"`"} is inconsistent.
+  pie.require_then_assert_one_execute(&write_1)?;
+  // However, because we required ${"`"}write_1${"`"} directly, instead of through ${"`"}seq${"`"}, ${"`"}output_file${"`"} contains the string that
+  // ${"`"}ret${"`"} returned, even though ${"`"}write_2${"`"} is inconsistent and should win.
+  assert_eq!(read_to_string(&output_file)?, "Hi there");
+  // The contents of ${"`"}output_file${"`"} is thus dependent on which tasks and in which order we require them. This
+  // inconsistent behaviour is undesirable.
+  // Note: this is asserting the current behaviour, not the desired behaviour, which is to disallow this!
+
+  Ok(())
+}
`;
    let target = document.getElementById('diff2html_1');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>In this test, we create 2 <code>WriteFile</code> tasks that both write to <code>output_file</code>.
<code>write_1</code> gets the string to write from <code>ret</code>, which returns <code>&quot;Hi there&quot;</code>.
<code>write_2</code> gets the string to write from <code>read</code>, which returns the contents of <code>input_file</code>.
Both write tasks are put into a <code>Sequence</code>, with first <code>write_1</code>, then <code>write_2</code>.</p>
<p>We require <code>seq</code> and assert that <code>output_file</code> should contain the result of executing <code>write_2</code>, which requires <code>read</code> to get the contents of <code>input_file</code>.
This result makes sense, it’s what would happen in a non-incremental setting.</p>
<p>However, we then modify <code>input_file</code> to make <code>write_2</code> inconsistent, and then require <code>write_1</code> directly instead of requiring <code>seq</code>.
The result is that <code>output_file</code> now contains <code>&quot;Hi there&quot;</code>, even though <code>write_2</code> is inconsistent!</p>
<p>This behaviour stems from the fact that we can <code>require</code> individual tasks, which is actually a great feature, not a bug!
When we <code>require</code> a task, we are asking the build system to make <strong>that task</strong> consistent, and get its up-to-date output.
We are <strong>not</strong> asking the build system to make <strong>all</strong> tasks consistent.
The build system recursively checks and executes only the tasks that are absolutely necessary to make that task consistent.
If it would not do that, it would not truly be incremental!
Therefore, we cannot (and shouldn’t) get rid of this feature, and instead need to find another solution to this problem.</p>
<p>While we require tasks “manually” here, through the <code>Pie</code> / <code>Session</code> API, this problem can also occur with tasks that require other tasks.
For example, if <code>seq</code> would just be <code>Sequence(vec![write_1])</code>, and we’d end up in the same inconsistent state when requiring <code>seq</code>.
Especially in large incremental builds with many different tasks, this can easily occur accidentally, causing subtle incrementality bugs.</p>
<p>Let’s go back to the test.
In the test, <code>output_file</code> is not in a consistent state because <code>write_2</code> is inconsistent and needs to be executed to bring <code>output_file</code> into a consistent state.
However, if <code>write_2</code> would write to another file, there would be no inconsistency.
Let’s write a test with separate output files.</p>
<p>Add the following test to <code>pie/tests/top_down.rs</code>:</p>
<pre><code class="language-rust ">#[test]
fn test_separate_output_files() -&gt; Result&lt;(), io::Error&gt; {
  let mut pie = test_pie();
  let temp_dir = create_temp_dir()?;

  let ret = Return(&quot;Hi there&quot;);
  let output_file_1 = temp_dir.path().join(&quot;out_1.txt&quot;);
  let write_1 = WriteFile(Box::new(ret.clone()), output_file_1.clone(), FileStamper::Modified);

  let input_file = temp_dir.path().join(&quot;in.txt&quot;);
  write(&amp;input_file, &quot;Hello, World!&quot;)?;
  let read = ReadFile(input_file.clone(), FileStamper::Modified);
  let output_file_2 = temp_dir.path().join(&quot;out_2.txt&quot;);
  let write_2 = WriteFile(Box::new(read.clone()), output_file_2.clone(), FileStamper::Modified);

  let seq = Sequence(vec![write_1.clone(), write_2.clone()]);

  pie.require(&amp;seq)?;
  assert_eq!(read_to_string(&amp;output_file_1)?, &quot;Hi there&quot;);
  assert_eq!(read_to_string(&amp;output_file_2)?, &quot;Hello, World!&quot;);

  write_until_modified(&amp;input_file, &quot;World, Hello?&quot;)?;

  // Require `write_1` to make `output_file_1` consistent.
  pie.require_then_assert_no_execute(&amp;write_1)?;
  assert_eq!(read_to_string(&amp;output_file_1)?, &quot;Hi there&quot;);
  // Require `write_2` to make `output_file_2` consistent.
  pie.require_then_assert_one_execute(&amp;write_2)?;
  assert_eq!(read_to_string(&amp;output_file_2)?, &quot;World, Hello?&quot;);

  Ok(())
}</code></pre>
<p>Here, <code>write_1</code> writes to <code>output_file_1</code>, and <code>write_2</code> writes to <code>output_file_2</code>.
Thus, requiring <code>write_1</code> makes <code>output_file_1</code> consistent.
Requiring <code>write_2</code> makes <code>output_file_2</code> consistent.
The last two <code>require_then_assert_no_execute</code> statements do this, and there are no inconsistencies with these separate output files.
Therefore, to prevent confusion, inconsistencies, and (subtle) incrementality bugs, we will detect overlapping file writes and disallow them.</p>
<p>Before continuing, confirm both tests succeed with <code>cargo test</code>.
We will modify the first test to assert the desired behaviour later.</p>
<details id="admonition-reduce-programming-errors-by-returning-paths" class="admonition admonish-tip">
<summary class="admonition-title">
<p>Reduce Programming Errors by Returning Paths</p>
<p><a class="admonition-anchor-link" href="#admonition-reduce-programming-errors-by-returning-paths"></a></p>
</summary>
<div>
<p>In this last test, we can still make a programming error where we read an output file without first requiring the task that makes that output file consistent.
We can mostly solve that by having <code>WriteFile</code> return the path it wrote to:</p>
<pre><code class="language-rust">TestTask::WriteFile(string_provider_task, path, stamper) =&gt; {
  let string = context.require_task(string_provider_task.as_ref())?.into_string();
  write_until_modified(path, string.as_bytes()).map_err(|e| e.kind())?;
  context.require_file_with_stamper(path, *stamper).map_err(|e| e.kind())?;
  Ok(TestOutput::Path(path.clone()))
}</code></pre>
<p>Then you can have <code>WriteFile</code> take ownership of the path so we don’t accidentally use it:</p>
<pre><code class="language-rust">let ret = Return(&quot;Hi there&quot;);
let write_1 = WriteFile(Box::new(ret.clone()), temp_dir.path().join(&quot;out_1.txt&quot;), FileStamper::Modified);</code></pre>
<p>And you can read the output file with:</p>
<pre><code class="language-rust">{
  let output_file = pie.require_then_assert_no_execute(&amp;write_1)?;
  assert_eq!(read_to_string(output_file.as_path())?, &quot;Hi there&quot;);
}</code></pre>
<p>You can still manually construct the path to the output file and read it to break this, but at least this prevents most accidental reads.</p>
</div>
</details>
<h2 id="implement-provided-files"><a class="header" href="#implement-provided-files">Implement provided files</a></h2>
<p>We currently have no means to disallow overlapping file writes.
We only have one kind of file dependency: require file, which is currently used for both reading from and writing to files.
It’s perfectly fine to read from a single file from multiple tasks, so we can’t disallow multiple tasks from creating a require file dependency to the same file.
Therefore, we must introduce a new kind of dependency for writing to (and creating) files: the <em>provide file dependency</em>.
A file may only be provided by one task.</p>
<p>To implement this dependency, we will:</p>
<ol>
<li>Add a <code>ProvideFile</code> variant to <code>Dependency</code>.</li>
<li>Update <code>Tracker</code> and implementations to handle file provide dependencies.</li>
<li>Add a <code>add_file_provide_dependency</code> method to <code>Store</code>.</li>
<li>Add <code>provide_file</code> methods to <code>Context</code> and implement them in implementations.</li>
</ol>
<h3 id="add-providefile-variant-to-dependency"><a class="header" href="#add-providefile-variant-to-dependency">Add <code>ProvideFile</code> variant to <code>Dependency</code></a></h3>
<p>Modify <code>pie/src/dependency.rs</code>:</p>
<div class="diff2html" id="diff2html_2"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/dependency.rs
+++ pie/src/dependency.rs
@@ -109,6 +109,7 @@
 #[derive(Clone, Eq, PartialEq, Debug)]
 pub enum Dependency<T, O> {
   RequireFile(FileDependency),
+  ProvideFile(FileDependency),
   RequireTask(TaskDependency<T, O>),
 }
 
@@ -127,6 +128,8 @@
     let option = match self {
       Dependency::RequireFile(d) => d.is_inconsistent()?
         .map(|s| Inconsistency::File(s)),
+      Dependency::ProvideFile(d) => d.is_inconsistent()?
+        .map(|s| Inconsistency::File(s)),
       Dependency::RequireTask(d) => d.is_inconsistent(context)
         .map(|s| Inconsistency::Task(s)),
     };
@@ -171,14 +174,17 @@
     write(&temp_file, "test1")?;
 
     let file_dependency = FileDependency::new(temp_file.path(), FileStamper::Modified)?;
-    let dependency: Dependency<ReadStringFromFile, String> = Dependency::RequireFile(file_dependency.clone());
+    let require_dependency: Dependency<ReadStringFromFile, String> = Dependency::RequireFile(file_dependency.clone());
+    let provide_dependency: Dependency<ReadStringFromFile, String> = Dependency::ProvideFile(file_dependency.clone());
     assert!(file_dependency.is_inconsistent()?.is_none());
-    assert!(dependency.is_inconsistent(&mut context)?.is_none());
+    assert!(require_dependency.is_inconsistent(&mut context)?.is_none());
+    assert!(provide_dependency.is_inconsistent(&mut context)?.is_none());
 
     // Change the file, changing the stamp the stamper will create next time, making the file dependency inconsistent.
     write_until_modified(&temp_file, "test2")?;
     assert!(file_dependency.is_inconsistent()?.is_some());
-    assert!(dependency.is_inconsistent(&mut context)?.is_some());
+    assert!(require_dependency.is_inconsistent(&mut context)?.is_some());
+    assert!(provide_dependency.is_inconsistent(&mut context)?.is_some());
 
     Ok(())
   }
`;
    let target = document.getElementById('diff2html_2');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We add the <code>ProvideFile</code> variant to <code>Dependency</code>, handle it in <code>is_inconsistent</code>, and update the unit test to also test that variant.
If you compile the code, you’ll get an error because this new variant needs to be handled in <code>WritingTracker</code>, so let’s update the trackers first.</p>
<h3 id="update-tracker-and-implementations"><a class="header" href="#update-tracker-and-implementations">Update <code>Tracker</code> and implementations</a></h3>
<p>Update <code>pie/src/tracker/mod.rs</code>:</p>
<div class="diff2html" id="diff2html_3"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/tracker/mod.rs
+++ pie/src/tracker/mod.rs
@@ -15,8 +15,10 @@
   /// End: completed build.
   fn build_end(&mut self) {}
 
-  /// End: created a file ${"`"}dependency${"`"}.
+  /// End: created a require file ${"`"}dependency${"`"}.
   fn require_file_end(&mut self, dependency: &FileDependency) {}
+  /// End: created a provide file ${"`"}dependency${"`"}.
+  fn provide_file_end(&mut self, dependency: &FileDependency) {}
   /// Start: require ${"`"}task${"`"} using ${"`"}stamper${"`"}.
   fn require_task_start(&mut self, task: &T, stamper: &OutputStamper) {}
   /// End: required a task, resulting in a task ${"`"}dependency${"`"} and ${"`"}output${"`"}, and the task ${"`"}was_executed${"`"}.
@@ -55,6 +57,10 @@
     self.1.build_end();
   }
 
+  fn provide_file_end(&mut self, dependency: &FileDependency) {
+    self.0.provide_file_end(dependency);
+    self.1.provide_file_end(dependency);
+  }
   fn require_file_end(&mut self, dependency: &FileDependency) {
     self.0.require_file_end(dependency);
     self.1.require_file_end(dependency);
`;
    let target = document.getElementById('diff2html_3');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We add <code>provide_file_end</code> to <code>Tracker</code> and handle it in <code>CompositeTracker</code>.</p>
<p>Update <code>pie/src/tracker/writing.rs</code>:</p>
<div class="diff2html" id="diff2html_4"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/tracker/writing.rs
+++ pie/src/tracker/writing.rs
@@ -70,8 +70,11 @@
   }
 
   fn require_file_end(&mut self, dependency: &FileDependency) {
-    self.writeln(format_args!("- {}", dependency.path().display()));
+    self.writeln(format_args!("r {}", dependency.path().display()));
   }
+  fn provide_file_end(&mut self, dependency: &FileDependency) {
+    self.writeln(format_args!("p {}", dependency.path().display()));
+  }
   fn require_task_start(&mut self, task: &T, _stamper: &OutputStamper) {
     self.writeln(format_args!("→ {:?}", task));
     self.indent();
@@ -99,7 +102,7 @@
     inconsistency: Result<Option<&Inconsistency<T::Output>>, &io::Error>
   ) {
     match dependency {
-      Dependency::RequireFile(d) => {
+      Dependency::RequireFile(d) | Dependency::ProvideFile(d) => {
         match inconsistency {
           Err(e) => self.writeln(format_args!("✗ {} (err: {:?})", d.path().display(), e)),
           Ok(Some(Inconsistency::File(s))) =>
`;
    let target = document.getElementById('diff2html_4');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We change <code>require_file_end</code> to print <code>r</code> instead of <code>-</code> to distinguish it from file provides.
We implement the <code>provide_file_end</code> method, printing the provided file.
Finally, we support the <code>Dependency::ProvideFile</code> variant by adding a branch for it in the match statement.</p>
<p>This fixes the compilation error.
Check that everything works with <code>cargo test</code>.</p>
<h3 id="add-add_file_provide_dependency-method-to-store"><a class="header" href="#add-add_file_provide_dependency-method-to-store">Add <code>add_file_provide_dependency</code> method to <code>Store</code></a></h3>
<p>First we need to support provide file dependencies in the <code>Store</code>.
Update <code>pie/src/store.rs</code>:</p>
<div class="diff2html" id="diff2html_5"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/store.rs
+++ pie/src/store.rs
@@ -163,6 +163,18 @@
       _ => {},
     }
   }
+  /// Add a file provide ${"`"}dependency${"`"} from task ${"`"}src${"`"} to file ${"`"}dst${"`"}.
+  ///
+  /// # Panics
+  ///
+  /// Panics if ${"`"}src${"`"} or ${"`"}dst${"`"} were not found in the dependency graph, or if a cycle is created by adding this dependency.
+  pub fn add_file_provide_dependency(&mut self, src: &TaskNode, dst: &FileNode, dependency: FileDependency) {
+    match self.graph.add_edge(src, dst, Dependency::ProvideFile(dependency)) {
+      Err(pie_graph::Error::NodeMissing) => panic!("BUG: source node {:?} or destination node {:?} was not found in the dependency graph", src, dst),
+      Err(pie_graph::Error::CycleDetected) => panic!("BUG: cycle detected when adding file dependency from {:?} to {:?}", src, dst),
+      _ => {},
+    }
+  }
   /// Adds a task require ${"`"}dependency${"`"} from task ${"`"}src${"`"} to task ${"`"}dst${"`"}.
   ///
   /// # Errors
@@ -366,13 +378,13 @@
 
     // Add file dependency from task B to file C.
     let file_dependency_b2c = FileDependency::new(&path_c, FileStamper::Exists).unwrap();
-    store.add_file_require_dependency(&node_b, &node_c, file_dependency_b2c.clone());
+    store.add_file_provide_dependency(&node_b, &node_c, file_dependency_b2c.clone());
     let deps_of_a: Vec<_> = store.get_dependencies_of_task(&node_a).cloned().collect();
     assert_eq!(deps_of_a.get(0), Some(&Dependency::RequireFile(file_dependency_a2c.clone())));
     assert_eq!(deps_of_a.get(1), None);
     let deps_of_b: Vec<_> = store.get_dependencies_of_task(&node_b).cloned().collect();
     assert_eq!(deps_of_b.get(0), Some(&Dependency::RequireTask(task_dependency_b2a.clone())));
-    assert_eq!(deps_of_b.get(1), Some(&Dependency::RequireFile(file_dependency_b2c.clone())));
+    assert_eq!(deps_of_b.get(1), Some(&Dependency::ProvideFile(file_dependency_b2c.clone())));
     assert_eq!(deps_of_b.get(2), None);
 
     // Add task dependency from task A to task B, creating a cycle.
@@ -403,6 +415,17 @@
 
   #[test]
   #[should_panic]
+  fn test_add_file_provide_dependency_panics() {
+    let mut fake_store = Store::default();
+    let fake_file_node = fake_store.get_or_create_file_node("hello.txt");
+    let fake_task_node = fake_store.get_or_create_task_node(&StringConstant::new("Hello"));
+    let mut store: Store<StringConstant, String> = Store::default();
+    let dependency = FileDependency::new("hello.txt", FileStamper::Exists).unwrap();
+    store.add_file_provide_dependency(&fake_task_node, &fake_file_node, dependency);
+  }
+
+  #[test]
+  #[should_panic]
   fn test_add_task_require_dependency_panics() {
     let mut fake_store = Store::default();
     let output = "Hello".to_string();
`;
    let target = document.getElementById('diff2html_5');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We add the <code>add_file_provide_dependency</code> method, which does the same as <code>add_require_provide_dependency</code> but creates a <code>ProvideFile</code> dependency instead.
We update the <code>test_dependencies</code> unit test to create a provide file dependency, and add a test to check whether <code>add_require_provide_dependency</code> panics when used incorrectly.
Confirm the changes work with <code>cargo test</code>.</p>
<h3 id="add-methods-to-context-and-implementations"><a class="header" href="#add-methods-to-context-and-implementations">Add methods to <code>Context</code> and implementations</a></h3>
<p>We are not creating provide file dependencies yet, so let’s work on that now.
Add methods to <code>Context</code>, enabling tasks to create provide file dependencies, in <code>pie/src/lib.rs</code>:</p>
<div class="diff2html" id="diff2html_6"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/lib.rs
+++ pie/src/lib.rs
@@ -49,6 +49,19 @@
   /// Returns the default require file stamper.
   fn default_require_file_stamper(&self) -> FileStamper { FileStamper::Modified }
 
+  /// Provides file at given ${"`"}path${"`"}, recording a dependency to it (using the default provide file stamper). Call this
+  /// method *just after writing to the file*, so that the dependency corresponds to your written data. Returns an
+  /// ${"`"}Err(e)${"`"} if there was an error getting the metadata for given ${"`"}path${"`"}, or if there was an error stamping the file.
+  fn provide_file<P: AsRef<Path>>(&mut self, path: P) -> Result<(), io::Error> {
+    self.provide_file_with_stamper(path, self.default_provide_file_stamper())
+  }
+  /// Provides file at given ${"`"}path${"`"}, recording a dependency to it (using given ${"`"}stamper${"`"}). Call this method
+  /// *just after writing to the file*, so that the dependency corresponds to you written data.  Returns an ${"`"}Err(e)${"`"} if
+  /// there was an error getting the metadata for given ${"`"}path${"`"}, or if there was an error stamping the file.
+  fn provide_file_with_stamper<P: AsRef<Path>>(&mut self, path: P, stamper: FileStamper) -> Result<(), io::Error>;
+  /// Returns the default provide file stamper.
+  fn default_provide_file_stamper(&self) -> FileStamper { FileStamper::Modified }
+
   /// Requires given ${"`"}task${"`"}, recording a dependency (using the default output stamper) and selectively executing it.
   /// Returns its up-to-date output.
   fn require_task(&mut self, task: &T) -> T::Output {
`;
    let target = document.getElementById('diff2html_6');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>These methods are like <code>require_file</code>, but must be called <strong>after</strong> writing to the file, so that the stamper creates a stamp that includes the (meta)data that was written to the file.
Therefore, these methods do not return a <code>File</code> handle, because the caller creates a file handle for writing.</p>
<p>Implement this method in <code>pie/src/context/non_incremental.rs</code>:</p>
<div class="diff2html" id="diff2html_7"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/non_incremental.rs
+++ pie/src/context/non_incremental.rs
@@ -14,6 +14,10 @@
     open_if_file(&path)
   }
 
+  fn provide_file_with_stamper<P: AsRef<Path>>(&mut self, _path: P, _stamper: FileStamper) -> Result<(), io::Error> {
+    Ok(())
+  }
+
   fn require_task_with_stamper(&mut self, task: &T, _stamper: OutputStamper) -> T::Output {
     task.execute(self)
   }
`;
    let target = document.getElementById('diff2html_7');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>The non-incremental context just ignores provided files.</p>
<p>Implement the method in <code>pie/src/context/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_8"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -36,6 +36,18 @@
     Ok(file)
   }
 
+  fn provide_file_with_stamper<P: AsRef<Path>>(&mut self, path: P, stamper: FileStamper) -> Result<(), io::Error> {
+    let Some(current_executing_task_node) = &self.session.current_executing_task else {
+      return Ok(()); // No current executing task, so no dependency needs to be made.
+    };
+    let path = path.as_ref();
+    let node = self.session.store.get_or_create_file_node(path);
+    let dependency = FileDependency::new(path, stamper)?;
+    self.session.tracker.provide_file_end(&dependency);
+    self.session.store.add_file_provide_dependency(current_executing_task_node, &node, dependency);
+    Ok(())
+  }
+
   fn require_task_with_stamper(&mut self, task: &T, stamper: OutputStamper) -> T::Output {
     self.session.tracker.require_task_start(task, &stamper);
 
`;
    let target = document.getElementById('diff2html_8');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Again, this method is similar to the requiring version, except that it creates a provide file dependency, and returns <code>()</code> instead of a file handle.
Check that your changes work with <code>cargo test</code>.</p>
<h2 id="detect-and-disallow-overlapping-provided-files"><a class="header" href="#detect-and-disallow-overlapping-provided-files">Detect and disallow overlapping provided files</a></h2>
<p>Now we will detect and disallow overlapping provided files.
The only source of provided files is the <code>provide_file_with_stamper</code> method we just implemented.
Therefore, we can easily check for overlapping dependencies there.
Whenever a file provide dependency is made, we just need to check if a task is already providing that file, and disallow that.</p>
<p>First add a method to <code>Store</code> to get the providing task (if any) for a file.
Modify <code>pie/src/store.rs</code>:</p>
<div class="diff2html" id="diff2html_9"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/store.rs
+++ pie/src/store.rs
@@ -151,6 +151,23 @@
     debug_assert!(self.graph.contains_node(src), "BUG: node {:?} was not found in the dependency graph", src);
     self.graph.get_outgoing_edge_data(src)
   }
+
+  /// Get the task node that provides file ${"`"}dst${"`"}, or ${"`"}None${"`"} if there is none.
+  ///
+  /// # Panics
+  ///
+  /// Panics in development builds if ${"`"}dst${"`"} was not found in the dependency graph.
+  pub fn get_task_providing_file(&self, dst: &FileNode) -> Option<TaskNode> {
+    debug_assert!(self.graph.contains_node(dst), "BUG: node {:?} was not found in the dependency graph", dst);
+    self.graph.get_incoming_edges(dst).filter_map(|(n, d)|
+      if matches!(d, Dependency::ProvideFile(_)) {
+        Some(TaskNode(*n))
+      } else {
+        None
+      }
+    ).next()
+  }
+
   /// Add a file require ${"`"}dependency${"`"} from task ${"`"}src${"`"} to file ${"`"}dst${"`"}.
   ///
   /// # Panics
@@ -356,6 +373,7 @@
 
     assert_eq!(store.get_dependencies_of_task(&node_a).next(), None);
     assert_eq!(store.get_dependencies_of_task(&node_b).next(), None);
+    assert_eq!(store.get_task_providing_file(&node_c), None);
 
     // Add file dependency from task A to file C.
     let file_dependency_a2c = FileDependency::new(&path_c, FileStamper::Exists).unwrap();
@@ -364,6 +382,7 @@
     assert_eq!(deps_of_a.get(0), Some(&Dependency::RequireFile(file_dependency_a2c.clone())));
     assert_eq!(deps_of_a.get(1), None);
     assert_eq!(store.get_dependencies_of_task(&node_b).next(), None);
+    assert_eq!(store.get_task_providing_file(&node_c), None);
 
     // Add task dependency from task B to task A.
     let task_dependency_b2a = TaskDependency::new(task_a.clone(), OutputStamper::Equals, output_a.clone());
@@ -375,6 +394,7 @@
     let deps_of_b: Vec<_> = store.get_dependencies_of_task(&node_b).cloned().collect();
     assert_eq!(deps_of_b.get(0), Some(&Dependency::RequireTask(task_dependency_b2a.clone())));
     assert_eq!(deps_of_b.get(1), None);
+    assert_eq!(store.get_task_providing_file(&node_c), None);
 
     // Add file dependency from task B to file C.
     let file_dependency_b2c = FileDependency::new(&path_c, FileStamper::Exists).unwrap();
@@ -386,6 +406,7 @@
     assert_eq!(deps_of_b.get(0), Some(&Dependency::RequireTask(task_dependency_b2a.clone())));
     assert_eq!(deps_of_b.get(1), Some(&Dependency::ProvideFile(file_dependency_b2c.clone())));
     assert_eq!(deps_of_b.get(2), None);
+    assert_eq!(store.get_task_providing_file(&node_c), Some(node_b));
 
     // Add task dependency from task A to task B, creating a cycle.
     let task_dependency_a2b = TaskDependency::new(task_a.clone(), OutputStamper::Equals, output_a.clone());
@@ -404,6 +425,15 @@
 
   #[test]
   #[should_panic]
+  fn get_task_providing_file_panics() {
+    let mut fake_store: Store<StringConstant, String> = Store::default();
+    let fake_node = fake_store.get_or_create_file_node("hello.txt");
+    let store: Store<StringConstant, String> = Store::default();
+    let _ = store.get_task_providing_file(&fake_node);
+  }
+
+  #[test]
+  #[should_panic]
   fn test_add_file_require_dependency_panics() {
     let mut fake_store = Store::default();
     let fake_file_node = fake_store.get_or_create_file_node("hello.txt");
`;
    let target = document.getElementById('diff2html_9');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p><code>get_task_providing_file</code> does exactly that.
We get an iterator over incoming dependency edges for the destination file node using <code>get_incoming_edges</code>.
We use <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter_map" title="" target="_blank">
<code>filter_map</code></a> to both filter out non-provide file dependencies, and map to a <code>TaskNode</code> when it is a provide file dependency.
Only tasks can be the source of provide file dependencies, so it is always correct to create a <code>TaskNode</code> here.
We get the first (if any) element of the iterator with <code>.next()</code>, which is the task that provides the file.
Because we will disallow multiple tasks from providing a file, this method will return <code>Option&lt;TaskNode&gt;</code>, since there can only be 0 or 1 task providing a file.</p>
<p>We modify the dependency test again, testing that <code>get_task_providing_file</code> returns what we expect.</p>
<p>We assert (in development builds, like <code>get_dependencies_of_task</code>) that the file node must exist in the dependency graph, as a sanity check, and test that. </p>
<p>Now we’ll use this in <code>provide_file_with_stamper</code> to panic when overlap is detected.
Modify <code>pie/src/context/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_10"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/src/context/top_down.rs
+++ pie/src/context/top_down.rs
@@ -42,6 +42,14 @@
     };
     let path = path.as_ref();
     let node = self.session.store.get_or_create_file_node(path);
+
+    if let Some(previous_providing_task_node) = self.session.store.get_task_providing_file(&node) {
+      let current_executing_task = self.session.store.get_task(current_executing_task_node);
+      let previous_providing_task = self.session.store.get_task(&previous_providing_task_node);
+      panic!("Overlapping provided file; file '{}' is provided by the current executing task '{:?}' that was \
+              previously provided by task: {:?}", path.display(), current_executing_task, previous_providing_task);
+    }
+
     let dependency = FileDependency::new(path, stamper)?;
     self.session.tracker.provide_file_end(&dependency);
     self.session.store.add_file_provide_dependency(current_executing_task_node, &node, dependency);
`;
    let target = document.getElementById('diff2html_10');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>If we find a task that provides the file, we panic with a message explaining why.
Note that we don’t have to check whether <code>previous_providing_task_node == current_executing_task_node</code>, and then not panic.
This is because when executing a task, we first reset it, which removes all its outgoing dependencies.
Therefore, <code>current_executing_task_node</code> cannot have a provide file dependency to the file.
Unless it provides the same file twice, but that is overlap that we also want to disallow.</p>
<div id="admonition-why-panic" class="admonition admonish-question">
<div class="admonition-title">
<p>Why Panic?</p>
<p><a class="admonition-anchor-link" href="#admonition-why-panic"></a></p>
</div>
<div>
<p>We discussed panicking in the section on the incremental top-down context, but want to reiterate it here.
Instead of panicking, we could have <code>provide_file_with_stamper</code> return an error indicating overlap was found.
However, that error would then propagate throughout the entire API.
Tasks would have to propagate it in their <code>execute</code> method, meaning that <code>Context::require</code> will also be able to return this error.
When tasks already return their own errors, you’d end up with return types such as <code>Result&lt;Result&lt;AnOutput, AnError&gt;, OverlapError&gt;</code> which are annoying to deal with.</p>
<p>This is a hard trade-off to make, but in this tutorial (and in the actual PIE library) we will panic.</p>
</div>
</div>
<p>Confirm our changes work with <code>cargo test</code>.
Wait, shouldn’t the overlap test now fail?
No, we didn’t change our <code>WriteFile</code> task to use <code>provide_file</code> yet.
Let’s fix that now.</p>
<p>Modify <code>pie/tests/common/mod.rs</code>:</p>
<div class="diff2html" id="diff2html_11"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/common/mod.rs
+++ pie/tests/common/mod.rs
@@ -84,7 +84,7 @@
       TestTask::WriteFile(string_provider_task, path, stamper) => {
         let string = context.require_task(string_provider_task.as_ref())?.into_string();
         write_until_modified(path, string.as_bytes()).map_err(|e| e.kind())?;
-        context.require_file_with_stamper(path, *stamper).map_err(|e| e.kind())?;
+        context.provide_file_with_stamper(path, *stamper).map_err(|e| e.kind())?;
         Ok(TestOutput::Unit)
       }
       TestTask::ToLower(string_provider_task) => {
`;
    let target = document.getElementById('diff2html_11');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Just replace <code>require_file_with_stamper</code> with <code>provide_file_with_stamper</code> in <code>WriteFile</code>.
Running <code>cargo test</code> should make the overlap test now fail!</p>
<div id="admonition-expected-test-failure" class="admonition admonish-failure">
<div class="admonition-title">
<p>Expected Test Failure</p>
<p><a class="admonition-anchor-link" href="#admonition-expected-test-failure"></a></p>
</div>
<div>
<p>Test <code>test_show_overlap_issue</code> will fail as expected, which we will now fix!</p>
</div>
</div>
<p>Modify the test in <code>pie/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_12"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -250,42 +250,26 @@
 // Overlapping provided file tests
 
 #[test]
-fn test_show_overlap_issue() -> Result<(), io::Error> {
-  let mut pie = test_pie();
-  let temp_dir = create_temp_dir()?;
+#[should_panic(expected = "Overlapping provided file")]
+fn test_overlapping_provided_file_panics() {
+  fn run() -> Result<(), io::Error> {
+    let mut pie = test_pie();
+    let temp_dir = create_temp_dir()?;
 
-  let output_file = temp_dir.path().join("out.txt");
+    let output_file = temp_dir.path().join("out.txt");
+    let input_file = temp_dir.path().join("in.txt");
+    write(&input_file, "Hello, World!")?;
 
-  let ret = Return("Hi there");
-  let write_1 = WriteFile(Box::new(ret.clone()), output_file.clone(), FileStamper::Modified);
+    let seq = Sequence(vec![
+      WriteFile(Box::new(Return("Hi there")), output_file.clone(), FileStamper::Modified),
+      WriteFile(Box::new(ReadFile(input_file.clone(), FileStamper::Modified)), output_file.clone(), FileStamper::Modified),
+    ]);
+    // Require ${"`"}seq${"`"}, resulting in overlapping provided files between the two different write tasks.
+    pie.require(&seq)?;
 
-  let input_file = temp_dir.path().join("in.txt");
-  write(&input_file, "Hello, World!")?;
-  let read = ReadFile(input_file.clone(), FileStamper::Modified);
-  let write_2 = WriteFile(Box::new(read.clone()), output_file.clone(), FileStamper::Modified);
-
-  let seq = Sequence(vec![write_1.clone(), write_2.clone()]);
-
-  // Require ${"`"}seq${"`"}. The last writer, ${"`"}write_2${"`"} (${"`"}WriteFile(ReadFile(input_file))${"`"}), wins because ${"`"}Sequence${"`"} executes
-  // tasks in order.
-  pie.require(&seq)?;
-  // Assert that ${"`"}output_file${"`"} contains the string from ${"`"}input_file${"`"}.
-  assert_eq!(read_to_string(&output_file)?, "Hello, World!");
-
-  // Change ${"`"}input_file${"`"} such that ${"`"}write_2${"`"} becomes inconsistent.
-  write_until_modified(&input_file, "World, Hello?")?;
-
-  // Require ${"`"}write_1${"`"} and assert that it is executed, because ${"`"}write_2${"`"} modified ${"`"}output_file${"`"} after ${"`"}write_1${"`"}, thus
-  // ${"`"}write_1${"`"}'s file dependency to ${"`"}output_file${"`"} is inconsistent.
-  pie.require_then_assert_one_execute(&write_1)?;
-  // However, because we required ${"`"}write_1${"`"} directly, instead of through ${"`"}seq${"`"}, ${"`"}output_file${"`"} contains the string that
-  // ${"`"}ret${"`"} returned, even though ${"`"}write_2${"`"} is inconsistent and should win.
-  assert_eq!(read_to_string(&output_file)?, "Hi there");
-  // The contents of ${"`"}output_file${"`"} is thus dependent on which tasks and in which order we require them. This
-  // inconsistent behaviour is undesirable.
-  // Note: this is asserting the current behaviour, not the desired behaviour, which is to disallow this!
-
-  Ok(())
+    Ok(())
+  }
+  run().unwrap()
 }
 
 #[test]
`;
    let target = document.getElementById('diff2html_12');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'side-by-side',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>We change the test into one that should panic.
We use <code>expected = &quot;Overlapping provided file&quot;</code> to indicate that the panic should include <code>&quot;Overlapping provided file&quot;</code>, so that the test does not succeed due to another unrelated panic.</p>
<p>Unfortunately, tests that should panic may not return a <code>Result</code>.
We work around that by wrapping the entire test in a nested <code>run</code> function that returns a <code>Result</code>, and by calling <code>run().unwrap()</code> at the end of the test.</p>
<p>We rename the test to <code>test_overlapping_provided_file_panics</code> which better describes what it is testing and what is expected.
And we simply the test a lot, because it will panic when we call <code>require</code>, so the other part of the test is no longer required. </p>
<p>Run <code>cargo test</code> to check that this test will now succeed.</p>
<div id="admonition-fixed-tests" class="admonition admonish-success">
<div class="admonition-title">
<p>Fixed Tests</p>
<p><a class="admonition-anchor-link" href="#admonition-fixed-tests"></a></p>
</div>
<div>
<p>Test <code>test_overlapping_provided_file_panics</code> (was: <code>test_show_overlap_issue</code>) should now succeed.</p>
</div>
</div>
<p>Let’s add two more tests: one that confirms overlap is detected when we manually <code>require</code> two different tasks, and one that confirms that requiring (and executing) the same task does not cause overlap.
Add these tests to <code>pie/tests/top_down.rs</code>:</p>
<div class="diff2html" id="diff2html_13"></div>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let diff = String.raw`--- pie/tests/top_down.rs
+++ pie/tests/top_down.rs
@@ -273,6 +273,50 @@
 }
 
 #[test]
+#[should_panic(expected = "Overlapping provided file")]
+fn test_require_overlapping_provided_file_panics() {
+  fn run() -> Result<(), io::Error> {
+    let mut pie = test_pie();
+    let temp_dir = create_temp_dir()?;
+
+    let output_file = temp_dir.path().join("out.txt");
+
+    let write_1 = WriteFile(Box::new(Return("Hi there")), output_file.clone(), FileStamper::Modified);
+    pie.require(&write_1)?;
+
+    // ${"`"}write_2${"`"} is a different task, so requiring it will cause overlap.
+    let write_2 = WriteFile(Box::new(Return("Hello, World!")), output_file.clone(), FileStamper::Modified);
+    pie.require(&write_2)?;
+
+    Ok(())
+  }
+  run().unwrap()
+}
+
+#[test]
+fn test_same_task_no_overlap() -> Result<(), io::Error> {
+  let mut pie = test_pie();
+  let temp_dir = create_temp_dir()?;
+
+  let output_file = temp_dir.path().join("out.txt");
+  let input_file = temp_dir.path().join("in.txt");
+  write(&input_file, "Hello, World!")?;
+
+  let read = ReadFile(input_file.clone(), FileStamper::Modified);
+  let write = WriteFile(Box::new(read), output_file.clone(), FileStamper::Modified);
+
+  pie.require_then_assert_one_execute(&write)?;
+  // Requiring and executing the same task does not cause overlap.
+  write_until_modified(&input_file, "World, Hello?")?;
+  pie.require_then_assert_one_execute(&write)?;
+  // Even when required indirectly.
+  write_until_modified(&input_file, "Hello, World!")?;
+  pie.require_then_assert_one_execute(&Sequence(vec![write]))?;
+
+  Ok(())
+}
+
+#[test]
 fn test_separate_output_files() -> Result<(), io::Error> {
   let mut pie = test_pie();
   let temp_dir = create_temp_dir()?;
`;
    let target = document.getElementById('diff2html_13');
    let configuration = {
      drawFileList: false,
      fileListToggle: false,
      fileContentToggle: false,

      outputFormat: 'line-by-line',
      matching: 'lines',
    };
    let diff2htmlUi = new Diff2HtmlUI(target, diff, configuration, hljs);
    diff2htmlUi.draw();
  });
</script>
<p>Confirm that these tests also succeed with <code>cargo test</code>.</p>
<p>We’re now preventing the inconsistencies of overlapping file writes that occur in an incremental setting.
This does require some care when writing to files in a programmatic incremental build system, as task authors need to ensure that distinct tasks only write to distinct files.
And we only detect this at run-time, while running the build, so task authors must test their tasks, combinations of tasks, and with different inputs, to have some certainty that their tasks have no overlapping file writes.
However, I think this kind of run-time checking is preferable over incremental builds being inconsistent or incorrect. </p>
<details id="admonition-detect-overlap-statically" class="admonition admonish-question">
<summary class="admonition-title">
<p>Detect Overlap Statically?</p>
<p><a class="admonition-anchor-link" href="#admonition-detect-overlap-statically"></a></p>
</summary>
<div>
<p>As far as I know, there is no <em>easy</em> way to detect overlap statically in the presence of dynamic dependencies and incrementality.
You’d have to encode file names and paths in the type system, and restrict what kind of names and paths you can use.</p>
<p>Matthew Hammer et al. developed <a href="https://arxiv.org/abs/1808.07826" title="" target="_blank">Fungi, a typed functional language for incremental computation with names</a> to solve these kind of problems, but it is quite involved!
Be sure to read that paper and their previous work on <a href="http://adapton.org/" title="" target="_blank">Adapton (non-HTTPS)</a> if you’re interested in that line of research.</p>
</div>
</details>
<p>In the next section, we will detect and disallow another inconsistency in incremental builds: hidden dependencies.</p>
<details id="admonition-download-source-code" class="admonition admonish-example">
<summary class="admonition-title">
<p>Download source code</p>
<p><a class="admonition-anchor-link" href="#admonition-download-source-code"></a></p>
</summary>
<div>
<p>You can <a href="../../gen/3_min_sound/5_overlap/source.zip">download the source files up to this point</a>.</p>
</div>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../3_min_sound/4_fix_task_dep/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../3_min_sound/6_hidden_dep/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../3_min_sound/4_fix_task_dep/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../3_min_sound/6_hidden_dep/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../.././diff2html-ui-base.min.js"></script>


    </div>
    </body>
</html>
