<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Programmable Build System API - Build your own Programmatic Incremental Build System</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../src/custom.css">
        <link rel="stylesheet" href="../src/mdbook-admonish.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><div>Introduction</div></li><li class="chapter-item expanded affix "><li class="part-title">Programmability</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Setup</div></li><li class="chapter-item expanded "><a href="../api/api.html" class="active"><strong aria-hidden="true">2.</strong> Programmable Build System API</a></li><li class="chapter-item expanded affix "><li class="part-title">Incrementality</li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Incremental Top-Down Context</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Minimality</div></li><li class="chapter-item expanded affix "><li class="part-title">Soundness</li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Prevent Overlapping File Writes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Prevent Hidden Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Prevent Cycles</div></li><li class="chapter-item expanded affix "><li class="part-title">Improvements</li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Serialization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Stamps</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Configurable Hashing</div></li><li class="chapter-item expanded affix "><li class="part-title">Efficiency</li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Incremental Bottom-Up Context</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Observability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Deferred Tasks</div></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Multiple Task Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> On Static Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> On Declarativity</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><div>Related Work</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="programmable-build-system-api"><a class="header" href="#programmable-build-system-api">Programmable Build System API</a></h1>
<p>In this first chapter, we will program the core API of the programmatic incremental build system, and implement an
extremely simple non-incremental version of the build system to get started.</p>
<h2 id="task-and-context"><a class="header" href="#task-and-context">Task and Context</a></h2>
<p>The unit of computation in a programmatic build system is a <em>task</em>.
A task is kind of like a closure: a value that can be executed to produce their output.
However, in an <em>incremental</em> programmatic build system, we also need to keep track of <em>dynamic dependencies</em> that are
made while tasks are executing.
Therefore, tasks are executed under a <em>context</em> which enable them to create these dependencies.
Tasks <em>require</em> other tasks through the context, creating a dynamic dependency and returning their up-to-date output.</p>
<p>On the other hand, an incremental context wants to <em>selectively execute tasks</em> — only those that are affected by a
change.
To that end, a context will selectively execute tasks, tasks require other tasks through the context, the context
selectively executes those, and so forth.
Thus, tasks and contexts are mutually recursive.
Let's make this more concrete by defining tasks and contexts in code.</p>
<h3 id="api-implementation"><a class="header" href="#api-implementation">API Implementation</a></h3>
<p>Since we want users of the build system to implement their own tasks, we will define <code>Task</code> as a trait.
Likewise, we will also be implementing multiple contexts in this tutorial, so we will also define <code>Context</code> as a trait.
Add the following code to your <code>src/lib.rs</code> file:</p>
<pre><code class="language-rust ">use std::fmt::Debug;
use std::hash::Hash;

pub trait Task: Clone + Eq + Hash + Debug {
  type Output: Clone + Eq + Debug;
  fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
}

pub trait Context&lt;T: Task&gt; {
  fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
}</code></pre>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="#admonition-note"></a></p>
</div>
<div>
<p>If this seems overwhelming to you, don't worry. We will go through the API and explain things. But more importantly, the API should become more clear once we implement it in the next section and subsequent chapters.
Furthermore, if you're new to Rust and/or need help understanding certain concepts, I will try to explain them in Rust Help blocks. They are collapsed by default to reduce distraction, clicking the header opens them. See the first Rust Help block at the end of this section.</p>
</div>
</div>
<p>The <code>Task</code> trait has several supertraits that we will need later in the tutorial to implement incrementality:</p>
<ul>
<li><code>Eq</code> and <code>Hash</code>: to check whether a task is equal to another one, and to create a hash of it, so we can use
a <code>HashMap</code> to get the output of a task if it is up-to-date.</li>
<li><code>Clone</code>: to create a clone of the task so that we can store it in the <code>HashMap</code> without having ownership of it.</li>
<li><code>Debug</code>: to format the task for debugging purposes.</li>
</ul>
<p>A <code>Task</code> has a single method <code>execute</code>, which takes a reference to itself (<code>&amp;self</code>), and a mutable reference to a
context (<code>context: &amp;mut C</code>), and produces a value of type <code>Self::Output</code>.
Because <code>Context</code> is a trait, we use generics (<code>&lt;C: Context&lt;Self&gt;&gt;</code>) to have <code>execute</code> work for any <code>Context</code>
implementation (ignoring the <code>Self</code> part for now).
The <code>execute</code> method takes self by reference such that a task can access its data, but not mutate it, as that could
throw off incrementality by changing the hash/equality of the task.
Finally, the type of output of a task is defined by the <code>Output</code> associated type, and this type must
implement <code>Clone</code>, <code>Eq</code>, and <code>Debug</code> for the same reason as <code>Task</code>.</p>
<p>The <code>Context</code> trait is generic over <code>Task</code>, allowing it to work with any task implementation.
It has a single method <code>require_task</code> for creating a dependency to a task and returning its up-to-date result.
It takes a mutable reference to itself, enabling dependency tracking and caching, which require mutation.
Because of this, the context reference passed to <code>Task::execute</code> is also mutable.</p>
<p>This <code>Task</code> and <code>Context</code> API mirrors the mutually recursive definition of task and context we discussed earlier, and
forms the basis for the entire build system.</p>
<p>Build the project by running <code>cargo build</code>. 
The output should look something like:</p>
<pre><code class="language-shell ">&gt; cargo build
   Compiling pie v0.1.0 (/tmp/.tmpYSKG8U)
    Finished dev [unoptimized + debuginfo] target(s) in 0.12s
</code></pre>
<details id="admonition-rust-help" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="#admonition-rust-help"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/book/ch00-00-introduction.html" title="" target="_blank">The Rust Programming Language</a> is an introductory book about Rust. I will try to provide links to the book where possible.</p>
<p>Rust has a <a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html" title="" target="_blank">module system</a> for project organization. The <code>lib.rs</code> file is the &quot;main file&quot; of a library. Later on, we will be creating more modules in different files.</p>
<p>Things are imported into the current scope with <a href="https://doc.rust-lang.org/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html" title="" target="_blank">
<code>use</code></a> statements. We import the <code>Debug</code> and <code>Hash</code> traits from the standard library with two <code>use</code> statements. Use statements use <a href="https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html" title="" target="_blank">paths</a> to refer to nested things. We use <code>::</code> for nesting, similar to namespaces in C++.</p>
<p>Rust models the concept of <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html" title="" target="_blank">ownership</a> to enable memory safety without a garbage collector.
The <code>execute</code> method accepts a <em>reference</em> to the current type, indicated with <code>&amp;</code>: <code>&amp;self</code>. This reference is <em>immutable</em>, meaning that we can read data from it, but not mutate it. In Rust, things are immutable by default.
On the other hand, <code>execute</code> accepts a <em>mutable reference</em> to the context, indicated with <code>&amp;mut</code>: <code>context: &amp;mut C</code>, which does allow mutation.</p>
<p><a href="https://doc.rust-lang.org/book/ch10-02-traits.html" title="" target="_blank">Traits</a> are the main mechanism for open extensibility in Rust. They are comparable to interfaces in class-oriented languages. We will implement a context and tasks in the next section.</p>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-supertraits-to-require-one-traits-functionality-within-another-trait" title="" target="_blank">Supertraits</a> are a kind of inheritance. The <code>: Clone + Eq + Hash + Debug</code> part of the <code>Task</code> trait means that every <code>Task</code> implementation must also implement the <code>Clone</code>, <code>Eq</code>, <code>Hash</code>, and <code>Debug</code> traits. These traits are part of the standard library:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html" title="" target="_blank">Clone</a> for duplicating values.</li>
<li><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html" title="" target="_blank">Eq</a> for equality comparisons, along with <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html" title="" target="_blank">PartialEq</a>.</li>
<li><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html" title="" target="_blank">Hash</a> for turning a value into a hash.</li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html" title="" target="_blank">Debug</a> for formatting values in a programmer-facing debugging context.</li>
</ul>
<p><code>Clone</code> and <code>Eq</code> are so common that they are part of the <a href="https://doc.rust-lang.org/std/prelude/index.html" title="" target="_blank">Rust Prelude</a>, so we don't have to import those with <code>use</code> statements.</p>
<p><a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html" title="" target="_blank">Methods</a> are functions that take a form of <code>self</code> as the first argument. This enables convenient object-like calling syntax: <code>context.require_task(&amp;task);</code>.</p>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types" title="" target="_blank">Associated types</a> are a kind of placeholder type in a trait such that methods of traits can use that type. In <code>Task</code> this allows us to talk about the <code>Output</code> type of a task. In <code>Context</code> this allows us to refer to both the <code>Task</code> type <code>T</code> and its output type <code>T::Output</code>. The <code>::</code> syntax here is used to access associated types of traits.</p>
<p>The <code>Self</code> type in a trait is a built-in associated type that is a placeholder for the type that is implementing the trait.</p>
<p>The <code>Task</code> trait is defined with <code>pub</code> (public) <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html" title="" target="_blank">visibility</a>, such that users of the library can implement it. Because <code>Task</code> uses <code>Context</code> in its public API, <code>Context</code> must also be public, even though we don't intend for users to implement their own <code>Context</code>.</p>
</div>
</details>
<h2 id="non-incremental-context"><a class="header" href="#non-incremental-context">Non-Incremental Context</a></h2>
<p>We set up the <code>Task</code> and <code>Context</code> API in such a way that we can implement incrementality.
However, incrementality is <em>hard</em>, so let's start with an extremely simple non-incremental <code>Context</code> implementation to
get a feeling for the API.</p>
<h3 id="context-module"><a class="header" href="#context-module">Context module</a></h3>
<p>Since we will be implementing three different contexts in this tutorial, we will separate them in different modules.
Create the <code>context</code> module by adding a module to <code>src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::fmt::Debug;
 use std::hash::Hash;

+mod context;
+
 pub trait Task: Clone + Eq + Hash + Debug {
   type Output: Clone + Eq + Debug;
   fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;</code></pre>
<p>This is a diff over <code>src/lib.rs</code> where lines with a green background are additions, lines with a red background are
removals, and lines with a grey background are context on where to add/remove lines, similar to diffs on source code
hubs like GitHub.</p>
<p>Create the <code>src/context</code> directory, and in it, create the <code>src/context/mod.rs</code> file with the following contents:</p>
<pre><code class="language-rust ">pub(crate) mod non_incremental;</code></pre>
<p>Then, create the <code>src/context/non_incremental.rs</code> file, it will be empty for now.
Your project structure should now look like:</p>
<pre><code>pie
├── src
│   ├── lib.rs
│   └── context
│       ├── mod.rs
│       └── non_incremental.rs
├── Cargo.toml
├── Cargo.lock
└── target
</code></pre>
<p>Confirm your module structure is correct by building with <code>cargo build</code>.</p>
<details id="admonition-rust-help-1" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="#admonition-rust-help-1"></a></p>
</summary>
<div>
<p>Modules are typically <a href="https://doc.rust-lang.org/book/ch07-05-separating-modules-into-different-files.html" title="" target="_blank">separated into different files</a>.
Modules are declared with <code>mod context</code>. 
Then, the contents of a module are defined either by creating a sibling file with the same name: <code>context.rs</code>, or by creating a sibling directory with the same name, with a <code>mod.rs</code> file in it: <code>context/mod.rs</code>.
Use the latter if you intend to nest modules, otherwise use the former.</p>
<p>Like traits, modules also have <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html" title="" target="_blank">visibility</a>.</p>
</div>
</details>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<p>Implement the non-incremental context in <code>src/context/non_incremental.rs</code> by adding:</p>
<pre><code class="language-rust ">use crate::{Context, Task};

pub struct NonIncrementalContext;

impl&lt;T: Task&gt; Context&lt;T&gt; for NonIncrementalContext {
  fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output {
    task.execute(self)
  }
}</code></pre>
<p>This <code>NonIncrementalContext</code> is extremely simple: in <code>require_task</code> we unconditionally execute the task, and pass <code>self</code>
along so the task we're calling can require additional tasks.
Let's write some tests to see if this does what we expect.</p>
<details id="admonition-rust-help-2" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="#admonition-rust-help-2"></a></p>
</summary>
<div>
<p>In Rust, libraries are called <a href="https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html" title="" target="_blank">crates</a>.
We import the <code>Context</code> and <code>Task</code> traits from the root of your crate (i.e., the <code>src/lib.rs</code> file) using <code>crate::</code> as a prefix.</p>
<p><a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html" title="" target="_blank">Structs</a> are concrete types that can contain data through fields and implement traits, similar to classes in class-oriented languages.
Since we don't need any data in <code>NonIncrementalContext</code>, we define it as a <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#unit-like-structs-without-any-fields" title="" target="_blank">unit-like struct</a>.</p>
<p><a href="https://doc.rust-lang.org/book/ch10-02-traits.html#implementing-a-trait-on-a-type" title="" target="_blank">Traits are implemented for a type</a> with <code>impl Context for NonIncrementalContext { ... }</code>, where we then have to implement all methods of the trait.</p>
<p>The <code>Context</code> trait is generic over <code>Task</code>, so in the <code>impl</code> block we introduce a type parameter <code>T</code> with <code>impl&lt;T&gt;</code>, and use <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#using-trait-bounds-to-conditionally-implement-methods" title="" target="_blank">trait bounds</a> as <code>impl&lt;T: Task&gt;</code> to declare that <code>T</code> must implement <code>Task</code>.</p>
<p>The last expression of a function – in this case <code>task.execute(self)</code> in <code>require_task</code> which is an expression because it does not end with <code>;</code> – is used as the return value.
We could also write that as <code>return task.execute(self);</code>, but that is more verbose.</p>
</div>
</details>
<h3 id="simple-test"><a class="header" href="#simple-test">Simple Test</a></h3>
<p>Add the following test to <code>src/context/non_incremental.rs</code>:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use super::*;

  #[test]
  fn test_require_task_direct() {
    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
    struct ReturnHelloWorld;

    impl Task for ReturnHelloWorld {
      type Output = String;
      fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, _context: &amp;mut C) -&gt; Self::Output {
        &quot;Hello World!&quot;.to_string()
      }
    }

    let mut context = NonIncrementalContext;
    assert_eq!(&quot;Hello World!&quot;, context.require_task(&amp;ReturnHelloWorld));
  }
}</code></pre>
<p>In this test, we create a struct <code>ReturnHelloWorld</code> which is the &quot;hello world&quot; of the build system.
We implement <code>Task</code>, set its <code>Output</code> associated type to be <code>String</code>, and implement the <code>execute</code> method to just return <code>&quot;Hello World!&quot;</code>.
We derive the <code>Clone</code>, <code>Eq</code>, <code>Hash</code>, and <code>Debug</code> traits for <code>ReturnHelloWorld</code> as they are required for all <code>Task</code> implementations.</p>
<p>We require the task with our context by creating a <code>NonIncrementalContext</code>, calling its <code>require_task</code> method, passing in a reference to the task.
It returns the output of the task, which we test with <code>assert_eq!</code>.</p>
<p>Run the test by running <code>cargo test</code>.
The output should look something like:</p>
<pre><code class="language-shell ">&gt; cargo test
   Compiling pie v0.1.0 (/tmp/.tmpYSKG8U)
    Finished test [unoptimized + debuginfo] target(s) in 0.67s
     Running unittests src/lib.rs (/tmp/.tmpYSKG8U/target/debug/deps/pie-3ca253e6389ba527)

running 1 test
test context::non_incremental::test::test_require_task_direct ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests pie

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>Which indicates that the test indeed succeeds!
You can experiment by returning a different string from <code>ReturnHelloWorld::execute</code> to see what a failed test looks like.</p>
<h3 id="more-complicated-test"><a class="header" href="#more-complicated-test">More Complicated Test</a></h3>
<p>TODO: add more complicated test</p>
<pre><code class="language-rust customdiff">     let mut context = NonIncrementalContext;
     assert_eq!(&quot;Hello World!&quot;, context.require_task(&amp;ReturnHelloWorld));
   }
+
+  #[test]
+  fn test_require_task() {
+    #[derive(Clone, PartialEq, Eq, Hash, Debug)]
+    enum Test {
+      ReturnHelloWorld,
+      ToLowerCase,
+    }
+    
+    impl Task for Test {
+      type Output = String;
+      fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
+        match self {
+          Self::ReturnHelloWorld =&gt; &quot;Hello World!&quot;.to_string(),
+          Self::ToLowerCase =&gt; context.require_task(&amp;Self::ReturnHelloWorld).to_lowercase(),
+        }
+      }
+    }
+
+    let mut context = NonIncrementalContext;
+    assert_eq!(&quot;hello world!&quot;, context.require_task(&amp;Test::ToLowerCase));
+  }
 }</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../src/diff.js"></script>


    </div>
    </body>
</html>
