<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Incremental Top-Down Context - Build your own Programmatic Incremental Build System</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../src/custom.css">
        <link rel="stylesheet" href="../src/mdbook-admonish.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><div>Introduction</div></li><li class="chapter-item expanded affix "><li class="part-title">Programmability</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Setup</div></li><li class="chapter-item expanded "><a href="../api/index.html"><strong aria-hidden="true">2.</strong> Programmable Build System API</a></li><li class="chapter-item expanded affix "><li class="part-title">Incrementality</li><li class="chapter-item expanded "><a href="../top_down/index.html" class="active"><strong aria-hidden="true">3.</strong> Incremental Top-Down Context</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Minimality</div></li><li class="chapter-item expanded affix "><li class="part-title">Soundness</li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Prevent Overlapping File Writes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Prevent Hidden Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Prevent Cycles</div></li><li class="chapter-item expanded affix "><li class="part-title">Improvements</li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Serialization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Stamps</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Configurable Hashing</div></li><li class="chapter-item expanded affix "><li class="part-title">Efficiency</li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Incremental Bottom-Up Context</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Observability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Deferred Tasks</div></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Multiple Task Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> On Static Dependencies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> On Declarativity</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><div>Related Work</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build your own Programmatic Incremental Build System</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="incremental-top-down-context"><a class="header" href="#incremental-top-down-context">Incremental Top-Down Context</a></h1>
<p>In this chapter, we will implement an <em>incremental</em> build context.
An incremental context selectively executes tasks — only those that are affected by a change.
In other words, an incremental context executes the <em>minimum number of tasks</em> required to make all tasks up-to-date.</p>
<p>However, due to dynamic dependencies, this is not trivial.
We cannot first gather all tasks into a dependency tree and then topologically sort that, as dependencies are added and removed <em>while tasks are executing</em>.
To do incremental builds in the presence of dynamic dependencies, we need to check and execute affected tasks <em>one at a time</em>, updating the dependency graph, while tasks are executing.
To achieve this, we will employ a technique called <em>top-down incremental building</em>, which starts checking if a top (root) task needs to be executed, and recursively checks whether dependent tasks should be executed until we reach the bottom (leaf) task(s), akin to a depth-first search.</p>
<p>Furthermore, build systems almost always interact with the file system in some way. 
For example, tasks read configuration and source files, or write intermediate and binary files.
Thus, a change in a file can affect a task that reads it, and executing a task can result in writing to new or existing files.
Therefore, we will also keep track of <em>file dependencies</em>.
Like task dependencies, file dependencies are also tracked dynamically while tasks are executing.</p>
<p>Before we start coding, let's sketch the outline of the solution — we will:</p>
<ul>
<li>Extend <code>Context</code> with a way to for tasks to register file dependencies.
<ul>
<li>Implement file system utility functions in module <code>fs</code>.</li>
<li>Make <code>NonIncrementalContext</code> compatible with the extension to <code>Context</code>.</li>
</ul>
</li>
<li>Implement an <code>TopDownContext</code> that does incremental building.
<ul>
<li>Implement <code>Dependency</code> to represent dependencies.</li>
<li>Implement <code>Store</code> that keeps track of the dependency graph.</li>
</ul>
</li>
<li>Write tests for <code>TopDownContext</code> to confirm that it is sound and incremental.
<ul>
<li>Implement a <code>Tracker</code> that can track build events, so we can assert whether a task has executed or not to test incrementality.</li>
</ul>
</li>
</ul>
<h2 id="adding-file-dependencies"><a class="header" href="#adding-file-dependencies">Adding File Dependencies</a></h2>
<p>To support file dependencies, add a method to the <code>Context</code> trait in <code>src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::fmt::Debug;
+use std::fs::File;
 use std::hash::Hash;
+use std::io;
+use std::path::Path;

 mod context;

 pub trait Task: Clone + Eq + Hash + Debug {
   type Output: Clone + Eq + Debug;
@@ -8,6 +11,7 @@
   fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
 }

 pub trait Context&lt;T: Task&gt; {
   fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output;
+  fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt;;
 }</code></pre>
<p><code>require_file</code> is similar to requiring a task, but instead takes a <code>path</code> to a file or directory on the filesystem as input.
We use <code>AsRef&lt;Path&gt;</code> as the type for the path, so that we can pass anything in that can dereference to a path.
For example, <code>str</code> has an <code>AsRef&lt;Path&gt;</code> implementation, so we can just use <code>&quot;test.txt&quot;</code> as a path.</p>
<p>As an output, we return <code>Result&lt;Option&lt;File&gt;, io::Error&gt;</code>, with <code>File</code> being a handle to an open file.
The reason for this complicated type is:</p>
<ul>
<li>An incremental context will want to read the metadata (such as the last modified date) of the file, or create a hash over the file, to be able to detect changes. Because getting metadata or reading the file can fail, and we want to propagate this error, we return a <code>Result</code> with <code>io::Error</code> as the error type.</li>
<li>Tasks can create a dependency to a file that does not exist, and the existence of that file affects the task. For example, a task that prints true or false based on if a file exists. If the file does not exist (or it is a directory), we cannot open it, so we cannot return a <code>File</code>, hence we use <code>Option&lt;File&gt;</code> to return <code>None</code>.</li>
<li>Otherwise, we return <code>Ok(Some(file))</code> so that the task can read the opened file.</li>
</ul>
<details id="admonition-rust-help" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="#admonition-rust-help"></a></p>
</summary>
<div>
<p><a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html" title="" target="_blank">Recoverable error handling</a> in Rust is done with the <code>Result&lt;T, E&gt;</code> type, which can either be <code>Ok(t)</code> or <code>Err(e)</code>.
In contrast to many languages which use exceptions, throwing, and exception handling; Rust treats recoverable errors just as regular values.</p>
<p>Similarly, <a href="https://doc.rust-lang.org/std/option/" title="" target="_blank">optional values</a> in Rust are defined using the <code>Option&lt;T&gt;</code> type, which can either be <code>Some(t)</code> or <code>None</code>.</p>
<p>Rust has many traits for converting values or references into others, which provides a lot of convenience in what would otherwise require a lot of explicit conversions.
<a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html" title="" target="_blank">
<code>AsRef&lt;T&gt;</code></a> is such a conversion trait, that can convert itself into <code>&amp;T</code>. 
Here, we use <code>AsRef&lt;Path&gt;</code> as a generic with a trait bound to support many different kinds of values to the <code>path</code> argument in <code>require_file</code>.
For example, we can call <code>context.require_file(&quot;test.txt&quot;)</code> because <code>str</code>, which is the type of string constants, <a href="https://doc.rust-lang.org/src/std/path.rs.html#3136-3141" title="" target="_blank">implements <code>AsRef&lt;Path&gt;</code></a>.
You can also see this as a kind of method overloading, without having to provide concrete overloads for all supported types.</p>
</div>
</details>
<p>Now we need to implement this method for <code>NonIncrementalContext</code>.
However, because we will be performing similar file system operations in the incremental context as well, we will create some utility functions for this first.</p>
<p>Add the <code>fs</code> module to <code>src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::hash::Hash;
 use std::io;
 use std::path::Path;

 mod context;
+mod fs;

 pub trait Task: Clone + Eq + Hash + Debug {
   type Output: Clone + Eq + Debug;
   fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
 }</code></pre>
<p>Create file <code>src/fs.rs</code> with:</p>
<pre><code class="language-rust ">use std::{fs, io};
use std::fs::{File, Metadata};
use std::path::Path;

/// Gets the metadata for given `path`, or `Err(e)` if there was an error getting the metadata, or `Ok(None)` if no file
/// or directory exists at given `path`.
pub fn metadata(path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Option&lt;Metadata&gt;, io::Error&gt; {
  match fs::metadata(path) {
    Err(e) if e.kind() == io::ErrorKind::NotFound =&gt; Ok(None),
    Err(e) =&gt; Err(e),
    Ok(m) =&gt; Ok(Some(m))
  }
}

/// Open file at given `path` if it exists and is a file. This is necessary because on Windows, opening a directory
/// returns an error.
pub fn open_if_file(path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
  let file = match metadata(&amp;path)? {
    Some(metadata) if metadata.is_file() =&gt; Some(File::open(&amp;path)?),
    _ =&gt; None,
  };
  Ok(file)
}</code></pre>
<p>The comments explain the behaviour.</p>
<p>We will write some tests to confirm the behaviour, but for that we need a utility to create temporary files and directories.
Instead of implementing that ourselves, we will use an existing crate.
Add the <code>tempfile</code> dependency to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml customdiff"> [package]
 name = &quot;pie&quot;
 version = &quot;0.1.0&quot;
 edition = &quot;2021&quot;
+
+[dev-dependencies]
+tempfile = &quot;3&quot;
</code></pre>
<p>Note that this is dependency is added under <code>dev-dependencies</code>, indicating that this dependency is only available when running tests, benchmarks, and examples.
Therefore, users of our library will not depend on this library, which is good because temporary file creation is not necessary to users of our library.</p>
<p>Now, add the following tests to <code>src/fs.rs</code>:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use tempfile::{NamedTempFile, TempDir};

  use super::*;

  #[test]
  fn test_metadata_ok() {
    let file = create_temp_file();
    let metadata = metadata(file.path());
    assert!(metadata.is_ok());
    let metadata = metadata.unwrap();
    assert!(metadata.is_some());
    let metadata = metadata.unwrap();
    assert!(metadata.is_file());
  }

  #[test]
  fn test_metadata_none() {
    let file = create_temp_file();
    let path = file.into_temp_path();
    std::fs::remove_file(&amp;path).expect(&quot;failed to delete temporary file&quot;);
    let metadata = metadata(&amp;path);
    assert!(metadata.is_ok());
    let metadata = metadata.unwrap();
    assert!(metadata.is_none());
  }

  #[test]
  fn test_open_if_file() {
    let path = create_temp_file().into_temp_path();
    let file = open_if_file(&amp;path);
    assert!(file.is_ok());
    let file = file.unwrap();
    assert!(file.is_some());
  }

  #[test]
  fn test_open_if_file_non_existent() {
    let path = create_temp_file().into_temp_path();
    std::fs::remove_file(&amp;path).expect(&quot;failed to delete temporary file&quot;);
    let file = open_if_file(&amp;path);
    assert!(file.is_ok());
    let file = file.unwrap();
    assert!(file.is_none());
  }

  #[test]
  fn test_open_if_file_on_directory() {
    let dir = TempDir::new().expect(&quot;failed to create temporary directory&quot;);
    let file = open_if_file(dir.path());
    assert!(file.is_ok());
    let file = file.unwrap();
    assert!(file.is_none());
  }

  fn create_temp_file() -&gt; NamedTempFile {
    NamedTempFile::new().expect(&quot;failed to create temporary file&quot;)
  }
}</code></pre>
<p>Unfortunately, we can't easily test when <code>metadata</code> and <code>open_if_file</code> should return an error, because we cannot disable read permissions on files via the Rust standard library.</p>
<p>Now we are done with our filesystem utility excursion.
Make the non-incremental context compatible by changing <code>src/context/non_incremental.rs</code>:</p>
<pre><code class="language-rust customdiff">+use std::fs::File;
+use std::io;
+use std::path::Path;
+
 use crate::{Context, Task};
+use crate::fs::open_if_file;

 pub struct NonIncrementalContext;

 impl&lt;T: Task&gt; Context&lt;T&gt; for NonIncrementalContext {
   fn require_task(&amp;mut self, task: &amp;T) -&gt; T::Output {
     task.execute(self)
   }
+  fn require_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;Option&lt;File&gt;, io::Error&gt; {
+    let file = open_if_file(&amp;path)?;
+    Ok(file)
+  }
 }</code></pre>
<p>Since the non-incremental context does not track anything, we simply try to open the file and return it.
This implements the description we made earlier:</p>
<ul>
<li>If opening the file results in an error, the <code>?</code> operator returns <code>Err(...)</code> immediately.</li>
<li>If the file does not exist or is a directory, <code>open_if_file</code> returns <code>None</code> and <code>file</code> is <code>None</code>.</li>
<li>Otherwise, <code>file</code> is <code>Some(file)</code>.</li>
</ul>
<p>Confirm everything works with <code>cargo test</code>.</p>
<details id="admonition-rust-help-1" class="admonition info">
<summary class="admonition-title">
<p>Rust Help</p>
<p><a class="admonition-anchor-link" href="#admonition-rust-help-1"></a></p>
</summary>
<div>
<p>The <code>?</code> operator makes it easy to <a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator" title="" target="_blank">propgate errors</a>.
Because errors are just values in Rust, to propgate an error, you'd normally have to match each result and manually propagate the error.
The <code>r?</code> operator applied to a <code>Result</code> <code>r</code> does this for you, it basically desugars to something like <code>match r { Err(e) =&gt; return Err(e), _ =&gt; {} }</code>.</p>
<p>Comments with three forward slashes <code>///</code> are <a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments" title="" target="_blank">documentation comments</a> that document the function/struct/enum/trait/etc. they are applied to.</p>
</div>
</details>
<h2 id="implementing-the-incremental-context"><a class="header" href="#implementing-the-incremental-context">Implementing the Incremental Context</a></h2>
<p>Now we get to the fun part, incrementality!</p>
<p>To check whether we need to execute a task, we need to check the dependencies of that task to see if any of them are not consistent.
If they are all consistent, we just return the cached output of the task.
If not, we just execute the task.</p>
<p>To implement this, we will need 3 components:</p>
<ul>
<li>A <code>Dependency</code> type which holds dependency data with methods for checking consistency.</li>
<li>A <code>Store</code> type which holds the dependency graph with methods for interacting with the graph.</li>
<li>A <code>TopDownContext</code> type that implements <code>Context</code> and owns a <code>Store</code>.</li>
</ul>
<p>We will start with implementing <code>Dependency</code>, as it can be implemented as a stand-alone part.</p>
<h3 id="dependency-implementation"><a class="header" href="#dependency-implementation">Dependency implementation</a></h3>
<p>Add the <code>dependency</code> module to <code>src/lib.rs</code>:</p>
<pre><code class="language-rust customdiff"> use std::io;
 use std::path::Path;

 mod context;
 mod fs;
+mod dependency;

 pub trait Task: Clone + Eq + Hash + Debug {
   type Output: Clone + Eq + Debug;
   fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output;
 }</code></pre>
<p>Then create the <code>src/dependency.rs</code> file and add:</p>
<pre><code class="language-rust ">use std::fmt::Debug;
use std::fs::File;
use std::io;
use std::path::Path;
use std::path::PathBuf;
use std::time::SystemTime;

use crate::{Context, Task};
use crate::fs::{metadata, open_if_file};

#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct TaskDependency&lt;T, O&gt; {
  pub task: T,
  pub output: O,
}

impl&lt;T: Task&gt; TaskDependency&lt;T, T::Output&gt; {
  pub fn new(task: T, output: T::Output) -&gt; Self {
    Self { task, output }
  }

  pub fn is_inconsistent&lt;C: Context&lt;T&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; bool {
    let output = context.require_task(&amp;self.task);
    output != self.output
  }
}


#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct FileDependency {
  pub path: PathBuf,
  pub modified_date: Option&lt;SystemTime&gt;,
}

impl FileDependency {
  pub fn new(path: impl Into&lt;PathBuf&gt;) -&gt; Result&lt;(Self, Option&lt;File&gt;), io::Error&gt; {
    let path = path.into();
    let modified_date = Self::modified_date(&amp;path)?;
    let file = open_if_file(&amp;path)?;
    let dependency = Self { path, modified_date };
    Ok((dependency, file))
  }

  pub fn is_inconsistent(&amp;self) -&gt; Result&lt;bool, io::Error&gt; {
    let modified_date = Self::modified_date(&amp;self.path)?;
    Ok(modified_date != self.modified_date)
  }

  fn modified_date(path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Option&lt;SystemTime&gt;, io::Error&gt; {
    let modified_date = if let Some(metadata) = metadata(path)? {
      Some(metadata.modified()?)
    } else {
      None // File does not exist -&gt; no modified date.
    };
    Ok(modified_date)
  }
}


#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub enum Dependency&lt;T, O&gt; {
  RequireTask(TaskDependency&lt;T, O&gt;),
  RequireFile(FileDependency),
}

impl&lt;T: Task&gt; Dependency&lt;T, T::Output&gt; {
  pub fn is_inconsistent&lt;C: Context&lt;T&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Result&lt;bool, io::Error&gt; {
    match self {
      Dependency::RequireTask(d) =&gt; Ok(d.is_inconsistent(context)),
      Dependency::RequireFile(d) =&gt; d.is_inconsistent(),
    }
  }
}</code></pre>
<p>We implement the <code>TaskDependency</code> and <code>FileDependency</code> types to handle task and file dependencies respectively.
We merge those two kinds of dependencies into the <code>Dependency</code> enum.
This split is made so that users of this module can accept only task or file dependencies, or any dependency in general, which we will need in the future.</p>
<p>A task dependency is inconsistent if, after recursively checking it, its output has changed.
The <code>TaskDependency::is_inconsistent</code> does exactly that, by requiring the task with a context, and then checking if the output has changed.
We implement a <code>is_inconsistent</code> method here instead of an <code>is_consistent</code> method, because we will change it in the future to return the changed output for logging purposes, and in that case we want to see the changed output if it is not consistent.</p>
<p>A file dependency is inconsistent if its last modification date has changed, or if the file did not exist before but does now (and vice versa), implemented in <code>FileDependency::is_inconsistent</code>.
If a file does not exist, we use <code>None</code> as the modification date, which does not equal <code>Some(modified_date)</code>.
We deal with errors (<code>io::Error</code>) by propagating them.</p>
<p>The <code>FileDependency::new</code> function also returns the opened file if it exists, so that users of this function can read from the file without having to open it again.</p>
<p>Finally, <code>Dependency</code> just merges the two kinds of dependencies and provides an <code>is_inconsistent</code> method that calls the corresponding method.</p>
<p>As usual, we write some tests to confirm the behaviour. Add tests to <code>src/dependency.rs</code>:</p>
<pre><code class="language-rust ">#[cfg(test)]
mod test {
  use std::fs;
  use std::io::Read;

  use tempfile::{NamedTempFile, TempPath};

  use crate::context::non_incremental::NonIncrementalContext;

  use super::*;

  #[derive(Clone, PartialEq, Eq, Hash, Debug)]
  struct ReadStringFromFile(PathBuf);

  impl Task for ReadStringFromFile {
    type Output = String;
    fn execute&lt;C: Context&lt;Self&gt;&gt;(&amp;self, context: &amp;mut C) -&gt; Self::Output {
      let mut string = String::new();
      if let Some(mut file) = context.require_file(&amp;self.0).expect(&quot;failed to require file&quot;) {
        file.read_to_string(&amp;mut string).expect(&quot;failed to read from file&quot;);
      };
      string
    }
  }

  #[test]
  fn test_task_dependency_consistency() {
    let mut context = NonIncrementalContext;

    let path = create_temp_path();
    fs::write(&amp;path, &quot;test1&quot;).expect(&quot;failed to write to file&quot;);
    let task = ReadStringFromFile(path.to_path_buf());
    let output = context.require_task(&amp;task);

    let task_dependency = TaskDependency::new(task.clone(), output);
    let dependency = Dependency::RequireTask(task_dependency.clone());
    assert!(!task_dependency.is_inconsistent(&amp;mut context));
    assert!(!dependency.is_inconsistent(&amp;mut context).expect(&quot;failed to check for inconsistency&quot;));

    fs::write(&amp;path, &quot;test2&quot;).expect(&quot;failed to write to file&quot;);
    assert!(task_dependency.is_inconsistent(&amp;mut context));
    assert!(dependency.is_inconsistent(&amp;mut context).expect(&quot;failed to check for inconsistency&quot;));
  }

  #[test]
  fn test_file_dependency_consistency() {
    let mut context = NonIncrementalContext;

    let path = create_temp_path();
    fs::write(&amp;path, &quot;test1&quot;).expect(&quot;failed to write to file&quot;);

    let (file_dependency, _) = FileDependency::new(&amp;path).expect(&quot;failed to create file dependency&quot;);
    let dependency: Dependency&lt;ReadStringFromFile, String&gt; = Dependency::RequireFile(file_dependency.clone());
    assert!(!file_dependency.is_inconsistent().expect(&quot;failed to check for inconsistency&quot;));
    assert!(!dependency.is_inconsistent(&amp;mut context).expect(&quot;failed to check for inconsistency&quot;));

    fs::write(&amp;path, &quot;test2&quot;).expect(&quot;failed to write to file&quot;);
    assert!(file_dependency.is_inconsistent().expect(&quot;failed to check for inconsistency&quot;));
    assert!(dependency.is_inconsistent(&amp;mut context).expect(&quot;failed to check for inconsistency&quot;));
  }

  fn create_temp_path() -&gt; TempPath {
    NamedTempFile::new().expect(&quot;failed to create temporary file&quot;).into_temp_path()
  }
}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../api/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../api/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../src/diff.js"></script>


    </div>
    </body>
</html>
